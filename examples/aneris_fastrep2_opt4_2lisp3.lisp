(defun nvbtrue ()
(make-inl :val (make-axiom)))

(defun nvbor (nvp nvq)
(if (inl-p nvp)
(nvbtrue)
nvq))

(defun nvbfalse ()
(make-inr :val (make-axiom)))

(defun nvreduce (nvf nvk nvas)
(funcall (fix (lambda (nvlist_ind)
(lambda (nvL)
(if (pair-p (funcall nvL))
(let ((pair (funcall nvL)))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(funcall (funcall nvf
(lambda () nvh))
(lambda () (funcall (funcall nvlist_ind)
(lambda () nvt))))))
(if (axiom-p (funcall nvL))
nvk
(error "bottom"))))))
(lambda () nvas)))

(defun nvdeq-member (nveq nvx nvL)
(nvreduce (lambda (nva)
(lambda (nvb)
(nvbor (funcall (funcall nveq
(lambda () (funcall nva)))
(lambda () nvx)) (funcall nvb)))) (nvbfalse) nvL))

(defun nvisr (nvx)
(let ((dec nvx))
(if (inl-p dec)
(nvbfalse)
(if (inr-p dec)
(nvbtrue)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))

(defun nvhdf-halted (nvP)
(nvisr nvP))

(defun nvband (nvp nvq)
(if (inl-p nvp)
nvq
(nvbfalse)))

(defun nvhdf-halt ()
(make-inr :val (make-axiom)))

(defun nvhdf-ap (nvX nva)
(let ((dec nvX))
(if (inl-p dec)
(let ((nvP (inl-val dec)))
(funcall nvP
(lambda () nva)))
(if (inr-p dec)
(make-pair :fst (make-inr :val (make-axiom)) :snd (make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))

(defun nvappend (nvas nvbs)
(funcall (fix (lambda (nvlist_ind)
(lambda (nvL)
(if (pair-p (funcall nvL))
(let ((pair (funcall nvL)))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(make-pair :fst nvh :snd (funcall (funcall nvlist_ind)
(lambda () nvt)))))
(if (axiom-p (funcall nvL))
nvbs
(error "bottom"))))))
(lambda () nvas)))

(defun nvbag-append (nvas nvbs)
(nvappend nvas nvbs))

(defun nvhdf-run (nvP)
(make-inl :val nvP))

(defun nvhdf-parallel (nvX nvY)
(funcall (fix (lambda (nvmk-hdf)
(lambda (nvs0)
(if (inl-p (let ((pair (funcall nvs0)))
(let ((nvX (pair-fst pair))
(nvY (pair-snd pair)))
(nvband (nvhdf-halted nvX) (nvhdf-halted nvY)))))
(nvhdf-halt)
(nvhdf-run (lambda (nvm)
(let ((pair (let ((pair (funcall nvs0)))
(let ((nvX (pair-fst pair))
(nvY (pair-snd pair)))
(let ((pair (nvhdf-ap nvX (funcall nvm))))
(let ((nvX_ (pair-fst pair))
(nvxs (pair-snd pair)))
(let ((pair (nvhdf-ap nvY (funcall nvm))))
(let ((nvY_ (pair-fst pair))
(nvys (pair-snd pair)))
(let ((nvout (nvbag-append nvxs nvys)))
(make-pair :fst (make-pair :fst nvX_ :snd nvY_) :snd nvout))))))))))
(let ((nvs1 (pair-fst pair))
(nvb (pair-snd pair)))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvs1)) :snd nvb)))))))))
(lambda () (make-pair :fst nvX :snd nvY))))

(defun nveq_atom (nvx nvy)
(if (string= nvx nvy)
(nvbtrue)
(nvbfalse)))

(defun nvatom-deq ()
(lambda (nva)
(lambda (nvb)
(nveq_atom (funcall nva) (funcall nvb)))))

(defun nvnull (nvas)
(funcall (fix (lambda (nvlist_ind)
(declare (ignore nvlist_ind))
(lambda (nvL)
(if (pair-p (funcall nvL))
(let ((pair (funcall nvL)))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(declare (ignore nvh))
(declare (ignore nvt))
(nvbfalse)))
(if (axiom-p (funcall nvL))
(nvbtrue)
(error "bottom"))))))
(lambda () nvas)))

(defun nvlist-deq (nveq)
(lambda (nvas)
(lambda (nvbs)
(funcall (funcall (fix (lambda (nvlist_ind)
(lambda (nvL)
(if (pair-p (funcall nvL))
(let ((pair (funcall nvL)))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(lambda (nvL)
(funcall (fix (lambda (nvlist_ind_)
(declare (ignore nvlist_ind_))
(lambda (nvL)
(if (pair-p (funcall nvL))
(let ((pair (funcall nvL)))
(let ((nvh_ (pair-fst pair))
(nvt_ (pair-snd pair)))
(nvband (funcall (funcall nveq
(lambda () nvh))
(lambda () nvh_)) (funcall (funcall (funcall nvlist_ind)
(lambda () nvt))
(lambda () nvt_)))))
(if (axiom-p (funcall nvL))
(nvbfalse)
(error "bottom"))))))
(lambda () (funcall nvL))))))
(if (axiom-p (funcall nvL))
(lambda (nvL)
(nvnull (funcall nvL)))
(error "bottom"))))))
(lambda () (funcall nvas)))
(lambda () (funcall nvbs))))))

(defun nvname-deq ()
(nvlist-deq (nvatom-deq)))

(defun nvname_eq (nvx nvy)
(funcall (funcall (nvname-deq)
(lambda () nvx))
(lambda () nvy)))

(defun nvmap (nvf nvas)
(funcall (fix (lambda (nvlist_ind)
(lambda (nvL)
(if (pair-p (funcall nvL))
(let ((pair (funcall nvL)))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(make-pair :fst (funcall nvf
(lambda () nvh)) :snd (funcall (funcall nvlist_ind)
(lambda () nvt)))))
(if (axiom-p (funcall nvL))
(make-axiom)
(error "bottom"))))))
(lambda () nvas)))

(defun nvbag-null (nvbs)
(nvnull nvbs))

(defun nvbag-map (nvf nvbs)
(nvmap nvf nvbs))

(defun nvconcat (nvll)
(nvreduce (lambda (nvl)
(lambda (nvl_)
(nvappend (funcall nvl) (funcall nvl_)))) (make-axiom) nvll))

(defun nvbag-union (nvbbs)
(nvconcat nvbbs))

(defun nvId ()
"ATOM")

(defun nveq_int (nvi nvj)
(if (= nvi nvj)
(nvbtrue)
(nvbfalse)))

(defun nvint-deq ()
(lambda (nva)
(lambda (nvb)
(nveq_int (funcall nva) (funcall nvb)))))

(defun nvpi1 (nvt)
(let ((pair nvt))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(declare (ignore nvy))
nvx)))

(defun nvpi2 (nvt)
(let ((pair nvt))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(declare (ignore nvx))
nvy)))

(defun nvproddeq (nva nvb)
(lambda (nvp)
(lambda (nvq)
(nvband (funcall (funcall nva
(lambda () (nvpi1 (funcall nvp))))
(lambda () (nvpi1 (funcall nvq)))) (funcall (funcall nvb
(lambda () (nvpi2 (funcall nvp))))
(lambda () (nvpi2 (funcall nvq))))))))

(defun nvproduct-deq (nvAA nvBB nva nvb)
(declare (ignore nvAA))
(declare (ignore nvBB))
(nvproddeq nva nvb))

(defun nvunit-deq ()
(lambda (nva)
(declare (ignore nva))
(lambda (nvb)
(declare (ignore nvb))
(nvbtrue))))

(defun nvsumdeq (nva nvb)
(lambda (nvp)
(lambda (nvq)
(let ((dec (funcall nvp)))
(if (inl-p dec)
(let ((nvpa (inl-val dec)))
(let ((dec (funcall nvq)))
(if (inl-p dec)
(let ((nvqa (inl-val dec)))
(funcall (funcall nva
(lambda () nvpa))
(lambda () nvqa)))
(if (inr-p dec)
(nvbfalse)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(if (inr-p dec)
(let ((nvpb (inr-val dec)))
(let ((dec (funcall nvq)))
(if (inl-p dec)
(nvbfalse)
(if (inr-p dec)
(let ((nvqb (inr-val dec)))
(funcall (funcall nvb
(lambda () nvpb))
(lambda () nvqb)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))

(defun nvunion-deq (nvAA nvBB nva nvb)
(declare (ignore nvAA))
(declare (ignore nvBB))
(nvsumdeq nva nvb))

(defun nvaneris_pax_v1_eq_bnums ()
(lambda (nvbn1)
(lambda (nvbn2)
(funcall (funcall (nvunion-deq "PRODUCT" "EQUAL" (nvproduct-deq "INT" (nvId) (nvint-deq) (lambda (nva)
(lambda (nvb)
(if (string= (funcall nva) (funcall nvb))
(make-inl :val (make-axiom))
(make-inr :val (make-axiom)))))) (nvunit-deq))
(lambda () (funcall nvbn1)))
(lambda () (funcall nvbn2))))))

(defun nvlength (nvas)
(funcall (fix (lambda (nvlength)
(lambda (nvas)
(funcall (fix (lambda (nvlist_ind)
(declare (ignore nvlist_ind))
(lambda (nvL)
(if (pair-p (funcall nvL))
(let ((pair (funcall nvL)))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(declare (ignore nvh))
(+ (funcall (funcall nvlength)
(lambda () nvt)) 1)))
(if (axiom-p (funcall nvL))
0
(error "bottom"))))))
(lambda () (funcall nvas))))))
(lambda () nvas)))

(defun nvbag-size (nvbs)
(nvlength nvbs))

(defun nvaneris_pax_v1_threshold (nvaccpts)
(/ (+ (nvbag-size nvaccpts) 1) 2))

(defun nvlt_int (nvi nvj)
(if (< nvi nvj)
(nvbtrue)
(nvbfalse)))

(defun nvmake-Msg (nvhdr nvval)
(make-pair :fst nvhdr :snd nvval))

(defun nvmake-msg-interface (nvi nvl nvm)
(make-pair :fst nvi :snd (make-pair :fst nvl :snd nvm)))

(defun nvmk-msg-interface (nvl nvm)
(nvmake-msg-interface 0 nvl nvm))

(defun nvaneris_pax_v1_adopted_send (nvCmd nvdecision nvpropose nvzs)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvzs))
(lambda (nvl)
(lambda (nvz)
(nvmk-msg-interface (funcall nvl) (nvmake-Msg (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "adopted" :snd (make-axiom))) (funcall nvz))))))

(defun nvsingle-bag (nvx)
(make-pair :fst nvx :snd (make-axiom)))

(defun nvaneris_pax_v1_preempted_send (nvCmd nvdecision nvpropose nvzs)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvzs))
(lambda (nvl)
(lambda (nvz)
(nvmk-msg-interface (funcall nvl) (nvmake-Msg (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "preempted" :snd (make-axiom))) (funcall nvz))))))

(defun nvaneris_pax_v1_scout_output (nvCmd nvaccpts nvdecision nvpropose nvzs)
(lambda (nvbnum)
(lambda (nvldr)
(lambda (nvzl)
(let ((pair (funcall nvzl)))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(declare (ignore nvw))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz (pair-snd pair)))
(declare (ignore nvz))
(lambda (nvz_)
(let ((pair (funcall nvz_)))
(let ((nvwaitfor (pair-fst pair))
(nvpvalues (pair-snd pair)))
(if (inl-p (funcall (funcall (nvaneris_pax_v1_eq_bnums)
(lambda () (funcall nvbnum)))
(lambda () nvx)))
(if (inl-p (funcall (funcall (nvaneris_pax_v1_eq_bnums)
(lambda () (funcall nvbnum)))
(lambda () nvy)))
(if (inl-p (nvlt_int (nvbag-size nvwaitfor) (nvaneris_pax_v1_threshold nvaccpts)))
(nvsingle-bag (funcall (funcall (nvaneris_pax_v1_adopted_send nvCmd nvdecision nvpropose nvzs)
(lambda () (funcall nvldr)))
(lambda () (make-pair :fst (funcall nvbnum) :snd nvpvalues))))
(make-axiom))
(nvsingle-bag (funcall (funcall (nvaneris_pax_v1_preempted_send nvCmd nvdecision nvpropose nvzs)
(lambda () (funcall nvldr)))
(lambda () nvy))))
(make-axiom)))))))))))))))

(defun nvaneris_pax_v1_mk_bnum ()
(lambda (nvn)
(lambda (nvloc)
(make-inl :val (make-pair :fst (funcall nvn) :snd (funcall nvloc))))))

(defun nvaneris_pax_v1_prp2slt (nvCmd)
(declare (ignore nvCmd))
(lambda (nvproposal)
(nvpi1 (funcall nvproposal))))

(defun nvaneris_pax_v1_pv2prp (nvCmd)
(declare (ignore nvCmd))
(lambda (nvpvalue)
(nvpi2 (funcall nvpvalue))))

(defun nvint-minus-comparison (nvf)
(lambda (nvx)
(lambda (nvy)
(- (funcall nvf
(lambda () (funcall nvx))) (funcall nvf
(lambda () (funcall nvy)))))))

(defun nvbnot (nvb)
(if (inl-p nvb)
(nvbfalse)
(nvbtrue)))

(defun nvle_int (nvi nvj)
(nvbnot (nvlt_int nvj nvi)))

(defun nvaneris_pax_v1_leq_bnum_ (nvldrs_uid)
(lambda (nvza)
(let ((pair (funcall nvza)))
(let ((nvi1 (pair-fst pair))
(nvl1 (pair-snd pair)))
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvi2 (pair-fst pair))
(nvl2 (pair-snd pair)))
(nvbor (nvlt_int nvi1 nvi2) (nvband (nveq_int nvi1 nvi2) (nvle_int (funcall nvldrs_uid
(lambda () nvl1)) (funcall nvldrs_uid
(lambda () nvl2))))))))))))

(defun nvaneris_pax_v1_leq_bnum (nvldrs_uid)
(lambda (nvbn1)
(lambda (nvbn2)
(let ((dec (funcall nvbn1)))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(let ((dec (funcall nvbn2)))
(if (inl-p dec)
(let ((nvx2 (inl-val dec)))
(funcall (funcall (nvaneris_pax_v1_leq_bnum_ nvldrs_uid)
(lambda () nvx1))
(lambda () nvx2)))
(if (inr-p dec)
(nvbfalse)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(if (inr-p dec)
(nvbtrue)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))

(defun nvaneris_pax_v1_pv2bn (nvCmd)
(declare (ignore nvCmd))
(lambda (nvpvalue)
(nvpi1 (funcall nvpvalue))))

(defun nvinsert-combine (nvcmp nvf nvx nvl)
(funcall (fix (lambda (nvlist_ind)
(lambda (nvL)
(if (pair-p (funcall nvL))
(let ((pair (funcall nvL)))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(let ((nvtst (funcall (funcall nvcmp
(lambda () nvx))
(lambda () nvh))))
(if (inl-p (nveq_int nvtst 0))
(make-pair :fst (funcall (funcall nvf
(lambda () nvx))
(lambda () nvh)) :snd nvt)
(if (inl-p (nvlt_int 0 nvtst))
(make-pair :fst nvx :snd (make-pair :fst nvh :snd nvt))
(make-pair :fst nvh :snd (funcall (funcall nvlist_ind)
(lambda () nvt))))))))
(if (axiom-p (funcall nvL))
(make-pair :fst nvx :snd (make-axiom))
(error "bottom"))))))
(lambda () nvl)))

(defun nvaneris_pax_v1_add_pvalue (nvCmd nvldrs_uid)
(lambda (nvpvalues)
(lambda (nvpvalue)
(nvinsert-combine (nvint-minus-comparison (lambda (nvpv)
(funcall (nvaneris_pax_v1_prp2slt nvCmd)
(lambda () (funcall (nvaneris_pax_v1_pv2prp nvCmd)
(lambda () (funcall nvpv))))))) (lambda (nvpv1)
(lambda (nvpv2)
(if (inl-p (funcall (funcall (nvaneris_pax_v1_leq_bnum nvldrs_uid)
(lambda () (funcall (nvaneris_pax_v1_pv2bn nvCmd)
(lambda () (funcall nvpv1)))))
(lambda () (funcall (nvaneris_pax_v1_pv2bn nvCmd)
(lambda () (funcall nvpv2))))))
(funcall nvpv2)
(funcall nvpv1)))) (funcall nvpvalue) (funcall nvpvalues)))))

(defun nvaneris_pax_v1_add_new_pvalues (nvCmd nvldrs_uid)
(lambda (nvpvals1)
(lambda (nvpvals2)
(nvreduce (lambda (nvpv)
(lambda (nvr)
(funcall (funcall (nvaneris_pax_v1_add_pvalue nvCmd nvldrs_uid)
(lambda () (funcall nvr)))
(lambda () (funcall nvpv))))) (funcall nvpvals2) (funcall nvpvals1)))))

(defun nvfilter (nvP nvl)
(nvreduce (lambda (nva)
(lambda (nvv)
(if (inl-p (funcall nvP
(lambda () (funcall nva))))
(make-pair :fst (funcall nva) :snd (funcall nvv))
(funcall nvv)))) (make-axiom) nvl))

(defun nvbag-remove (nveq nvbs nvx)
(nvfilter (lambda (nvx_)
(nvbnot (funcall (funcall nveq
(lambda () nvx))
(lambda () (funcall nvx_))))) nvbs))

(defun nvaneris_pax_v1_on_p1b (nvCmd nvldrs_uid)
(lambda (nvbnum)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvzj)
(let ((pair (funcall nvzj)))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz (pair-snd pair)))
(lambda (nvz_)
(let ((pair (funcall nvz_)))
(let ((nvwaitfor (pair-fst pair))
(nvpvalues (pair-snd pair)))
(if (inl-p (nvband (funcall (funcall (nvaneris_pax_v1_eq_bnums)
(lambda () (funcall nvbnum)))
(lambda () nvx)) (funcall (funcall (nvaneris_pax_v1_eq_bnums)
(lambda () (funcall nvbnum)))
(lambda () nvy))))
(funcall (lambda (nvx)
(funcall (lambda (nvx_)
(make-pair :fst (funcall nvx) :snd (funcall nvx_)))
(lambda () (funcall (funcall (nvaneris_pax_v1_add_new_pvalues nvCmd nvldrs_uid)
(lambda () nvpvalues))
(lambda () nvz)))))
(lambda () (nvbag-remove (lambda (nva)
(lambda (nvb)
(if (string= (funcall nva) (funcall nvb))
(make-inl :val (make-axiom))
(make-inr :val (make-axiom))))) nvwaitfor nvw)))
(make-pair :fst nvwaitfor :snd nvpvalues)))))))))))))))

(defun nvaneris_pax_v1_p1a_broadcast (nvCmd nvdecision nvpropose nvzs)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvzs))
(lambda (nvlocs)
(lambda (nvz)
(nvbag-map (lambda (nvl)
(nvmk-msg-interface (funcall nvl) (nvmake-Msg (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p1a" :snd (make-axiom))) (funcall nvz)))) (funcall nvlocs)))))

(defun nvaneris_pax_v1_init_pvalues (nvCmd)
(declare (ignore nvCmd))
(make-axiom))

(defun nvaneris_pax_v1_init_scout (nvCmd nvaccpts)
(make-pair :fst nvaccpts :snd (nvaneris_pax_v1_init_pvalues nvCmd)))

(defun nvbind-nxt (nvY nvp nva)
(let ((pair nvp))
(let ((nvX (pair-fst pair))
(nvys (pair-snd pair)))
(let ((pair (nvhdf-ap nvX nva)))
(let ((nvX_ (pair-fst pair))
(nvb (pair-snd pair)))
(let ((nvybs (nvbag-map (lambda (nvP)
(nvhdf-ap (funcall nvP) nva)) (nvbag-append nvys (nvbag-map nvY nvb)))))
(let ((nvys_ (nvfilter (lambda (nvx)
(nvbnot (nvhdf-halted (funcall nvx)))) (nvbag-map (lambda (nvyb)
(nvpi1 (funcall nvyb))) nvybs))))
(let ((nvout (nvbag-union (nvbag-map (lambda (nvx)
(nvpi2 (funcall nvx))) nvybs))))
(make-pair :fst (make-pair :fst nvX_ :snd nvys_) :snd nvout)))))))))

(defun nvhdf-bind (nvX nvY)
(funcall (fix (lambda (nvmk-hdf)
(lambda (nvs0)
(if (inl-p (let ((pair (funcall nvs0)))
(let ((nvX (pair-fst pair))
(nvys (pair-snd pair)))
(nvband (nvhdf-halted nvX) (nvbag-null nvys)))))
(nvhdf-halt)
(nvhdf-run (lambda (nvm)
(let ((pair (nvbind-nxt nvY (funcall nvs0) (funcall nvm))))
(let ((nvs1 (pair-fst pair))
(nvb (pair-snd pair)))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvs1)) :snd nvb)))))))))
(lambda () (make-pair :fst nvX :snd (make-axiom)))))

(defun nvhdf-once (nvX)
(funcall (fix (lambda (nvmk-hdf)
(lambda (nvs0)
(if (inl-p (nvhdf-halted (funcall nvs0)))
(nvhdf-halt)
(nvhdf-run (lambda (nvm)
(let ((pair (let ((pair (nvhdf-ap (funcall nvs0) (funcall nvm))))
(let ((nvX_ (pair-fst pair))
(nvb (pair-snd pair)))
(make-pair :fst (if (inl-p (nvbag-null nvb))
nvX_
(nvhdf-halt)) :snd nvb)))))
(let ((nvs1 (pair-fst pair))
(nvb (pair-snd pair)))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvs1)) :snd nvb)))))))))
(lambda () nvX)))

(defun nvaneris_pax_v1_dest_prp (nvCmd)
(declare (ignore nvCmd))
(lambda (nvproposal)
(funcall nvproposal)))

(defun nvaneris_pax_v1_is_in_missing ()
(lambda (nvslt)
(lambda (nvmissing)
(nvreduce (lambda (nvh)
(lambda (nvr)
(if (inl-p (nvlt_int (funcall nvslt) (funcall nvh)))
(nvbfalse)
(if (inl-p (nveq_int (funcall nvslt) (funcall nvh)))
(nvbtrue)
(funcall nvr))))) (nvbfalse) (funcall nvmissing)))))

(defun nvaneris_pax_v1_is_decided ()
(lambda (nvslt)
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvmax (pair-fst pair))
(nvmissing (pair-snd pair)))
(nvband (nvle_int (funcall nvslt) nvmax) (nvbnot (funcall (funcall (nvaneris_pax_v1_is_in_missing)
(lambda () (funcall nvslt)))
(lambda () nvmissing)))))))))

(defun nvaneris_pax_v1_mk_prp (nvCmd)
(declare (ignore nvCmd))
(lambda (nvslt)
(lambda (nvcmd)
(make-pair :fst (funcall nvslt) :snd (funcall nvcmd)))))

(defun nvaneris_pax_v1_add_proposal_if_not_in (nvCCmd)
(lambda (nvproposals)
(lambda (nvslt)
(lambda (nvcmd)
(nvinsert-combine (nvint-minus-comparison (nvaneris_pax_v1_prp2slt nvCCmd)) (lambda (nvprp1)
(declare (ignore nvprp1))
(lambda (nvprp2)
(funcall nvprp2))) (funcall (funcall (nvaneris_pax_v1_mk_prp nvCCmd)
(lambda () (funcall nvslt)))
(lambda () (funcall nvcmd))) (funcall nvproposals))))))

(defun nvaneris_pax_v1_on_propose (nvCmd)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvproposal)
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz_ (pair-snd pair)))
(let ((pair (funcall (nvaneris_pax_v1_dest_prp nvCmd)
(lambda () (funcall nvproposal)))))
(let ((nvslt (pair-fst pair))
(nvcmd (pair-snd pair)))
(funcall (lambda (nvx_)
(make-pair :fst nvw :snd (make-pair :fst nvx :snd (make-pair :fst (funcall nvx_) :snd nvz_))))
(lambda () (if (inl-p (funcall (funcall (nvaneris_pax_v1_is_decided)
(lambda () nvslt))
(lambda () nvz_)))
nvy
(funcall (funcall (funcall (nvaneris_pax_v1_add_proposal_if_not_in nvCmd)
(lambda () nvy))
(lambda () nvslt))
(lambda () nvcmd)))))))))))))))))

(defun nvaneris_pax_v1_in_proposals (nvCmd)
(lambda (nvslt)
(lambda (nvproposals)
(nvreduce (lambda (nvprp)
(lambda (nvr)
(let ((pair (funcall (nvaneris_pax_v1_dest_prp nvCmd)
(lambda () (funcall nvprp)))))
(let ((nvslt_ (pair-fst pair))
(nvcmd (pair-snd pair)))
(declare (ignore nvcmd))
(if (inl-p (nvlt_int nvslt_ (funcall nvslt)))
(nvbfalse)
(if (inl-p (nveq_int (funcall nvslt) nvslt_))
(nvbtrue)
(funcall nvr))))))) (nvbfalse) (funcall nvproposals)))))

(defun nvaneris_pax_v1_mk_pv (nvCmd)
(declare (ignore nvCmd))
(lambda (nvbn)
(lambda (nvprp)
(make-pair :fst (funcall nvbn) :snd (funcall nvprp)))))

(defun nvaneris_pax_v1_leader_propose (nvCmd)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvproposal)
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz_ (pair-snd pair)))
(funcall (lambda (nvx_)
(if (inl-p (nvband nvx (nvband (nvbnot (funcall (funcall (nvaneris_pax_v1_in_proposals nvCmd)
(lambda () (funcall nvx_)))
(lambda () nvy))) (nvbnot (funcall (funcall (nvaneris_pax_v1_is_decided)
(lambda () (funcall nvx_)))
(lambda () nvz_))))))
(nvsingle-bag (funcall (funcall (nvaneris_pax_v1_mk_pv nvCmd)
(lambda () nvw))
(lambda () (funcall nvproposal))))
(make-axiom)))
(lambda () (funcall (nvaneris_pax_v1_prp2slt nvCmd)
(lambda () (funcall nvproposal)))))))))))))))

(defun nvcons-bag (nvx nvb)
(make-pair :fst nvx :snd nvb))

(defun nvaneris_pax_v1_dest_pv (nvCmd)
(lambda (nvpvalue)
(let ((pair (funcall nvpvalue)))
(let ((nvbn (pair-fst pair))
(nvprp (pair-snd pair)))
(make-pair :fst nvbn :snd (funcall (nvaneris_pax_v1_dest_prp nvCmd)
(lambda () nvprp)))))))

(defun nvaneris_pax_v1_add_proposal (nvCCmd)
(lambda (nvproposals)
(lambda (nvslt)
(lambda (nvcmd)
(nvinsert-combine (nvint-minus-comparison (nvaneris_pax_v1_prp2slt nvCCmd)) (lambda (nvprp1)
(lambda (nvprp2)
(declare (ignore nvprp2))
(funcall nvprp1))) (funcall (funcall (nvaneris_pax_v1_mk_prp nvCCmd)
(lambda () (funcall nvslt)))
(lambda () (funcall nvcmd))) (funcall nvproposals))))))

(defun nvaneris_pax_v1_update_proposals (nvCmd)
(lambda (nvproposals)
(lambda (nvdecided)
(lambda (nvpvals)
(funcall (funcall (fix (lambda (nvlist_accum)
(lambda (nvy)
(lambda (nvL)
(if (pair-p (funcall nvL))
(let ((pair (funcall nvL)))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(funcall (funcall (funcall nvlist_accum)
(lambda () (let ((pair (funcall (nvaneris_pax_v1_dest_pv nvCmd)
(lambda () nvh))))
(let ((nvx (pair-fst pair))
(nvzz (pair-snd pair)))
(declare (ignore nvx))
(let ((pair nvzz))
(let ((nvy_ (pair-fst pair))
(nvz (pair-snd pair)))
(if (inl-p (funcall (funcall (nvaneris_pax_v1_is_decided)
(lambda () nvy_))
(lambda () (funcall nvdecided))))
(funcall nvy)
(funcall (funcall (funcall (nvaneris_pax_v1_add_proposal nvCmd)
(lambda () (funcall nvy)))
(lambda () nvy_))
(lambda () nvz)))))))))
(lambda () nvt))))
(if (axiom-p (funcall nvL))
(funcall nvy)
(error "bottom")))))))
(lambda () (funcall nvproposals)))
(lambda () (funcall nvpvals)))))))

(defun nvaneris_pax_v1_leader_adopted (nvCmd)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvzp)
(let ((pair (funcall nvzp)))
(let ((nvbnum (pair-fst pair))
(nvpvals (pair-snd pair)))
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(declare (ignore nvx))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz_ (pair-snd pair)))
(if (inl-p (funcall (funcall (nvaneris_pax_v1_eq_bnums)
(lambda () nvbnum))
(lambda () nvw)))
(funcall (funcall (fix (lambda (nvlist_accum)
(lambda (nvy_)
(lambda (nvL)
(if (pair-p (funcall nvL))
(let ((pair (funcall nvL)))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(funcall (funcall (funcall nvlist_accum)
(lambda () (nvcons-bag (funcall (funcall (nvaneris_pax_v1_mk_pv nvCmd)
(lambda () nvbnum))
(lambda () nvh)) (funcall nvy_))))
(lambda () nvt))))
(if (axiom-p (funcall nvL))
(funcall nvy_)
(error "bottom")))))))
(lambda () (make-axiom)))
(lambda () (funcall (funcall (funcall (nvaneris_pax_v1_update_proposals nvCmd)
(lambda () nvy))
(lambda () nvz_))
(lambda () nvpvals))))
(make-axiom))))))))))))))

(defun nvaneris_pax_v1_when_adopted (nvCmd)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvzm)
(let ((pair (funcall nvzm)))
(let ((nvbnum (pair-fst pair))
(nvpvals (pair-snd pair)))
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz_ (pair-snd pair)))
(if (inl-p (funcall (funcall (nvaneris_pax_v1_eq_bnums)
(lambda () nvbnum))
(lambda () nvw)))
(funcall (lambda (nvx)
(make-pair :fst nvw :snd (make-pair :fst (nvbtrue) :snd (make-pair :fst (funcall nvx) :snd nvz_))))
(lambda () (funcall (funcall (funcall (nvaneris_pax_v1_update_proposals nvCmd)
(lambda () nvy))
(lambda () nvz_))
(lambda () nvpvals))))
(make-pair :fst nvw :snd (make-pair :fst nvx :snd (make-pair :fst nvy :snd nvz_))))))))))))))))

(defun nvisl (nvx)
(let ((dec nvx))
(if (inl-p dec)
(nvbtrue)
(if (inr-p dec)
(nvbfalse)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))

(defun nvaneris_pax_v1_is_bnum ()
(lambda (nvbnum)
(nvisl (funcall nvbnum))))

(defun nvaneris_pax_v1_lt_bnum_ (nvldrs_uid)
(lambda (nvzb)
(let ((pair (funcall nvzb)))
(let ((nvi1 (pair-fst pair))
(nvl1 (pair-snd pair)))
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvi2 (pair-fst pair))
(nvl2 (pair-snd pair)))
(nvbor (nvlt_int nvi1 nvi2) (nvband (nveq_int nvi1 nvi2) (nvlt_int (funcall nvldrs_uid
(lambda () nvl1)) (funcall nvldrs_uid
(lambda () nvl2))))))))))))

(defun nvaneris_pax_v1_lt_bnum (nvldrs_uid)
(lambda (nvbn1)
(lambda (nvbn2)
(let ((dec (funcall nvbn1)))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(let ((dec (funcall nvbn2)))
(if (inl-p dec)
(let ((nvx2 (inl-val dec)))
(funcall (funcall (nvaneris_pax_v1_lt_bnum_ nvldrs_uid)
(lambda () nvx1))
(lambda () nvx2)))
(if (inr-p dec)
(nvbfalse)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(if (inr-p dec)
(nvisl (funcall nvbn2))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))

(defun nvaneris_pax_v1_upd_bnum ()
(lambda (nvbnum)
(lambda (nvloc)
(let ((dec (funcall nvbnum)))
(if (inl-p dec)
(let ((nvz (inl-val dec)))
(let ((pair nvz))
(let ((nvr (pair-fst pair))
(nvl (pair-snd pair)))
(declare (ignore nvl))
(funcall (funcall (nvaneris_pax_v1_mk_bnum)
(lambda () (+ nvr 1)))
(lambda () (funcall nvloc))))))
(if (inr-p dec)
(funcall nvbnum)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))

(defun nvaneris_pax_v1_when_preempted (nvCmd nvldrs_uid)
(declare (ignore nvCmd))
(lambda (nvldr)
(lambda (nvbnum)
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz_ (pair-snd pair)))
(if (inl-p (nvband (funcall (nvaneris_pax_v1_is_bnum)
(lambda () (funcall nvbnum))) (funcall (funcall (nvaneris_pax_v1_lt_bnum nvldrs_uid)
(lambda () nvw))
(lambda () (funcall nvbnum)))))
(make-pair :fst (funcall (funcall (nvaneris_pax_v1_upd_bnum)
(lambda () (funcall nvbnum)))
(lambda () (funcall nvldr))) :snd (make-pair :fst (nvbfalse) :snd (make-pair :fst nvy :snd nvz_)))
(make-pair :fst nvw :snd (make-pair :fst nvx :snd (make-pair :fst nvy :snd nvz_))))))))))))))

(defun nvfrom-upto (nvn nvm)
(funcall (fix (lambda (nvfrom-upto)
(lambda (nvn)
(if (inl-p (nvlt_int (funcall nvn) nvm))
(make-pair :fst (funcall nvn) :snd (let ((nvn_ (+ (funcall nvn) 1)))
(funcall (funcall nvfrom-upto)
(lambda () nvn_))))
(make-axiom)))))
(lambda () nvn)))

(defun nvremove-combine (nvcmp nvl)
(funcall (fix (lambda (nvlist_ind)
(lambda (nvL)
(if (pair-p (funcall nvL))
(let ((pair (funcall nvL)))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(let ((nvtst (funcall nvcmp
(lambda () nvh))))
(if (inl-p (nveq_int nvtst 0))
nvt
(if (inl-p (nvlt_int 0 nvtst))
(make-pair :fst nvh :snd nvt)
(make-pair :fst nvh :snd (funcall (funcall nvlist_ind)
(lambda () nvt))))))))
(if (axiom-p (funcall nvL))
(make-axiom)
(error "bottom"))))))
(lambda () nvl)))

(defun nvaneris_pax_v1_remove_from_missing ()
(lambda (nvslt)
(lambda (nvmissing)
(nvremove-combine (lambda (nvn)
(- (funcall nvn) (funcall nvslt))) (funcall nvmissing)))))

(defun nvaneris_pax_v1_add_slot_to_decided ()
(lambda (nvslt)
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvmax (pair-fst pair))
(nvmissing (pair-snd pair)))
(if (inl-p (nvlt_int nvmax (funcall nvslt)))
(make-pair :fst (funcall nvslt) :snd (nvappend nvmissing (nvfrom-upto (+ nvmax 1) (funcall nvslt))))
(if (inl-p (nveq_int (funcall nvslt) nvmax))
(make-pair :fst nvmax :snd nvmissing)
(make-pair :fst nvmax :snd (funcall (funcall (nvaneris_pax_v1_remove_from_missing)
(lambda () (funcall nvslt)))
(lambda () nvmissing))))))))))

(defun nvaneris_pax_v1_filter_out_proposals (nvCmd)
(lambda (nvslt)
(lambda (nvproposals)
(nvremove-combine (lambda (nvprp)
(- (funcall nvslt) (funcall (nvaneris_pax_v1_prp2slt nvCmd)
(lambda () (funcall nvprp))))) (funcall nvproposals)))))

(defun nvaneris_pax_v1_when_decided (nvCmd)
(lambda (nvldr)
(declare (ignore nvldr))
(lambda (nvslt)
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz_ (pair-snd pair)))
(funcall (lambda (nvx_)
(funcall (lambda (nvx__)
(make-pair :fst nvw :snd (make-pair :fst nvx :snd (make-pair :fst (funcall nvx_) :snd (funcall nvx__)))))
(lambda () (funcall (funcall (nvaneris_pax_v1_add_slot_to_decided)
(lambda () (funcall nvslt)))
(lambda () nvz_)))))
(lambda () (funcall (funcall (nvaneris_pax_v1_filter_out_proposals nvCmd)
(lambda () (funcall nvslt)))
(lambda () nvy))))))))))))))

(defun nvaneris_pax_v1_p2a_broadcast (nvCmd nvdecision nvpropose nvzs)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvzs))
(lambda (nvlocs)
(lambda (nvz)
(nvbag-map (lambda (nvl)
(nvmk-msg-interface (funcall nvl) (nvmake-Msg (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p2a" :snd (make-axiom))) (funcall nvz)))) (funcall nvlocs)))))

(defun nvaneris_pax_v1_decision_broadcast (nvCmd nvdecision nvpropose nvzs)
(declare (ignore nvCmd))
(declare (ignore nvpropose))
(declare (ignore nvzs))
(lambda (nvlocs)
(lambda (nvz)
(nvbag-map (lambda (nvl)
(nvmk-msg-interface (funcall nvl) (nvmake-Msg nvdecision (funcall nvz)))) (funcall nvlocs)))))

(defun nvaneris_pax_v1_decided_broadcast (nvCmd nvdecision nvpropose nvzs)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvzs))
(lambda (nvlocs)
(lambda (nvz)
(nvbag-map (lambda (nvl)
(nvmk-msg-interface (funcall nvl) (nvmake-Msg (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "decided" :snd (make-axiom))) (funcall nvz)))) (funcall nvlocs)))))

(defun nvaneris_pax_v1_commander_output (nvCmd nvaccpts nvdecision nvldrs nvpropose nvreps nvzs)
(lambda (nvpvalue)
(lambda (nvldr)
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(declare (ignore nvw))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz_ (pair-snd pair)))
(lambda (nvwaitfor)
(let ((pair (funcall (nvaneris_pax_v1_dest_pv nvCmd)
(lambda () (funcall nvpvalue)))))
(let ((nvx_ (pair-fst pair))
(nvzz (pair-snd pair)))
(let ((pair nvzz))
(let ((nvy_ (pair-fst pair))
(nvz (pair-snd pair)))
(if (inl-p (nvband (funcall (funcall (nvaneris_pax_v1_eq_bnums)
(lambda () nvx_))
(lambda () nvx)) (nveq_int nvy_ nvy)))
(if (inl-p (funcall (funcall (nvaneris_pax_v1_eq_bnums)
(lambda () nvx_))
(lambda () nvz_)))
(if (inl-p (nvlt_int (nvbag-size (funcall nvwaitfor)) (nvaneris_pax_v1_threshold nvaccpts)))
(nvbag-append (funcall (funcall (nvaneris_pax_v1_decision_broadcast nvCmd nvdecision nvpropose nvzs)
(lambda () nvreps))
(lambda () (funcall (funcall (nvaneris_pax_v1_mk_prp nvCmd)
(lambda () nvy_))
(lambda () nvz)))) (funcall (funcall (nvaneris_pax_v1_decided_broadcast nvCmd nvdecision nvpropose nvzs)
(lambda () nvldrs))
(lambda () nvy_)))
(make-axiom))
(nvsingle-bag (funcall (funcall (nvaneris_pax_v1_preempted_send nvCmd nvdecision nvpropose nvzs)
(lambda () (funcall nvldr)))
(lambda () nvz_))))
(make-axiom)))))))))))))))))

(defun nvaneris_pax_v1_on_p2b ()
(lambda (nvbnum)
(lambda (nvslt)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz_ (pair-snd pair)))
(lambda (nvwaitfor)
(if (inl-p (nvband (funcall (funcall (nvaneris_pax_v1_eq_bnums)
(lambda () (funcall nvbnum)))
(lambda () nvx)) (nvband (nveq_int (funcall nvslt) nvy) (funcall (funcall (nvaneris_pax_v1_eq_bnums)
(lambda () (funcall nvbnum)))
(lambda () nvz_)))))
(nvbag-remove (lambda (nva)
(lambda (nvb)
(if (string= (funcall nva) (funcall nvb))
(make-inl :val (make-axiom))
(make-inr :val (make-axiom))))) (funcall nvwaitfor) nvw)
(funcall nvwaitfor))))))))))))))

(defun nvaneris_pax_v1_leader_preempted (nvCmd nvldrs_uid)
(declare (ignore nvCmd))
(lambda (nvldr)
(lambda (nvbnum)
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(declare (ignore nvx))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz_ (pair-snd pair)))
(declare (ignore nvy))
(declare (ignore nvz_))
(if (inl-p (nvband (funcall (nvaneris_pax_v1_is_bnum)
(lambda () (funcall nvbnum))) (funcall (funcall (nvaneris_pax_v1_lt_bnum nvldrs_uid)
(lambda () nvw))
(lambda () (funcall nvbnum)))))
(nvsingle-bag (funcall (funcall (nvaneris_pax_v1_upd_bnum)
(lambda () (funcall nvbnum)))
(lambda () (funcall nvldr))))
(make-axiom))))))))))))

(defun nvaneris_pax_v1_max_bnum (nvldrs_uid)
(lambda (nvbn1)
(lambda (nvbn2)
(if (inl-p (funcall (funcall (nvaneris_pax_v1_leq_bnum nvldrs_uid)
(lambda () (funcall nvbn1)))
(lambda () (funcall nvbn2))))
(funcall nvbn2)
(funcall nvbn1)))))

(defun nvaneris_pax_v1_on_p1a (nvCmd nvldrs_uid)
(declare (ignore nvCmd))
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvze)
(let ((pair (funcall nvze)))
(let ((nvloc (pair-fst pair))
(nvbnum (pair-snd pair)))
(declare (ignore nvloc))
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvballot_num (pair-fst pair))
(nvaccepted (pair-snd pair)))
(make-pair :fst (funcall (funcall (nvaneris_pax_v1_max_bnum nvldrs_uid)
(lambda () nvbnum))
(lambda () nvballot_num)) :snd nvaccepted)))))))))

(defun nvaneris_pax_v1_on_p2a (nvCmd nvldrs_uid)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvzf)
(let ((pair (funcall nvzf)))
(let ((nvloc (pair-fst pair))
(nvpvalue (pair-snd pair)))
(declare (ignore nvloc))
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvballot_num (pair-fst pair))
(nvaccepted (pair-snd pair)))
(funcall (lambda (nvx)
(funcall (lambda (nvx_)
(funcall (lambda (nvx__)
(make-pair :fst (funcall nvx_) :snd (funcall nvx__)))
(lambda () (if (inl-p (funcall (funcall (nvaneris_pax_v1_leq_bnum nvldrs_uid)
(lambda () nvballot_num))
(lambda () (funcall nvx))))
(funcall (funcall (nvaneris_pax_v1_add_pvalue nvCmd nvldrs_uid)
(lambda () nvaccepted))
(lambda () nvpvalue))
nvaccepted))))
(lambda () (funcall (funcall (nvaneris_pax_v1_max_bnum nvldrs_uid)
(lambda () (funcall nvx)))
(lambda () nvballot_num)))))
(lambda () (funcall (nvaneris_pax_v1_pv2bn nvCmd)
(lambda () nvpvalue))))))))))))

(defun nvaneris_23_v1_when_new_proposal (nvCmd)
(declare (ignore nvCmd))
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvzk)
(let ((pair (funcall nvzk)))
(let ((nvn (pair-fst pair))
(nvc (pair-snd pair)))
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvmax (pair-fst pair))
(nvmissing (pair-snd pair)))
(if (inl-p (nvbor (nvlt_int nvmax nvn) (nvdeq-member (nvint-deq) nvn nvmissing)))
(nvsingle-bag (make-pair :fst nvn :snd nvc))
(make-axiom))))))))))

(defun nvaneris_23_v1_vote2prop (nvCmd)
(declare (ignore nvCmd))
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvz (pair-fst pair))
(nvloc_ (pair-snd pair)))
(declare (ignore nvloc_))
(let ((pair nvz))
(let ((nvz (pair-fst pair))
(nvc (pair-snd pair)))
(let ((pair nvz))
(let ((nvn (pair-fst pair))
(nvi (pair-snd pair)))
(declare (ignore nvi))
(nvsingle-bag (make-pair :fst nvn :snd nvc)))))))))))

(defun nvhdf-compose1 (nvf nvX)
(funcall (fix (lambda (nvmk-hdf)
(lambda (nvs0)
(if (inl-p (nvhdf-halted (funcall nvs0)))
(nvhdf-halt)
(nvhdf-run (lambda (nvm)
(let ((pair (let ((pair (nvhdf-ap (funcall nvs0) (funcall nvm))))
(let ((nvX_ (pair-fst pair))
(nvbs (pair-snd pair)))
(let ((nvout (nvbag-map nvf nvbs)))
(make-pair :fst nvX_ :snd nvout))))))
(let ((nvs1 (pair-fst pair))
(nvb (pair-snd pair)))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvs1)) :snd nvb)))))))))
(lambda () nvX)))

(defun nvlist-diff (nveq nvas nvbs)
(nvfilter (lambda (nva)
(nvbnot (nvdeq-member nveq (funcall nva) nvbs))) nvas))

(defun nvaneris_23_v1_onnewpropose (nvCmd)
(declare (ignore nvCmd))
(lambda (nvzi)
(let ((pair (funcall nvzi)))
(let ((nvn (pair-fst pair))
(nvc (pair-snd pair)))
(declare (ignore nvc))
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvmax (pair-fst pair))
(nvmissing (pair-snd pair)))
(if (inl-p (nvlt_int nvmax nvn))
(make-pair :fst nvn :snd (nvappend nvmissing (nvfrom-upto (+ nvmax 1) nvn)))
(make-pair :fst nvmax :snd (nvlist-diff (nvint-deq) nvmissing (make-pair :fst nvn :snd (make-axiom))))))))))))

(defun nvaneris_23_v1_update_replica (nvCmd)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvzj)
(let ((pair (funcall nvzj)))
(let ((nvn (pair-fst pair))
(nvc (pair-snd pair)))
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvmax (pair-fst pair))
(nvmissing (pair-snd pair)))
(if (inl-p (nvbor (nvlt_int nvmax nvn) (nvdeq-member (nvint-deq) nvn nvmissing)))
(funcall (funcall (nvaneris_23_v1_onnewpropose nvCmd)
(lambda () (make-pair :fst nvn :snd nvc)))
(lambda () (make-pair :fst nvmax :snd nvmissing)))
(make-pair :fst nvmax :snd nvmissing))))))))))

(defun nvhdf-memory (nvX nvbs)
(funcall (fix (lambda (nvmk-hdf)
(lambda (nvs0)
(if (inl-p (nvbfalse))
(nvhdf-halt)
(nvhdf-run (lambda (nvm)
(let ((pair (let ((pair (funcall nvs0)))
(let ((nvX (pair-fst pair))
(nvs (pair-snd pair)))
(let ((pair (nvhdf-ap nvX (funcall nvm))))
(let ((nvX_ (pair-fst pair))
(nvfs (pair-snd pair)))
(let ((nvb (nvbag-union (nvbag-map (lambda (nvx)
(nvbag-map (funcall nvx) nvs)) nvfs))))
(let ((nvs_ (if (inl-p (nvbag-null nvb))
nvs
nvb)))
(make-pair :fst (make-pair :fst nvX_ :snd nvs_) :snd nvs)))))))))
(let ((nvs1 (pair-fst pair))
(nvb (pair-snd pair)))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvs1)) :snd nvb)))))))))
(lambda () (make-pair :fst nvX :snd nvbs))))

(defun nvhdf-compose2 (nvX nvY)
(funcall (fix (lambda (nvmk-hdf)
(lambda (nvs0)
(if (inl-p (let ((pair (funcall nvs0)))
(let ((nvX (pair-fst pair))
(nvY (pair-snd pair)))
(nvbor (nvhdf-halted nvX) (nvhdf-halted nvY)))))
(nvhdf-halt)
(nvhdf-run (lambda (nvm)
(let ((pair (let ((pair (funcall nvs0)))
(let ((nvX (pair-fst pair))
(nvY (pair-snd pair)))
(let ((pair (nvhdf-ap nvX (funcall nvm))))
(let ((nvX_ (pair-fst pair))
(nvfs (pair-snd pair)))
(let ((pair (nvhdf-ap nvY (funcall nvm))))
(let ((nvY_ (pair-fst pair))
(nvbs (pair-snd pair)))
(let ((nvout (nvbag-union (nvbag-map (lambda (nvx)
(nvbag-union (nvbag-map (lambda (nvx_)
(funcall (funcall nvx)
(lambda () (funcall nvx_)))) nvbs))) nvfs))))
(make-pair :fst (make-pair :fst nvX_ :snd nvY_) :snd nvout))))))))))
(let ((nvs1 (pair-fst pair))
(nvb (pair-snd pair)))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvs1)) :snd nvb)))))))))
(lambda () (make-pair :fst nvX :snd nvY))))

(defun nvaneris_23_v1_newvote (nvCmd)
(declare (ignore nvCmd))
(lambda (nvni)
(lambda (nvzd)
(let ((pair (funcall nvzd)))
(let ((nvze (pair-fst pair))
(nvsender (pair-snd pair)))
(let ((pair nvze))
(let ((nvni_ (pair-fst pair))
(nvc (pair-snd pair)))
(declare (ignore nvc))
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvcmds (pair-fst pair))
(nvz (pair-snd pair)))
(declare (ignore nvcmds))
(nvband (funcall (funcall (nvproduct-deq "INT" "INT" (nvint-deq) (nvint-deq))
(lambda () (funcall nvni)))
(lambda () nvni_)) (nvbnot (nvdeq-member (lambda (nva)
(lambda (nvb)
(if (string= (funcall nva) (funcall nvb))
(make-inl :val (make-axiom))
(make-inr :val (make-axiom))))) nvsender nvz)))))))))))))

(defun nvaneris_23_v1_addvote (nvCmd)
(declare (ignore nvCmd))
(lambda (nvzf)
(let ((pair (funcall nvzf)))
(let ((nvzg (pair-fst pair))
(nvsender (pair-snd pair)))
(let ((pair nvzg))
(let ((nvni (pair-fst pair))
(nvc (pair-snd pair)))
(declare (ignore nvni))
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvcmds (pair-fst pair))
(nvz (pair-snd pair)))
(make-pair :fst (make-pair :fst nvc :snd nvcmds) :snd (make-pair :fst nvsender :snd nvz)))))))))))

(defun nvaneris_23_v1_add_to_quorum (nvCmd)
(lambda (nvni)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvvt)
(lambda (nvstate)
(if (inl-p (funcall (funcall (funcall (nvaneris_23_v1_newvote nvCmd)
(lambda () (funcall nvni)))
(lambda () (funcall nvvt)))
(lambda () (funcall nvstate))))
(funcall (funcall (nvaneris_23_v1_addvote nvCmd)
(lambda () (funcall nvvt)))
(lambda () (funcall nvstate)))
(funcall nvstate)))))))

(defun nvlist (nvT)
(declare (ignore nvT))
"REC")

(defun nvaneris_cmd_deq (nvCid nvOp nveq_Cid nveq_Op)
(nvunion-deq "PRODUCT" "PRODUCT" (nvproduct-deq nvCid (nvlist "ATOM") nveq_Cid (nvlist-deq (nvatom-deq))) (nvproduct-deq nvCid nvOp nveq_Cid nveq_Op)))

(defun nvposs-maj (nveq nvL nvx)
(funcall (funcall (fix (lambda (nvlist_accum)
(lambda (nvy)
(lambda (nvL)
(if (pair-p (funcall nvL))
(let ((pair (funcall nvL)))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(funcall (funcall (funcall nvlist_accum)
(lambda () (let ((pair (funcall nvy)))
(let ((nvn (pair-fst pair))
(nvx (pair-snd pair)))
(if (inl-p (funcall (funcall nveq
(lambda () nvh))
(lambda () nvx)))
(make-pair :fst (+ nvn 1) :snd nvx)
(if (inl-p (nveq_int nvn 0))
(make-pair :fst 1 :snd nvh)
(make-pair :fst (- nvn 1) :snd nvx)))))))
(lambda () nvt))))
(if (axiom-p (funcall nvL))
(funcall nvy)
(error "bottom")))))))
(lambda () (make-pair :fst 0 :snd nvx)))
(lambda () nvL)))

(defun nvaneris_23_v1_decided_send (nvCmd nvnotify nvpropose nvf)
(declare (ignore nvCmd))
(declare (ignore nvnotify))
(declare (ignore nvpropose))
(declare (ignore nvf))
(lambda (nvl)
(lambda (nvz)
(nvmk-msg-interface (funcall nvl) (nvmake-Msg (make-pair :fst "aneris_23_v1" :snd (make-pair :fst "decided" :snd (make-axiom))) (funcall nvz))))))

(defun nvaneris_23_v1_retry_send (nvCmd nvnotify nvpropose nvf)
(declare (ignore nvCmd))
(declare (ignore nvnotify))
(declare (ignore nvpropose))
(declare (ignore nvf))
(lambda (nvl)
(lambda (nvz)
(nvmk-msg-interface (funcall nvl) (nvmake-Msg (make-pair :fst "aneris_23_v1" :snd (make-pair :fst "retry" :snd (make-axiom))) (funcall nvz))))))

(defun nvaneris_23_v1_roundout (nvCmd nvcmdeq nvcoeff nvflrs nvnotify nvpropose nvf)
(lambda (nvloc)
(lambda (nvza)
(let ((pair (funcall nvza)))
(let ((nvzb (pair-fst pair))
(nvsender (pair-snd pair)))
(declare (ignore nvsender))
(let ((pair nvzb))
(let ((nvzc (pair-fst pair))
(nvc (pair-snd pair)))
(let ((pair nvzc))
(let ((nvn (pair-fst pair))
(nvi (pair-snd pair)))
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvcmds (pair-fst pair))
(nvz (pair-snd pair)))
(declare (ignore nvz))
(if (inl-p (nveq_int (nvlength nvcmds) (* nvcoeff nvflrs)))
(let ((pair (nvposs-maj nvcmdeq (make-pair :fst nvc :snd nvcmds) nvc)))
(let ((nvk (pair-fst pair))
(nvx (pair-snd pair)))
(if (inl-p (nveq_int nvk (+ (* nvcoeff nvflrs) 1)))
(nvsingle-bag (funcall (funcall (nvaneris_23_v1_decided_send nvCmd nvnotify nvpropose nvf)
(lambda () (funcall nvloc)))
(lambda () (make-pair :fst nvn :snd nvx))))
(nvsingle-bag (funcall (funcall (nvaneris_23_v1_retry_send nvCmd nvnotify nvpropose nvf)
(lambda () (funcall nvloc)))
(lambda () (make-pair :fst (make-pair :fst nvn :snd (+ nvi 1)) :snd nvx)))))))
(make-axiom))))))))))))))

(defun nvaneris_23_v1_when_quorum (nvCmd nvcmdeq nvcoeff nvflrs nvnotify nvpropose nvf)
(lambda (nvni)
(lambda (nvloc)
(lambda (nvvt)
(lambda (nvstate)
(if (inl-p (funcall (funcall (funcall (nvaneris_23_v1_newvote nvCmd)
(lambda () (funcall nvni)))
(lambda () (funcall nvvt)))
(lambda () (funcall nvstate))))
(funcall (funcall (funcall (nvaneris_23_v1_roundout nvCmd nvcmdeq nvcoeff nvflrs nvnotify nvpropose nvf)
(lambda () (funcall nvloc)))
(lambda () (funcall nvvt)))
(lambda () (funcall nvstate)))
(make-axiom)))))))

(defun nvaneris_23_v1_vote_broadcast (nvCmd nvnotify nvpropose nvf)
(declare (ignore nvCmd))
(declare (ignore nvnotify))
(declare (ignore nvpropose))
(declare (ignore nvf))
(lambda (nvlocs)
(lambda (nvz)
(nvbag-map (lambda (nvl)
(nvmk-msg-interface (funcall nvl) (nvmake-Msg (make-pair :fst "aneris_23_v1" :snd (make-pair :fst "vote" :snd (make-axiom))) (funcall nvz)))) (funcall nvlocs)))))

(defun nvaneris_23_v1_notify_broadcast (nvCmd nvnotify nvpropose nvf)
(declare (ignore nvCmd))
(declare (ignore nvpropose))
(declare (ignore nvf))
(lambda (nvlocs)
(lambda (nvz)
(nvbag-map (lambda (nvl)
(nvmk-msg-interface (funcall nvl) (nvmake-Msg nvnotify (funcall nvz)))) (funcall nvlocs)))))

(defun nvaneris_23_v1_decision (nvCmd nvclients nvnotify nvpropose nvf)
(lambda (nvn)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvm (pair-fst pair))
(nvc (pair-snd pair)))
(if (inl-p (nveq_int nvm (funcall nvn)))
(funcall (funcall (nvaneris_23_v1_notify_broadcast nvCmd nvnotify nvpropose nvf)
(lambda () nvclients))
(lambda () (make-pair :fst nvm :snd nvc)))
(make-axiom))))))))

(defun nvaneris_23_v1_when_new_round (nvCmd)
(declare (ignore nvCmd))
(lambda (nvn)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvz (pair-fst pair))
(nvc (pair-snd pair)))
(let ((pair nvz))
(let ((nvm (pair-fst pair))
(nvi (pair-snd pair)))
(lambda (nvround)
(if (inl-p (nvband (nveq_int (funcall nvn) nvm) (nvlt_int (funcall nvround) nvi)))
(nvsingle-bag (make-pair :fst (make-pair :fst nvm :snd nvi) :snd nvc))
(make-axiom)))))))))))

(defun nvaneris_23_v1_vote2retry (nvCmd)
(declare (ignore nvCmd))
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvz (pair-fst pair))
(nvsender (pair-snd pair)))
(declare (ignore nvsender))
(let ((pair nvz))
(let ((nvni (pair-fst pair))
(nvc (pair-snd pair)))
(nvsingle-bag (make-pair :fst nvni :snd nvc)))))))))

(defun nvaneris_23_v1_update_round (nvCmd)
(declare (ignore nvCmd))
(lambda (nvn)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvz (pair-fst pair))
(nvc (pair-snd pair)))
(declare (ignore nvc))
(let ((pair nvz))
(let ((nvm (pair-fst pair))
(nvi (pair-snd pair)))
(lambda (nvround)
(if (inl-p (nvband (nveq_int (funcall nvn) nvm) (nvlt_int (funcall nvround) nvi)))
nvi
(funcall nvround)))))))))))

(defun nvaneris_v2_out_tr (nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtt_propose nvf)
(declare (ignore nvOp))
(declare (ignore nvbcast))
(declare (ignore nvdecision))
(declare (ignore nvpax_propose))
(declare (ignore nvresponse))
(declare (ignore nvswap))
(declare (ignore nvtt_propose))
(declare (ignore nvf))
(lambda (nvtr)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvx)
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nva (pair-fst pair))
(nvz (pair-snd pair)))
(declare (ignore nvz))
(funcall (funcall (funcall nvtr)
(lambda () (funcall nvx)))
(lambda () nva)))))))))

(defun nvaneris_v2_command_tag2num (nvOp)
(declare (ignore nvOp))
(lambda (nvcmdt)
(let ((dec (funcall nvcmdt)))
(if (inl-p dec)
(let ((nvz (inl-val dec)))
(let ((pair nvz))
(let ((nvcid (pair-fst pair))
(nvx (pair-snd pair)))
(declare (ignore nvx))
(+ (* 2 nvcid) 1))))
(if (inr-p dec)
(let ((nvz (inr-val dec)))
(let ((pair nvz))
(let ((nvcid (pair-fst pair))
(nvx (pair-snd pair)))
(declare (ignore nvx))
(* 2 nvcid))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))

(defun nvaneris_v2_proposal2num (nvOp)
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvslt (pair-fst pair))
(nvcmdt (pair-snd pair)))
(declare (ignore nvslt))
(funcall (nvaneris_v2_command_tag2num nvOp)
(lambda () nvcmdt))))))

(defun nvaneris_v2_is_decision (nvOp)
(lambda (nvcmdt)
(lambda (nvdecisions)
(funcall (lambda (nvx)
(nvreduce (lambda (nvprp)
(lambda (nvr)
(funcall (lambda (nvx_)
(if (inl-p (nvlt_int (funcall nvx_) (funcall nvx)))
(nvbfalse)
(nvbor (nveq_int (funcall nvx) (funcall nvx_)) (funcall nvr))))
(lambda () (funcall (nvaneris_v2_proposal2num nvOp)
(lambda () (funcall nvprp))))))) (nvbfalse) (funcall nvdecisions)))
(lambda () (funcall (nvaneris_v2_command_tag2num nvOp)
(lambda () (funcall nvcmdt))))))))

(defun nvaneris_v2_is_todo (nvOp)
(lambda (nvcmdt)
(lambda (nvtodo)
(funcall (lambda (nvx)
(nvreduce (lambda (nvx_)
(lambda (nvp)
(nvbor (nveq_int (funcall nvx) (funcall (nvaneris_v2_proposal2num nvOp)
(lambda () (funcall nvx_)))) (funcall nvp)))) (nvbfalse) (funcall nvtodo)))
(lambda () (funcall (nvaneris_v2_command_tag2num nvOp)
(lambda () (funcall nvcmdt))))))))

(defun nvaneris_v2_pax_propose_broadcast (nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtt_propose nvf)
(declare (ignore nvOp))
(declare (ignore nvbcast))
(declare (ignore nvdecision))
(declare (ignore nvresponse))
(declare (ignore nvswap))
(declare (ignore nvtt_propose))
(declare (ignore nvf))
(lambda (nvlocs)
(lambda (nvz)
(nvbag-map (lambda (nvl)
(nvmk-msg-interface (funcall nvl) (nvmake-Msg nvpax_propose (funcall nvz)))) (funcall nvlocs)))))

(defun nvaneris_v2_tt_propose_broadcast (nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtt_propose nvf)
(declare (ignore nvOp))
(declare (ignore nvbcast))
(declare (ignore nvdecision))
(declare (ignore nvpax_propose))
(declare (ignore nvresponse))
(declare (ignore nvswap))
(declare (ignore nvf))
(lambda (nvlocs)
(lambda (nvz)
(nvbag-map (lambda (nvl)
(nvmk-msg-interface (funcall nvl) (nvmake-Msg nvtt_propose (funcall nvz)))) (funcall nvlocs)))))

(defun nvaneris_v2_add_proposal_if_not_in (nvOp)
(lambda (nvcmdt)
(lambda (nvproposals)
(nvinsert-combine (nvint-minus-comparison (nvaneris_v2_command_tag2num nvOp)) (lambda (nvprp1)
(declare (ignore nvprp1))
(lambda (nvprp2)
(funcall nvprp2))) (funcall nvcmdt) (funcall nvproposals)))))

(defun nvaneris_v2_propose (nvOp nvbcast nvdecision nvpax_procs nvpax_propose nvresponse nvswap nvtt_procs nvtt_propose nvf)
(lambda (nvcmdt)
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nva (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvb (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvc (pair-fst pair))
(nvzz3 (pair-snd pair)))
(let ((pair nvzz3))
(let ((nvd (pair-fst pair))
(nvzz4 (pair-snd pair)))
(let ((pair nvzz4))
(let ((nve (pair-fst pair))
(nvf_ (pair-snd pair)))
(if (inl-p (nvbor (funcall (funcall (nvaneris_v2_is_decision nvOp)
(lambda () (funcall nvcmdt)))
(lambda () nvd)) (funcall (funcall (nvaneris_v2_is_todo nvOp)
(lambda () (funcall nvcmdt)))
(lambda () nve))))
(make-pair :fst (make-pair :fst nva :snd (make-pair :fst (nvbtrue) :snd (make-pair :fst nvc :snd (make-pair :fst nvd :snd (make-pair :fst nve :snd nvf_))))) :snd (make-axiom))
(funcall (lambda (nvx)
(funcall (lambda (nvx_)
(make-pair :fst (make-pair :fst nva :snd (make-pair :fst (nvbtrue) :snd (make-pair :fst (funcall nvx) :snd (make-pair :fst nvd :snd (make-pair :fst nve :snd nvf_))))) :snd (funcall nvx_)))
(lambda () (if (inl-p nvb)
(make-axiom)
(if (inl-p (funcall (funcall (nvlist-deq (nvatom-deq))
(lambda () nvf_))
(lambda () (make-pair :fst "paxos" :snd (make-axiom)))))
(funcall (funcall (nvaneris_v2_pax_propose_broadcast nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtt_propose nvf)
(lambda () nvpax_procs))
(lambda () (make-pair :fst nva :snd (funcall nvcmdt))))
(if (inl-p (funcall (funcall (nvlist-deq (nvatom-deq))
(lambda () nvf_))
(lambda () (make-pair :fst "2/3" :snd (make-axiom)))))
(funcall (funcall (nvaneris_v2_tt_propose_broadcast nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtt_propose nvf)
(lambda () nvtt_procs))
(lambda () (make-pair :fst nva :snd (funcall nvcmdt))))
(make-axiom)))))))
(lambda () (funcall (funcall (nvaneris_v2_add_proposal_if_not_in nvOp)
(lambda () (funcall nvcmdt)))
(lambda () nvc))))))))))))))))))

(defun nvaneris_v2_propose_inl (nvOp nvbcast nvdecision nvpax_procs nvpax_propose nvresponse nvswap nvtt_procs nvtt_propose nvf)
(lambda (nvnp)
(lambda (nvstate)
(funcall (funcall (nvaneris_v2_propose nvOp nvbcast nvdecision nvpax_procs nvpax_propose nvresponse nvswap nvtt_procs nvtt_propose nvf)
(lambda () (make-inl :val (funcall nvnp))))
(lambda () (funcall nvstate))))))

(defun nvaneris_v2_propose_inr (nvOp nvbcast nvdecision nvpax_procs nvpax_propose nvresponse nvswap nvtt_procs nvtt_propose nvf)
(lambda (nvcmd)
(lambda (nvstate)
(funcall (funcall (nvaneris_v2_propose nvOp nvbcast nvdecision nvpax_procs nvpax_propose nvresponse nvswap nvtt_procs nvtt_propose nvf)
(lambda () (make-inr :val (funcall nvcmd))))
(lambda () (funcall nvstate))))))

(defun nvaneris_v2_iterate_tr (nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtt_propose nvf)
(declare (ignore nvOp))
(declare (ignore nvbcast))
(declare (ignore nvdecision))
(declare (ignore nvpax_propose))
(declare (ignore nvresponse))
(declare (ignore nvswap))
(declare (ignore nvtt_propose))
(declare (ignore nvf))
(lambda (nvtr)
(lambda (nvinit)
(lambda (nvops)
(funcall (funcall (fix (lambda (nvlist_accum)
(lambda (nvy)
(lambda (nvL)
(if (pair-p (funcall nvL))
(let ((pair (funcall nvL)))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(funcall (funcall (funcall nvlist_accum)
(lambda () (funcall (let ((pair (funcall nvy)))
(let ((nva (pair-fst pair))
(nvb (pair-snd pair)))
(lambda (nvx)
(let ((pair (funcall (funcall (funcall nvtr)
(lambda () (funcall nvx)))
(lambda () nva))))
(let ((nvs_ (pair-fst pair))
(nvb_ (pair-snd pair)))
(make-pair :fst nvs_ :snd (nvbag-append nvb nvb_)))))))
(lambda () nvh))))
(lambda () nvt))))
(if (axiom-p (funcall nvL))
(funcall nvy)
(error "bottom")))))))
(lambda () (make-pair :fst (funcall nvinit) :snd (make-axiom))))
(lambda () (funcall nvops)))))))

(defun nvaneris_v2_response_broadcast (nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtt_propose nvf)
(declare (ignore nvOp))
(declare (ignore nvbcast))
(declare (ignore nvdecision))
(declare (ignore nvpax_propose))
(declare (ignore nvswap))
(declare (ignore nvtt_propose))
(declare (ignore nvf))
(lambda (nvlocs)
(lambda (nvz)
(nvbag-map (lambda (nvl)
(nvmk-msg-interface (funcall nvl) (nvmake-Msg nvresponse (funcall nvz)))) (funcall nvlocs)))))

(defun nvaneris_v2_perform (nvOp nvbcast nvclients nvdecision nvpax_propose nvresponse nvswap nvtt_propose nvf)
(lambda (nvcmdt)
(lambda (nvslot_num)
(lambda (nvprotocol)
(funcall (lambda (nvx)
(make-pair :fst (funcall nvx) :snd (funcall (funcall (nvaneris_v2_response_broadcast nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtt_propose nvf)
(lambda () nvclients))
(lambda () (make-pair :fst (funcall nvslot_num) :snd (funcall nvcmdt))))))
(lambda () (let ((dec (funcall nvcmdt)))
(if (inl-p dec)
(let ((nvz (inl-val dec)))
(let ((pair nvz))
(let ((nvcid (pair-fst pair))
(nvnew_protocol (pair-snd pair)))
(declare (ignore nvcid))
nvnew_protocol)))
(if (inr-p dec)
(let ((nvz (inr-val dec)))
(let ((pair nvz))
(let ((nvcid (pair-fst pair))
(nvopr (pair-snd pair)))
(declare (ignore nvcid))
(declare (ignore nvopr))
(funcall nvprotocol))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))))))

(defun nvaneris_v2_add_decision (nvOp)
(lambda (nvslt)
(lambda (nvcmdt)
(lambda (nvdecisions)
(nvinsert-combine (nvint-minus-comparison (nvaneris_v2_proposal2num nvOp)) (lambda (nvprp1)
(declare (ignore nvprp1))
(lambda (nvprp2)
(funcall nvprp2))) (make-pair :fst (funcall nvslt) :snd (funcall nvcmdt)) (funcall nvdecisions))))))

(defun nvaneris_v2_dec2slt (nvOp)
(declare (ignore nvOp))
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvslt (pair-fst pair))
(nvcmdt (pair-snd pair)))
(declare (ignore nvcmdt))
nvslt))))

(defun nvaneris_v2_filter_out_todo (nvOp)
(lambda (nvslt)
(lambda (nvtodo)
(nvremove-combine (lambda (nvprp)
(- (funcall (nvaneris_v2_dec2slt nvOp)
(lambda () (funcall nvprp))) (funcall nvslt))) (funcall nvtodo)))))

(defun nvaneris_v2_on_slot_num_cmd (nvOp nvbcast nvclients nvdecision nvpax_propose nvresponse nvswap nvtt_propose nvf)
(lambda (nvcmdt)
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nva (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvb (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvc (pair-fst pair))
(nvzz3 (pair-snd pair)))
(let ((pair nvzz3))
(let ((nvd (pair-fst pair))
(nvzz4 (pair-snd pair)))
(let ((pair nvzz4))
(let ((nve (pair-fst pair))
(nvf_ (pair-snd pair)))
(funcall (lambda (nvx)
(if (inl-p (funcall (funcall (nvaneris_v2_is_decision nvOp)
(lambda () (funcall nvcmdt)))
(lambda () nvd)))
(make-pair :fst (make-pair :fst nva :snd (make-pair :fst nvb :snd (make-pair :fst nvc :snd (make-pair :fst nvd :snd (make-pair :fst (funcall nvx) :snd nvf_))))) :snd (make-axiom))
(let ((pair (funcall (funcall (funcall (nvaneris_v2_perform nvOp nvbcast nvclients nvdecision nvpax_propose nvresponse nvswap nvtt_propose nvf)
(lambda () (funcall nvcmdt)))
(lambda () nva))
(lambda () nvf_))))
(let ((nvprotocol_ (pair-fst pair))
(nvmsgs (pair-snd pair)))
(funcall (lambda (nvx_)
(make-pair :fst (make-pair :fst (+ nva 1) :snd (make-pair :fst (nvbfalse) :snd (make-pair :fst nvc :snd (make-pair :fst (funcall nvx_) :snd (make-pair :fst (funcall nvx) :snd nvprotocol_))))) :snd nvmsgs))
(lambda () (funcall (funcall (funcall (nvaneris_v2_add_decision nvOp)
(lambda () nva))
(lambda () (funcall nvcmdt)))
(lambda () nvd))))))))
(lambda () (funcall (funcall (nvaneris_v2_filter_out_todo nvOp)
(lambda () nva))
(lambda () nve)))))))))))))))))

(defun nvaneris_v2_on_slot_num (nvOp nvbcast nvclients nvdecision nvpax_propose nvresponse nvswap nvtt_propose nvf)
(lambda (nvza)
(lambda (nvz)
(let ((pair (funcall nvza)))
(let ((nvslt (pair-fst pair))
(nvcmdt (pair-snd pair)))
(let ((pair (funcall nvz)))
(let ((nva (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvb (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvc (pair-fst pair))
(nvzz3 (pair-snd pair)))
(let ((pair nvzz3))
(let ((nvd (pair-fst pair))
(nvzz4 (pair-snd pair)))
(let ((pair nvzz4))
(let ((nve (pair-fst pair))
(nvf_ (pair-snd pair)))
(if (inl-p (nveq_int nvslt nva))
(funcall (funcall (nvaneris_v2_on_slot_num_cmd nvOp nvbcast nvclients nvdecision nvpax_propose nvresponse nvswap nvtt_propose nvf)
(lambda () nvcmdt))
(lambda () (make-pair :fst nva :snd (make-pair :fst nvb :snd (make-pair :fst nvc :snd (make-pair :fst nvd :snd (make-pair :fst nve :snd nvf_)))))))
(make-pair :fst (make-pair :fst nva :snd (make-pair :fst nvb :snd (make-pair :fst nvc :snd (make-pair :fst nvd :snd (make-pair :fst nve :snd nvf_))))) :snd (make-axiom))))))))))))))))))

(defun nvselect (nvi nvl)
(funcall (funcall (fix (lambda (nvlist_ind)
(lambda (nvL)
(if (pair-p (funcall nvL))
(let ((pair (funcall nvL)))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(lambda (nvj)
(if (< (funcall nvj) 1)
nvh
(let ((nvj_ (- (funcall nvj) 1)))
(funcall (funcall (funcall nvlist_ind)
(lambda () nvt))
(lambda () nvj_)))))))
(if (axiom-p (funcall nvL))
(lambda (nvj)
(declare (ignore nvj))
(make-axiom))
(error "bottom"))))))
(lambda () nvl))
(lambda () nvi)))

(defun nvlast (nvL)
(nvselect (- (nvlength nvL) 1) nvL))

(defun nvaneris_v2_command_tag2cid (nvOp)
(declare (ignore nvOp))
(lambda (nvcmdt)
(let ((dec (funcall nvcmdt)))
(if (inl-p dec)
(let ((nvz (inl-val dec)))
(let ((pair nvz))
(let ((nvcid (pair-fst pair))
(nvx (pair-snd pair)))
(declare (ignore nvx))
nvcid)))
(if (inr-p dec)
(let ((nvz (inr-val dec)))
(let ((pair nvz))
(let ((nvcid (pair-fst pair))
(nvx (pair-snd pair)))
(declare (ignore nvx))
nvcid)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))

(defun nvaneris_v2_filter_out_proposals (nvOp)
(lambda (nvcmdt)
(lambda (nvproposals)
(funcall (lambda (nvx)
(nvremove-combine (lambda (nvprp)
(- (funcall nvx) (funcall (nvaneris_v2_command_tag2cid nvOp)
(lambda () (funcall nvprp))))) (funcall nvproposals)))
(lambda () (funcall (nvaneris_v2_command_tag2cid nvOp)
(lambda () (funcall nvcmdt))))))))

(defun nvint-minus-comparison-inc (nvf)
(lambda (nvx)
(lambda (nvy)
(- (funcall nvf
(lambda () (funcall nvy))) (funcall nvf
(lambda () (funcall nvx)))))))

(defun nvaneris_v2_add_todo (nvOp)
(lambda (nvslot_num)
(lambda (nvslt)
(lambda (nvcmdt)
(lambda (nvdecisions)
(lambda (nvtodo)
(if (inl-p (nvbor (nvlt_int (funcall nvslt) (funcall nvslot_num)) (funcall (funcall (nvaneris_v2_is_decision nvOp)
(lambda () (funcall nvcmdt)))
(lambda () (funcall nvdecisions)))))
(funcall nvtodo)
(nvinsert-combine (nvint-minus-comparison-inc (nvaneris_v2_dec2slt nvOp)) (lambda (nvprp1)
(declare (ignore nvprp1))
(lambda (nvprp2)
(funcall nvprp2))) (make-pair :fst (funcall nvslt) :snd (funcall nvcmdt)) (funcall nvtodo)))))))))

(defun nvaneris_v2_on_decision (nvOp nvbcast nvclients nvdecision nvpax_procs nvpax_propose nvresponse nvswap nvtt_procs nvtt_propose nvf)
(lambda (nvzc)
(lambda (nvzb)
(let ((pair (funcall nvzc)))
(let ((nvslt (pair-fst pair))
(nvcmdt (pair-snd pair)))
(let ((pair (funcall nvzb)))
(let ((nva (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvb (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvc (pair-fst pair))
(nvzz3 (pair-snd pair)))
(let ((pair nvzz3))
(let ((nvd (pair-fst pair))
(nvzz4 (pair-snd pair)))
(let ((pair nvzz4))
(let ((nve (pair-fst pair))
(nvf_ (pair-snd pair)))
(funcall (lambda (nvx)
(funcall (lambda (nvx_)
(let ((pair (funcall (funcall (funcall (nvaneris_v2_iterate_tr nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtt_propose nvf)
(lambda () (nvaneris_v2_on_slot_num nvOp nvbcast nvclients nvdecision nvpax_propose nvresponse nvswap nvtt_propose nvf)))
(lambda () (make-pair :fst nva :snd (make-pair :fst nvb :snd (make-pair :fst (funcall nvx_) :snd (make-pair :fst nvd :snd (make-pair :fst (funcall nvx) :snd nvf_)))))))
(lambda () (funcall nvx)))))
(let ((nvz (pair-fst pair))
(nvmsgs1 (pair-snd pair)))
(let ((pair nvz))
(let ((nva (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvb (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvc (pair-fst pair))
(nvzz3 (pair-snd pair)))
(let ((pair nvzz3))
(let ((nvd (pair-fst pair))
(nvzz4 (pair-snd pair)))
(let ((pair nvzz4))
(let ((nve (pair-fst pair))
(nvf_ (pair-snd pair)))
(let ((pair (if (inl-p (nvbnot (nvnull nvc)))
(funcall (funcall (nvaneris_v2_propose nvOp nvbcast nvdecision nvpax_procs nvpax_propose nvresponse nvswap nvtt_procs nvtt_propose nvf)
(lambda () (nvlast nvc)))
(lambda () (make-pair :fst nva :snd (make-pair :fst nvb :snd (make-pair :fst nvc :snd (make-pair :fst nvd :snd (make-pair :fst nve :snd nvf_)))))))
(make-pair :fst (make-pair :fst nva :snd (make-pair :fst nvb :snd (make-pair :fst nvc :snd (make-pair :fst nvd :snd (make-pair :fst nve :snd nvf_))))) :snd (make-axiom)))))
(let ((nvstate (pair-fst pair))
(nvmsgs2 (pair-snd pair)))
(make-pair :fst nvstate :snd (nvbag-append nvmsgs1 nvmsgs2)))))))))))))))))
(lambda () (funcall (funcall (nvaneris_v2_filter_out_proposals nvOp)
(lambda () nvcmdt))
(lambda () nvc)))))
(lambda () (funcall (funcall (funcall (funcall (funcall (nvaneris_v2_add_todo nvOp)
(lambda () nva))
(lambda () nvslt))
(lambda () nvcmdt))
(lambda () nvd))
(lambda () nve)))))))))))))))))))

(defun main ()
(lambda (nvOp)
(lambda (nveq_Op)
(lambda (nvaccpts)
(lambda (nvldrs)
(lambda (nvldrs_uid)
(lambda (nvlocs)
(lambda (nvreps)
(lambda (nvclients)
(lambda (nvflrs)
(lambda (nvf)
(lambda (nvi)
(nvhdf-parallel (nvhdf-parallel (let ((dec (nvdeq-member (lambda (nva)
(lambda (nvb)
(if (string= (funcall nva) (funcall nvb))
(make-inl :val (make-axiom))
(make-inr :val (make-axiom))))) (funcall nvi) (funcall nvldrs))))
(if (inl-p dec)
(nvhdf-parallel (nvhdf-parallel (nvhdf-parallel (nvhdf-parallel (nvhdf-bind (make-inl :val (lambda (nvm)
(declare (ignore nvm))
(make-pair :fst (make-inr :val (make-axiom)) :snd (make-pair :fst (funcall (lambda (nvloc)
(funcall (lambda (nvx)
(funcall (funcall (fix (lambda (nvlist_accum)
(lambda (nvy)
(lambda (nvL)
(if (pair-p (funcall nvL))
(let ((pair (funcall nvL)))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(funcall (funcall (funcall nvlist_accum)
(lambda () (funcall (lambda (nvx_)
(let ((dec (let ((dec (if (< (funcall nvx) (funcall nvx_))
(make-inl :val (make-axiom))
(make-inr :val (make-axiom)))))
(if (inl-p dec)
(make-inr :val (make-axiom))
(if (inr-p dec)
(make-inl :val (make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))
(if (inl-p dec)
(funcall nvy)
(if (inr-p dec)
(let ((dec (funcall nvy)))
(if (inl-p dec)
(let ((nvl (inl-val dec)))
(let ((dec (if (< (funcall nvx_) (funcall (funcall nvldrs_uid)
(lambda () nvl)))
(make-inl :val (make-axiom))
(make-inr :val (make-axiom)))))
(if (inl-p dec)
(make-inl :val nvh)
(if (inr-p dec)
(funcall nvy)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(if (inr-p dec)
(make-inl :val nvh)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(lambda () (funcall (funcall nvldrs_uid)
(lambda () nvh))))))
(lambda () nvt))))
(if (axiom-p (funcall nvL))
(funcall nvy)
(error "bottom")))))))
(lambda () (make-inr :val (make-axiom))))
(lambda () (funcall nvldrs))))
(lambda () (funcall (funcall nvldrs_uid)
(lambda () (funcall nvloc))))))
(lambda () (funcall nvi))) :snd (make-axiom))))) (lambda (nvx)
(let ((dec (funcall nvx)))
(if (inl-p dec)
(let ((nvl (inl-val dec)))
(nvhdf-parallel (nvhdf-parallel (make-inl :val (lambda (nvm)
(declare (ignore nvm))
(make-pair :fst (make-inr :val (make-axiom)) :snd (make-pair :fst (funcall (funcall (lambda (nvl)
(lambda (nvz)
(make-pair :fst 0 :snd (make-pair :fst (funcall nvl) :snd (make-pair :fst (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "ping" :snd (make-axiom))) :snd (funcall nvz))))))
(lambda () nvl))
(lambda () (funcall nvi))) :snd (make-axiom))))) (make-inl :val (lambda (nvm)
(declare (ignore nvm))
(make-pair :fst (make-inr :val (make-axiom)) :snd (make-pair :fst (funcall (funcall (funcall (lambda (nvn)
(lambda (nvl)
(lambda (nvz)
(make-pair :fst (funcall nvn) :snd (make-pair :fst (funcall nvl) :snd (make-pair :fst (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "react" :snd (make-axiom))) :snd (funcall nvz)))))))
(lambda () 10))
(lambda () (funcall nvi)))
(lambda () (make-axiom))) :snd (make-axiom)))))) (funcall (fix (lambda (nvmk-hdf)
(lambda (nvs)
(make-inl :val (lambda (nva)
(let ((pair (funcall nva)))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(declare (ignore nvy))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "react" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nvv4 (nvmap (lambda (nvz)
(declare (ignore nvz))
(make-inr :val (make-axiom))) (funcall nvs))))
(let ((dec (nvbag-null nvv4)))
(if (inl-p dec)
(let ((nvv5 (funcall nvs)))
(let ((nvv6 (nvbag-union (nvbag-map (lambda (nvx)
(let ((dec (funcall nvx)))
(if (inl-p dec)
(make-pair :fst (funcall (funcall (lambda (nvl)
(lambda (nvz)
(make-pair :fst 0 :snd (make-pair :fst (funcall nvl) :snd (make-pair :fst (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "ping" :snd (make-axiom))) :snd (funcall nvz))))))
(lambda () nvl))
(lambda () (funcall nvi))) :snd (make-pair :fst (funcall (funcall (funcall (lambda (nvn)
(lambda (nvl)
(lambda (nvz)
(make-pair :fst (funcall nvn) :snd (make-pair :fst (funcall nvl) :snd (make-pair :fst (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "react" :snd (make-axiom))) :snd (funcall nvz)))))))
(lambda () 10))
(lambda () (funcall nvi)))
(lambda () (make-axiom))) :snd (make-axiom)))
(if (inr-p dec)
(make-pair :fst (funcall (funcall (lambda (nvl)
(lambda (nvz)
(make-pair :fst 0 :snd (make-pair :fst (funcall nvl) :snd (make-pair :fst (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "start" :snd (make-axiom))) :snd (funcall nvz))))))
(lambda () (funcall nvi)))
(lambda () (make-axiom))) :snd (make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))) (funcall nvs)))))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv5)) :snd nvv6)))
(if (inr-p dec)
(let ((nvv6 (nvbag-union (nvbag-map (lambda (nvx)
(let ((dec (funcall nvx)))
(if (inl-p dec)
(make-pair :fst (funcall (funcall (lambda (nvl)
(lambda (nvz)
(make-pair :fst 0 :snd (make-pair :fst (funcall nvl) :snd (make-pair :fst (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "ping" :snd (make-axiom))) :snd (funcall nvz))))))
(lambda () nvl))
(lambda () (funcall nvi))) :snd (make-pair :fst (funcall (funcall (funcall (lambda (nvn)
(lambda (nvl)
(lambda (nvz)
(make-pair :fst (funcall nvn) :snd (make-pair :fst (funcall nvl) :snd (make-pair :fst (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "react" :snd (make-axiom))) :snd (funcall nvz)))))))
(lambda () 10))
(lambda () (funcall nvi)))
(lambda () (make-axiom))) :snd (make-axiom)))
(if (inr-p dec)
(make-pair :fst (funcall (funcall (lambda (nvl)
(lambda (nvz)
(make-pair :fst 0 :snd (make-pair :fst (funcall nvl) :snd (make-pair :fst (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "start" :snd (make-axiom))) :snd (funcall nvz))))))
(lambda () (funcall nvi)))
(lambda () (make-axiom))) :snd (make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))) (funcall nvs)))))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv4)) :snd nvv6))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(if (inr-p dec)
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "pong" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nvv4 (nvmap (lambda (nvz)
(declare (ignore nvz))
(make-inl :val (make-axiom))) (funcall nvs))))
(let ((dec (nvbag-null nvv4)))
(if (inl-p dec)
(let ((nvv5 (funcall nvs)))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv5)) :snd (make-axiom)))
(if (inr-p dec)
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv4)) :snd (make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(if (inr-p dec)
(let ((nvv5 (funcall nvs)))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv5)) :snd (make-axiom)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))))))
(lambda () (make-pair :fst (make-inr :val (make-axiom)) :snd (make-axiom))))))
(if (inr-p dec)
(funcall (fix (lambda (nvmk-hdf)
(lambda (nvs)
(make-inl :val (lambda (nvv)
(let ((pair (funcall nvs)))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((pair (funcall nvv)))
(let ((nvx1 (pair-fst pair))
(nvy1 (pair-snd pair)))
(let ((dec (nvname_eq nvx1 (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p1b" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nvv1 (funcall (funcall (funcall (nvaneris_pax_v1_scout_output "UNION" (funcall nvaccpts) (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (funcall nvf))
(lambda () (funcall (funcall (nvaneris_pax_v1_mk_bnum)
(lambda () 0))
(lambda () (funcall nvi)))))
(lambda () (funcall nvi)))
(lambda () nvy1))))
(let ((nvv2 (funcall (funcall (funcall (funcall (nvaneris_pax_v1_on_p1b "UNION" (funcall nvldrs_uid))
(lambda () (funcall (funcall (nvaneris_pax_v1_mk_bnum)
(lambda () 0))
(lambda () (funcall nvi)))))
(lambda () (funcall nvi)))
(lambda () nvy1))
(lambda () nvy))))
(let ((nvv3 (nvappend (funcall nvv1
(lambda () nvv2)) (make-axiom))))
(let ((dec nvx))
(if (inl-p dec)
(let ((nvv4 (nvappend (funcall (funcall (nvaneris_pax_v1_p1a_broadcast "UNION" (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (funcall nvf))
(lambda () (funcall nvaccpts)))
(lambda () (make-pair :fst (funcall nvi) :snd (funcall (funcall (nvaneris_pax_v1_mk_bnum)
(lambda () 0))
(lambda () (funcall nvi)))))) nvv3)))
(make-pair :fst (let ((dec (nvnull nvv3)))
(if (inl-p dec)
(funcall (funcall nvmk-hdf)
(lambda () (make-pair :fst (make-inr :val (make-axiom)) :snd nvv2)))
(if (inr-p dec)
(make-inr :val (make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))) :snd nvv4))
(if (inr-p dec)
(make-pair :fst (let ((dec (nvnull nvv3)))
(if (inl-p dec)
(funcall (funcall nvmk-hdf)
(lambda () (make-pair :fst (make-inr :val (make-axiom)) :snd nvv2)))
(if (inr-p dec)
(make-inr :val (make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))) :snd nvv3)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))
(if (inr-p dec)
(let ((nvv2 nvy))
(let ((dec nvx))
(if (inl-p dec)
(let ((nvv4 (nvappend (funcall (funcall (nvaneris_pax_v1_p1a_broadcast "UNION" (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (funcall nvf))
(lambda () (funcall nvaccpts)))
(lambda () (make-pair :fst (funcall nvi) :snd (funcall (funcall (nvaneris_pax_v1_mk_bnum)
(lambda () 0))
(lambda () (funcall nvi)))))) (make-axiom))))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () (make-pair :fst (make-inr :val (make-axiom)) :snd nvv2))) :snd nvv4))
(if (inr-p dec)
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () (make-pair :fst (make-inr :val (make-axiom)) :snd nvv2))) :snd (make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))))))))
(lambda () (make-pair :fst (make-inl :val (make-axiom)) :snd (nvaneris_pax_v1_init_scout "UNION" (funcall nvaccpts)))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))) (nvhdf-bind (nvhdf-once (fix (lambda (nvmk-hdf)
(make-inl :val (lambda (nva)
(make-pair :fst (funcall nvmk-hdf) :snd (let ((pair (funcall nva)))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "start" :snd (make-axiom))))))
(if (inl-p dec)
(make-pair :fst nvy :snd (make-axiom))
(if (inr-p dec)
(make-axiom)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))))))) (lambda (nvx)
(declare (ignore nvx))
(funcall (fix (lambda (nvmk-hdf)
(lambda (nvs)
(make-inl :val (lambda (nvv)
(let ((pair (funcall nvs)))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((pair (funcall nvv)))
(let ((nvx1 (pair-fst pair))
(nvy1 (pair-snd pair)))
(let ((dec (nvname_eq nvx1 (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p1b" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nvv1 (funcall (funcall (funcall (nvaneris_pax_v1_scout_output "UNION" (funcall nvaccpts) (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (funcall nvf))
(lambda () (funcall (funcall (nvaneris_pax_v1_mk_bnum)
(lambda () 0))
(lambda () (funcall nvi)))))
(lambda () (funcall nvi)))
(lambda () nvy1))))
(let ((nvv2 (funcall (funcall (funcall (funcall (nvaneris_pax_v1_on_p1b "UNION" (funcall nvldrs_uid))
(lambda () (funcall (funcall (nvaneris_pax_v1_mk_bnum)
(lambda () 0))
(lambda () (funcall nvi)))))
(lambda () (funcall nvi)))
(lambda () nvy1))
(lambda () nvy))))
(let ((nvv3 (nvappend (funcall nvv1
(lambda () nvv2)) (make-axiom))))
(let ((dec nvx))
(if (inl-p dec)
(let ((nvv4 (nvappend (funcall (funcall (nvaneris_pax_v1_p1a_broadcast "UNION" (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (funcall nvf))
(lambda () (funcall nvaccpts)))
(lambda () (make-pair :fst (funcall nvi) :snd (funcall (funcall (nvaneris_pax_v1_mk_bnum)
(lambda () 0))
(lambda () (funcall nvi)))))) nvv3)))
(make-pair :fst (let ((dec (nvnull nvv3)))
(if (inl-p dec)
(funcall (funcall nvmk-hdf)
(lambda () (make-pair :fst (make-inr :val (make-axiom)) :snd nvv2)))
(if (inr-p dec)
(make-inr :val (make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))) :snd nvv4))
(if (inr-p dec)
(make-pair :fst (let ((dec (nvnull nvv3)))
(if (inl-p dec)
(funcall (funcall nvmk-hdf)
(lambda () (make-pair :fst (make-inr :val (make-axiom)) :snd nvv2)))
(if (inr-p dec)
(make-inr :val (make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))) :snd nvv3)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))
(if (inr-p dec)
(let ((nvv2 nvy))
(let ((dec nvx))
(if (inl-p dec)
(let ((nvv4 (nvappend (funcall (funcall (nvaneris_pax_v1_p1a_broadcast "UNION" (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (funcall nvf))
(lambda () (funcall nvaccpts)))
(lambda () (make-pair :fst (funcall nvi) :snd (funcall (funcall (nvaneris_pax_v1_mk_bnum)
(lambda () 0))
(lambda () (funcall nvi)))))) (make-axiom))))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () (make-pair :fst (make-inr :val (make-axiom)) :snd nvv2))) :snd nvv4))
(if (inr-p dec)
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () (make-pair :fst (make-inr :val (make-axiom)) :snd nvv2))) :snd (make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))))))))
(lambda () (make-pair :fst (make-inl :val (make-axiom)) :snd (nvaneris_pax_v1_init_scout "UNION" (funcall nvaccpts)))))))) (nvhdf-bind (funcall (fix (lambda (nvmk-hdf)
(lambda (nvs)
(make-inl :val (lambda (nva)
(let ((pair (funcall nva)))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))))))
(if (inl-p dec)
(let ((nvv10 (nvmap (funcall (funcall (nvaneris_pax_v1_on_propose "UNION")
(lambda () (funcall nvi)))
(lambda () nvy)) (funcall nvs))))
(let ((dec (nvbag-null nvv10)))
(if (inl-p dec)
(let ((nvv11 (funcall nvs)))
(let ((nvv12 (nvbag-union (nvbag-map (lambda (nvx)
(funcall (funcall (funcall (nvaneris_pax_v1_leader_propose "UNION")
(lambda () (funcall nvi)))
(lambda () nvy))
(lambda () (funcall nvx)))) (funcall nvs)))))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv11)) :snd nvv12)))
(if (inr-p dec)
(let ((nvv12 (nvbag-union (nvbag-map (lambda (nvx)
(funcall (funcall (funcall (nvaneris_pax_v1_leader_propose "UNION")
(lambda () (funcall nvi)))
(lambda () nvy))
(lambda () (funcall nvx)))) (funcall nvs)))))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv10)) :snd nvv12))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(if (inr-p dec)
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "adopted" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nvv1 (funcall (funcall (nvaneris_pax_v1_leader_adopted "UNION")
(lambda () (funcall nvi)))
(lambda () nvy))))
(let ((nvv4 (funcall (funcall (nvaneris_pax_v1_when_adopted "UNION")
(lambda () (funcall nvi)))
(lambda () nvy))))
(let ((nvv10 (nvmap nvv4 (funcall nvs))))
(let ((dec (nvbag-null nvv10)))
(if (inl-p dec)
(let ((nvv11 (funcall nvs)))
(let ((nvv12 (nvbag-union (nvbag-map (lambda (nvx)
(funcall nvv1
(lambda () (funcall nvx)))) (funcall nvs)))))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv11)) :snd nvv12)))
(if (inr-p dec)
(let ((nvv12 (nvbag-union (nvbag-map (lambda (nvx)
(funcall nvv1
(lambda () (funcall nvx)))) (funcall nvs)))))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv10)) :snd nvv12))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))
(if (inr-p dec)
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "preempted" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nvv10 (nvmap (funcall (funcall (nvaneris_pax_v1_when_preempted "UNION" (funcall nvldrs_uid))
(lambda () (funcall nvi)))
(lambda () nvy)) (funcall nvs))))
(let ((dec (nvbag-null nvv10)))
(if (inl-p dec)
(let ((nvv11 (funcall nvs)))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv11)) :snd (make-axiom)))
(if (inr-p dec)
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv10)) :snd (make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(if (inr-p dec)
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "decided" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nvv10 (nvmap (funcall (funcall (nvaneris_pax_v1_when_decided "UNION")
(lambda () (funcall nvi)))
(lambda () nvy)) (funcall nvs))))
(let ((dec (nvbag-null nvv10)))
(if (inl-p dec)
(let ((nvv11 (funcall nvs)))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv11)) :snd (make-axiom)))
(if (inr-p dec)
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv10)) :snd (make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(if (inr-p dec)
(let ((nvv11 (funcall nvs)))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv11)) :snd (make-axiom)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))))))
(lambda () (make-pair :fst (funcall (lambda (nvloc)
(make-pair :fst (funcall (lambda (nvloc)
(funcall (funcall (lambda (nvn)
(lambda (nvloc)
(make-inl :val (make-pair :fst (funcall nvn) :snd (funcall nvloc)))))
(lambda () 0))
(lambda () (funcall nvloc))))
(lambda () (funcall nvloc))) :snd (make-pair :fst (make-inr :val (make-axiom)) :snd (make-pair :fst (make-axiom) :snd (make-pair :fst 0 :snd (make-axiom))))))
(lambda () (funcall nvi))) :snd (make-axiom)))) (lambda (nvx)
(nvhdf-parallel (make-inl :val (lambda (nvm)
(declare (ignore nvm))
(make-pair :fst (make-inr :val (make-axiom)) :snd (funcall (funcall (nvaneris_pax_v1_p2a_broadcast "UNION" (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (funcall nvf))
(lambda () (funcall nvaccpts)))
(lambda () (make-pair :fst (funcall nvi) :snd (funcall nvx))))))) (let ((pair (funcall (nvaneris_pax_v1_dest_pv "UNION")
(lambda () (funcall nvx)))))
(let ((nvbnum (pair-fst pair))
(nvzz (pair-snd pair)))
(let ((pair nvzz))
(let ((nvslt (pair-fst pair))
(nvcmd (pair-snd pair)))
(declare (ignore nvcmd))
(funcall (fix (lambda (nvmk-hdf)
(lambda (nvs)
(make-inl :val (lambda (nvv)
(let ((pair (funcall nvv)))
(let ((nvx1 (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx1 (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p2b" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nvv1 (funcall (funcall (funcall (nvaneris_pax_v1_commander_output "UNION" (funcall nvaccpts) (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (funcall nvldrs) (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (funcall nvreps) (funcall nvf))
(lambda () (funcall nvx)))
(lambda () (funcall nvi)))
(lambda () nvy))))
(let ((nvv2 (funcall (funcall (funcall (funcall (funcall (nvaneris_pax_v1_on_p2b)
(lambda () nvbnum))
(lambda () nvslt))
(lambda () (funcall nvi)))
(lambda () nvy))
(lambda () (funcall nvs)))))
(let ((nvv3 (nvappend (funcall nvv1
(lambda () nvv2)) (make-axiom))))
(make-pair :fst (let ((dec (nvnull nvv3)))
(if (inl-p dec)
(funcall (funcall nvmk-hdf)
(lambda () nvv2))
(if (inr-p dec)
(make-inr :val (make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))) :snd nvv3))))
(if (inr-p dec)
(let ((nvv2 (funcall nvs)))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv2)) :snd (make-axiom)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))))))
(lambda () (funcall nvaccpts))))))))))) (nvhdf-bind (funcall (fix (lambda (nvmk-hdf)
(lambda (nvs)
(make-inl :val (lambda (nva)
(let ((pair (funcall nva)))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "preempted" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nvv8 (nvmap (funcall (funcall (nvaneris_pax_v1_when_preempted "UNION" (funcall nvldrs_uid))
(lambda () (funcall nvi)))
(lambda () nvy)) (funcall nvs))))
(let ((dec (nvbag-null nvv8)))
(if (inl-p dec)
(let ((nvv9 (funcall nvs)))
(let ((nvv10 (nvbag-union (nvbag-map (lambda (nvx)
(funcall (funcall (funcall (nvaneris_pax_v1_leader_preempted "UNION" (funcall nvldrs_uid))
(lambda () (funcall nvi)))
(lambda () nvy))
(lambda () (funcall nvx)))) (funcall nvs)))))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv9)) :snd nvv10)))
(if (inr-p dec)
(let ((nvv10 (nvbag-union (nvbag-map (lambda (nvx)
(funcall (funcall (funcall (nvaneris_pax_v1_leader_preempted "UNION" (funcall nvldrs_uid))
(lambda () (funcall nvi)))
(lambda () nvy))
(lambda () (funcall nvx)))) (funcall nvs)))))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv8)) :snd nvv10))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(if (inr-p dec)
(let ((dec (nvname_eq nvx (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))))))
(if (inl-p dec)
(let ((nvv8 (nvmap (funcall (funcall (nvaneris_pax_v1_on_propose "UNION")
(lambda () (funcall nvi)))
(lambda () nvy)) (funcall nvs))))
(let ((dec (nvbag-null nvv8)))
(if (inl-p dec)
(let ((nvv9 (funcall nvs)))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv9)) :snd (make-axiom)))
(if (inr-p dec)
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv8)) :snd (make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(if (inr-p dec)
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "adopted" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nvv2 (funcall (funcall (nvaneris_pax_v1_when_adopted "UNION")
(lambda () (funcall nvi)))
(lambda () nvy))))
(let ((nvv8 (nvmap nvv2 (funcall nvs))))
(let ((dec (nvbag-null nvv8)))
(if (inl-p dec)
(let ((nvv9 (funcall nvs)))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv9)) :snd (make-axiom)))
(if (inr-p dec)
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv8)) :snd (make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))
(if (inr-p dec)
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "decided" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nvv8 (nvmap (funcall (funcall (nvaneris_pax_v1_when_decided "UNION")
(lambda () (funcall nvi)))
(lambda () nvy)) (funcall nvs))))
(let ((dec (nvbag-null nvv8)))
(if (inl-p dec)
(let ((nvv9 (funcall nvs)))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv9)) :snd (make-axiom)))
(if (inr-p dec)
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv8)) :snd (make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(if (inr-p dec)
(let ((nvv9 (funcall nvs)))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv9)) :snd (make-axiom)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))))))
(lambda () (make-pair :fst (funcall (lambda (nvloc)
(make-pair :fst (funcall (lambda (nvloc)
(funcall (funcall (lambda (nvn)
(lambda (nvloc)
(make-inl :val (make-pair :fst (funcall nvn) :snd (funcall nvloc)))))
(lambda () 0))
(lambda () (funcall nvloc))))
(lambda () (funcall nvloc))) :snd (make-pair :fst (make-inr :val (make-axiom)) :snd (make-pair :fst (make-axiom) :snd (make-pair :fst 0 :snd (make-axiom))))))
(lambda () (funcall nvi))) :snd (make-axiom)))) (lambda (nvx)
(funcall (fix (lambda (nvmk-hdf)
(lambda (nvs)
(make-inl :val (lambda (nvv)
(let ((pair (funcall nvs)))
(let ((nvx1 (pair-fst pair))
(nvy (pair-snd pair)))
(let ((pair (funcall nvv)))
(let ((nvx2 (pair-fst pair))
(nvy1 (pair-snd pair)))
(let ((dec (nvname_eq nvx2 (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p1b" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nvv1 (funcall (funcall (funcall (nvaneris_pax_v1_scout_output "UNION" (funcall nvaccpts) (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (funcall nvf))
(lambda () (funcall nvx)))
(lambda () (funcall nvi)))
(lambda () nvy1))))
(let ((nvv2 (funcall (funcall (funcall (funcall (nvaneris_pax_v1_on_p1b "UNION" (funcall nvldrs_uid))
(lambda () (funcall nvx)))
(lambda () (funcall nvi)))
(lambda () nvy1))
(lambda () nvy))))
(let ((nvv3 (nvappend (funcall nvv1
(lambda () nvv2)) (make-axiom))))
(let ((dec nvx1))
(if (inl-p dec)
(let ((nvv4 (nvappend (funcall (funcall (nvaneris_pax_v1_p1a_broadcast "UNION" (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (funcall nvf))
(lambda () (funcall nvaccpts)))
(lambda () (make-pair :fst (funcall nvi) :snd (funcall nvx)))) nvv3)))
(make-pair :fst (let ((dec (nvnull nvv3)))
(if (inl-p dec)
(funcall (funcall nvmk-hdf)
(lambda () (make-pair :fst (make-inr :val (make-axiom)) :snd nvv2)))
(if (inr-p dec)
(make-inr :val (make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))) :snd nvv4))
(if (inr-p dec)
(make-pair :fst (let ((dec (nvnull nvv3)))
(if (inl-p dec)
(funcall (funcall nvmk-hdf)
(lambda () (make-pair :fst (make-inr :val (make-axiom)) :snd nvv2)))
(if (inr-p dec)
(make-inr :val (make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))) :snd nvv3)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))
(if (inr-p dec)
(let ((nvv2 nvy))
(let ((dec nvx1))
(if (inl-p dec)
(let ((nvv4 (nvappend (funcall (funcall (nvaneris_pax_v1_p1a_broadcast "UNION" (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (funcall nvf))
(lambda () (funcall nvaccpts)))
(lambda () (make-pair :fst (funcall nvi) :snd (funcall nvx)))) (make-axiom))))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () (make-pair :fst (make-inr :val (make-axiom)) :snd nvv2))) :snd nvv4))
(if (inr-p dec)
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () (make-pair :fst (make-inr :val (make-axiom)) :snd nvv2))) :snd (make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))))))))
(lambda () (make-pair :fst (make-inl :val (make-axiom)) :snd (nvaneris_pax_v1_init_scout "UNION" (funcall nvaccpts)))))))) (fix (lambda (nvmk-hdf)
(make-inl :val (lambda (nva)
(let ((nvv (nvbag-union (nvbag-map (lambda (nvx)
(make-pair :fst (funcall (funcall (lambda (nvl)
(lambda (nvz)
(make-pair :fst 0 :snd (make-pair :fst (funcall nvl) :snd (make-pair :fst (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "pong" :snd (make-axiom))) :snd (funcall nvz))))))
(lambda () (funcall nvx)))
(lambda () (make-axiom))) :snd (make-axiom))) (let ((pair (funcall nva)))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "ping" :snd (make-axiom))))))
(if (inl-p dec)
(make-pair :fst nvy :snd (make-axiom))
(if (inr-p dec)
(make-axiom)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))))))
(make-pair :fst (funcall nvmk-hdf) :snd nvv)))))))
(if (inr-p dec)
(nvhdf-halt)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))) (let ((dec (nvdeq-member (lambda (nva)
(lambda (nvb)
(if (string= (funcall nva) (funcall nvb))
(make-inl :val (make-axiom))
(make-inr :val (make-axiom))))) (funcall nvi) (funcall nvaccpts))))
(if (inl-p dec)
(funcall (fix (lambda (nvmk-hdf)
(lambda (nvs)
(make-inl :val (lambda (nva)
(let ((pair (funcall nva)))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p1a" :snd (make-axiom))))))
(if (inl-p dec)
(let ((pair nvy))
(let ((nvldr (pair-fst pair))
(nvbn (pair-snd pair)))
(let ((nvv6 (nvmap (funcall (funcall (nvaneris_pax_v1_on_p1a "UNION" (funcall nvldrs_uid))
(lambda () (funcall nvi)))
(lambda () (make-pair :fst nvldr :snd nvbn))) (funcall nvs))))
(let ((dec (nvbag-null nvv6)))
(if (inl-p dec)
(let ((nvv7 (funcall nvs)))
(let ((nvv8 (nvbag-union (nvbag-map (lambda (nvx)
(let ((pair (funcall nvx)))
(let ((nvbnum (pair-fst pair))
(nvpvals (pair-snd pair)))
(make-pair :fst (funcall (funcall (lambda (nvl)
(lambda (nvz)
(make-pair :fst 0 :snd (make-pair :fst (funcall nvl) :snd (make-pair :fst (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p1b" :snd (make-axiom))) :snd (funcall nvz))))))
(lambda () nvldr))
(lambda () (make-pair :fst (funcall nvi) :snd (make-pair :fst nvbn :snd (make-pair :fst nvbnum :snd nvpvals))))) :snd (make-axiom))))) nvv7))))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv7)) :snd nvv8)))
(if (inr-p dec)
(let ((nvv8 (nvbag-union (nvbag-map (lambda (nvx)
(let ((pair (funcall nvx)))
(let ((nvbnum (pair-fst pair))
(nvpvals (pair-snd pair)))
(make-pair :fst (funcall (funcall (lambda (nvl)
(lambda (nvz)
(make-pair :fst 0 :snd (make-pair :fst (funcall nvl) :snd (make-pair :fst (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p1b" :snd (make-axiom))) :snd (funcall nvz))))))
(lambda () nvldr))
(lambda () (make-pair :fst (funcall nvi) :snd (make-pair :fst nvbn :snd (make-pair :fst nvbnum :snd nvpvals))))) :snd (make-axiom))))) nvv6))))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv6)) :snd nvv8))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))
(if (inr-p dec)
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p2a" :snd (make-axiom))))))
(if (inl-p dec)
(let ((pair nvy))
(let ((nvldr (pair-fst pair))
(nvpvalue (pair-snd pair)))
(let ((nvv6 (nvmap (funcall (funcall (nvaneris_pax_v1_on_p2a "UNION" (funcall nvldrs_uid))
(lambda () (funcall nvi)))
(lambda () (make-pair :fst nvldr :snd nvpvalue))) (funcall nvs))))
(let ((dec (nvbag-null nvv6)))
(if (inl-p dec)
(let ((nvv7 (funcall nvs)))
(let ((nvv8 (nvbag-union (nvbag-map (lambda (nvx)
(let ((pair (funcall nvx)))
(let ((nvbnum (pair-fst pair))
(nvz (pair-snd pair)))
(declare (ignore nvz))
(let ((pair (funcall (nvaneris_pax_v1_dest_pv "UNION")
(lambda () nvpvalue))))
(let ((nvbn (pair-fst pair))
(nvzz (pair-snd pair)))
(let ((pair nvzz))
(let ((nvslt (pair-fst pair))
(nvcmd (pair-snd pair)))
(declare (ignore nvcmd))
(make-pair :fst (funcall (funcall (lambda (nvl)
(lambda (nvz)
(make-pair :fst 0 :snd (make-pair :fst (funcall nvl) :snd (make-pair :fst (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p2b" :snd (make-axiom))) :snd (funcall nvz))))))
(lambda () nvldr))
(lambda () (make-pair :fst (funcall nvi) :snd (make-pair :fst nvbn :snd (make-pair :fst nvslt :snd nvbnum))))) :snd (make-axiom))))))))) nvv7))))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv7)) :snd nvv8)))
(if (inr-p dec)
(let ((nvv8 (nvbag-union (nvbag-map (lambda (nvx)
(let ((pair (funcall nvx)))
(let ((nvbnum (pair-fst pair))
(nvz (pair-snd pair)))
(declare (ignore nvz))
(let ((pair (funcall (nvaneris_pax_v1_dest_pv "UNION")
(lambda () nvpvalue))))
(let ((nvbn (pair-fst pair))
(nvzz (pair-snd pair)))
(let ((pair nvzz))
(let ((nvslt (pair-fst pair))
(nvcmd (pair-snd pair)))
(declare (ignore nvcmd))
(make-pair :fst (funcall (funcall (lambda (nvl)
(lambda (nvz)
(make-pair :fst 0 :snd (make-pair :fst (funcall nvl) :snd (make-pair :fst (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p2b" :snd (make-axiom))) :snd (funcall nvz))))))
(lambda () nvldr))
(lambda () (make-pair :fst (funcall nvi) :snd (make-pair :fst nvbn :snd (make-pair :fst nvslt :snd nvbnum))))) :snd (make-axiom))))))))) nvv6))))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv6)) :snd nvv8))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))
(if (inr-p dec)
(let ((nvv7 (funcall nvs)))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv7)) :snd (make-axiom)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))))))
(lambda () (make-pair :fst (make-pair :fst (make-inr :val (make-axiom)) :snd (make-axiom)) :snd (make-axiom))))
(if (inr-p dec)
(nvhdf-halt)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))) (nvhdf-parallel (let ((dec (nvdeq-member (lambda (nva)
(lambda (nvb)
(if (string= (funcall nva) (funcall nvb))
(make-inl :val (make-axiom))
(make-inr :val (make-axiom))))) (funcall nvi) (funcall nvlocs))))
(if (inl-p dec)
(nvhdf-bind (nvhdf-compose2 (nvhdf-compose1 (funcall (nvaneris_23_v1_when_new_proposal "UNION")
(lambda () (funcall nvi))) (nvhdf-parallel (fix (lambda (nvmk-hdf)
(make-inl :val (lambda (nva)
(make-pair :fst (funcall nvmk-hdf) :snd (let ((pair (funcall nva)))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom)))))))
(if (inl-p dec)
(make-pair :fst nvy :snd (make-axiom))
(if (inr-p dec)
(make-axiom)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))))))) (fix (lambda (nvmk-hdf)
(make-inl :val (lambda (nva)
(let ((nvv (nvbag-union (nvbag-map (lambda (nvx)
(funcall (funcall (nvaneris_23_v1_vote2prop "UNION")
(lambda () (funcall nvi)))
(lambda () (funcall nvx)))) (let ((pair (funcall nva)))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_23_v1" :snd (make-pair :fst "vote" :snd (make-axiom))))))
(if (inl-p dec)
(make-pair :fst nvy :snd (make-axiom))
(if (inr-p dec)
(make-axiom)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))))))
(make-pair :fst (funcall nvmk-hdf) :snd nvv)))))))) (nvhdf-memory (nvhdf-compose1 (funcall (nvaneris_23_v1_update_replica "UNION")
(lambda () (funcall nvi))) (nvhdf-parallel (fix (lambda (nvmk-hdf)
(make-inl :val (lambda (nva)
(make-pair :fst (funcall nvmk-hdf) :snd (let ((pair (funcall nva)))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom)))))))
(if (inl-p dec)
(make-pair :fst nvy :snd (make-axiom))
(if (inr-p dec)
(make-axiom)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))))))) (fix (lambda (nvmk-hdf)
(make-inl :val (lambda (nva)
(let ((nvv (nvbag-union (nvbag-map (lambda (nvx)
(funcall (funcall (nvaneris_23_v1_vote2prop "UNION")
(lambda () (funcall nvi)))
(lambda () (funcall nvx)))) (let ((pair (funcall nva)))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_23_v1" :snd (make-pair :fst "vote" :snd (make-axiom))))))
(if (inl-p dec)
(make-pair :fst nvy :snd (make-axiom))
(if (inr-p dec)
(make-axiom)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))))))
(make-pair :fst (funcall nvmk-hdf) :snd nvv)))))))) (make-pair :fst (make-pair :fst 0 :snd (make-axiom)) :snd (make-axiom)))) (lambda (nvx)
(let ((pair (funcall nvx)))
(let ((nvn (pair-fst pair))
(nvc (pair-snd pair)))
(nvhdf-parallel (nvhdf-parallel (funcall (fix (lambda (nvmk-hdf)
(lambda (nvs)
(make-inl :val (lambda (nvv)
(let ((pair (funcall nvs)))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((pair (funcall nvv)))
(let ((nvx1 (pair-fst pair))
(nvy1 (pair-snd pair)))
(let ((dec (nvname_eq nvx1 (make-pair :fst "aneris_23_v1" :snd (make-pair :fst "vote" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nvv2 (funcall (funcall (funcall (funcall (nvaneris_23_v1_add_to_quorum "UNION")
(lambda () (make-pair :fst nvn :snd 0)))
(lambda () (funcall nvi)))
(lambda () nvy1))
(lambda () nvy))))
(let ((nvv3 (nvappend (funcall (funcall (funcall (funcall (nvaneris_23_v1_when_quorum "UNION" (nvaneris_cmd_deq "INT" (funcall nvOp) (nvint-deq) (funcall nveq_Op)) 2 (funcall nvflrs) (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom)))) (funcall nvf))
(lambda () (make-pair :fst nvn :snd 0)))
(lambda () (funcall nvi)))
(lambda () nvy1))
(lambda () nvy)) (make-axiom))))
(let ((dec nvx))
(if (inl-p dec)
(let ((nvv4 (nvappend (funcall (funcall (nvaneris_23_v1_vote_broadcast "UNION" (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom)))) (funcall nvf))
(lambda () (funcall nvlocs)))
(lambda () (make-pair :fst (make-pair :fst (make-pair :fst nvn :snd 0) :snd nvc) :snd (funcall nvi)))) nvv3)))
(make-pair :fst (let ((dec (nvnull nvv3)))
(if (inl-p dec)
(funcall (funcall nvmk-hdf)
(lambda () (make-pair :fst (make-inr :val (make-axiom)) :snd nvv2)))
(if (inr-p dec)
(make-inr :val (make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))) :snd nvv4))
(if (inr-p dec)
(make-pair :fst (let ((dec (nvnull nvv3)))
(if (inl-p dec)
(funcall (funcall nvmk-hdf)
(lambda () (make-pair :fst (make-inr :val (make-axiom)) :snd nvv2)))
(if (inr-p dec)
(make-inr :val (make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))) :snd nvv3)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))
(if (inr-p dec)
(let ((nvv2 nvy))
(let ((dec nvx))
(if (inl-p dec)
(let ((nvv4 (nvappend (funcall (funcall (nvaneris_23_v1_vote_broadcast "UNION" (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom)))) (funcall nvf))
(lambda () (funcall nvlocs)))
(lambda () (make-pair :fst (make-pair :fst (make-pair :fst nvn :snd 0) :snd nvc) :snd (funcall nvi)))) (make-axiom))))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () (make-pair :fst (make-inr :val (make-axiom)) :snd nvv2))) :snd nvv4))
(if (inr-p dec)
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () (make-pair :fst (make-inr :val (make-axiom)) :snd nvv2))) :snd (make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))))))))
(lambda () (make-pair :fst (make-inl :val (make-axiom)) :snd (make-pair :fst (make-axiom) :snd (make-axiom))))) (nvhdf-once (fix (lambda (nvmk-hdf)
(make-inl :val (lambda (nva)
(let ((nvv (nvbag-union (nvbag-map (lambda (nvx)
(funcall (funcall (funcall (nvaneris_23_v1_decision "UNION" (funcall nvreps) (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom)))) (funcall nvf))
(lambda () nvn))
(lambda () (funcall nvi)))
(lambda () (funcall nvx)))) (let ((pair (funcall nva)))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_23_v1" :snd (make-pair :fst "decided" :snd (make-axiom))))))
(if (inl-p dec)
(make-pair :fst nvy :snd (make-axiom))
(if (inr-p dec)
(make-axiom)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))))))
(make-pair :fst (funcall nvmk-hdf) :snd nvv)))))))) (funcall (fix (lambda (nvmk-hdf)
(lambda (nvs0)
(let ((dec (nvhdf-halted (let ((pair (funcall nvs0)))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(declare (ignore nvy))
nvx)))))
(if (inl-p dec)
(nvhdf-halt)
(if (inr-p dec)
(nvhdf-run (lambda (nva)
(let ((pair (funcall nvs0)))
(let ((nvX (pair-fst pair))
(nvY (pair-snd pair)))
(let ((pair (nvhdf-ap nvX (funcall nva))))
(let ((nvX_ (pair-fst pair))
(nvb (pair-snd pair)))
(let ((pair (nvhdf-ap nvY (funcall nva))))
(let ((nvY_ (pair-fst pair))
(nvc (pair-snd pair)))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () (make-pair :fst (let ((dec (nvbag-null nvc)))
(if (inl-p dec)
nvX_
(if (inr-p dec)
(nvhdf-halt)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))) :snd nvY_))) :snd nvb)))))))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))
(lambda () (make-pair :fst (nvhdf-bind (nvhdf-compose2 (nvhdf-compose1 (funcall (funcall (nvaneris_23_v1_when_new_round "UNION")
(lambda () nvn))
(lambda () (funcall nvi))) (nvhdf-parallel (fix (lambda (nvmk-hdf)
(make-inl :val (lambda (nva)
(make-pair :fst (funcall nvmk-hdf) :snd (let ((pair (funcall nva)))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_23_v1" :snd (make-pair :fst "retry" :snd (make-axiom))))))
(if (inl-p dec)
(make-pair :fst nvy :snd (make-axiom))
(if (inr-p dec)
(make-axiom)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))))))) (fix (lambda (nvmk-hdf)
(make-inl :val (lambda (nva)
(let ((nvv (nvbag-union (nvbag-map (lambda (nvx)
(funcall (funcall (nvaneris_23_v1_vote2retry "UNION")
(lambda () (funcall nvi)))
(lambda () (funcall nvx)))) (let ((pair (funcall nva)))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_23_v1" :snd (make-pair :fst "vote" :snd (make-axiom))))))
(if (inl-p dec)
(make-pair :fst nvy :snd (make-axiom))
(if (inr-p dec)
(make-axiom)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))))))
(make-pair :fst (funcall nvmk-hdf) :snd nvv)))))))) (nvhdf-memory (nvhdf-compose1 (funcall (funcall (nvaneris_23_v1_update_round "UNION")
(lambda () nvn))
(lambda () (funcall nvi))) (nvhdf-parallel (fix (lambda (nvmk-hdf)
(make-inl :val (lambda (nva)
(make-pair :fst (funcall nvmk-hdf) :snd (let ((pair (funcall nva)))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_23_v1" :snd (make-pair :fst "retry" :snd (make-axiom))))))
(if (inl-p dec)
(make-pair :fst nvy :snd (make-axiom))
(if (inr-p dec)
(make-axiom)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))))))) (fix (lambda (nvmk-hdf)
(make-inl :val (lambda (nva)
(let ((nvv (nvbag-union (nvbag-map (lambda (nvx)
(funcall (funcall (nvaneris_23_v1_vote2retry "UNION")
(lambda () (funcall nvi)))
(lambda () (funcall nvx)))) (let ((pair (funcall nva)))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_23_v1" :snd (make-pair :fst "vote" :snd (make-axiom))))))
(if (inl-p dec)
(make-pair :fst nvy :snd (make-axiom))
(if (inr-p dec)
(make-axiom)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))))))
(make-pair :fst (funcall nvmk-hdf) :snd nvv)))))))) (make-pair :fst 0 :snd (make-axiom)))) (lambda (nvx)
(let ((pair (funcall nvx)))
(let ((nvni (pair-fst pair))
(nvc (pair-snd pair)))
(funcall (fix (lambda (nvmk-hdf)
(lambda (nvs)
(make-inl :val (lambda (nvv)
(let ((pair (funcall nvs)))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((pair (funcall nvv)))
(let ((nvx1 (pair-fst pair))
(nvy1 (pair-snd pair)))
(let ((dec (nvname_eq nvx1 (make-pair :fst "aneris_23_v1" :snd (make-pair :fst "vote" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nvv2 (funcall (funcall (funcall (funcall (nvaneris_23_v1_add_to_quorum "UNION")
(lambda () nvni))
(lambda () (funcall nvi)))
(lambda () nvy1))
(lambda () nvy))))
(let ((nvv3 (nvappend (funcall (funcall (funcall (funcall (nvaneris_23_v1_when_quorum "UNION" (nvaneris_cmd_deq "INT" (funcall nvOp) (nvint-deq) (funcall nveq_Op)) 2 (funcall nvflrs) (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom)))) (funcall nvf))
(lambda () nvni))
(lambda () (funcall nvi)))
(lambda () nvy1))
(lambda () nvy)) (make-axiom))))
(let ((dec nvx))
(if (inl-p dec)
(let ((nvv4 (nvappend (funcall (funcall (nvaneris_23_v1_vote_broadcast "UNION" (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom)))) (funcall nvf))
(lambda () (funcall nvlocs)))
(lambda () (make-pair :fst (make-pair :fst nvni :snd nvc) :snd (funcall nvi)))) nvv3)))
(make-pair :fst (let ((dec (nvnull nvv3)))
(if (inl-p dec)
(funcall (funcall nvmk-hdf)
(lambda () (make-pair :fst (make-inr :val (make-axiom)) :snd nvv2)))
(if (inr-p dec)
(make-inr :val (make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))) :snd nvv4))
(if (inr-p dec)
(make-pair :fst (let ((dec (nvnull nvv3)))
(if (inl-p dec)
(funcall (funcall nvmk-hdf)
(lambda () (make-pair :fst (make-inr :val (make-axiom)) :snd nvv2)))
(if (inr-p dec)
(make-inr :val (make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))) :snd nvv3)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))
(if (inr-p dec)
(let ((nvv2 nvy))
(let ((dec nvx))
(if (inl-p dec)
(let ((nvv4 (nvappend (funcall (funcall (nvaneris_23_v1_vote_broadcast "UNION" (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom)))) (funcall nvf))
(lambda () (funcall nvlocs)))
(lambda () (make-pair :fst (make-pair :fst nvni :snd nvc) :snd (funcall nvi)))) (make-axiom))))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () (make-pair :fst (make-inr :val (make-axiom)) :snd nvv2))) :snd nvv4))
(if (inr-p dec)
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () (make-pair :fst (make-inr :val (make-axiom)) :snd nvv2))) :snd (make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))))))))
(lambda () (make-pair :fst (make-inl :val (make-axiom)) :snd (make-pair :fst (make-axiom) :snd (make-axiom))))))))) :snd (nvhdf-once (fix (lambda (nvmk-hdf)
(make-inl :val (lambda (nva)
(let ((nvv (nvbag-union (nvbag-map (lambda (nvx)
(funcall (funcall (funcall (nvaneris_23_v1_decision "UNION" (funcall nvreps) (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom)))) (funcall nvf))
(lambda () nvn))
(lambda () (funcall nvi)))
(lambda () (funcall nvx)))) (let ((pair (funcall nva)))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_23_v1" :snd (make-pair :fst "decided" :snd (make-axiom))))))
(if (inl-p dec)
(make-pair :fst nvy :snd (make-axiom))
(if (inr-p dec)
(make-axiom)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))))))
(make-pair :fst (funcall nvmk-hdf) :snd nvv)))))))))))))))
(if (inr-p dec)
(nvhdf-halt)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))) (let ((dec (nvdeq-member (lambda (nva)
(lambda (nvb)
(if (string= (funcall nva) (funcall nvb))
(make-inl :val (make-axiom))
(make-inr :val (make-axiom))))) (funcall nvi) (funcall nvreps))))
(if (inl-p dec)
(funcall (fix (lambda (nvmk-hdf)
(lambda (nvs)
(make-inl :val (lambda (nva)
(let ((pair (funcall nva)))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx (make-pair :fst "swap" :snd (make-axiom)))))
(if (inl-p dec)
(let ((nvv5 (nvmap (funcall (funcall (funcall (nvaneris_v2_out_tr (funcall nvOp) (make-pair :fst "bcast" :snd (make-axiom)) (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (make-pair :fst "response" :snd (make-axiom)) (make-pair :fst "swap" :snd (make-axiom)) (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom)))) (funcall nvf))
(lambda () (nvaneris_v2_propose_inl (funcall nvOp) (make-pair :fst "bcast" :snd (make-axiom)) (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (funcall nvldrs) (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (make-pair :fst "response" :snd (make-axiom)) (make-pair :fst "swap" :snd (make-axiom)) (funcall nvlocs) (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom)))) (funcall nvf))))
(lambda () (funcall nvi)))
(lambda () nvy)) (funcall nvs))))
(let ((dec (nvbag-null nvv5)))
(if (inl-p dec)
(let ((nvv6 (funcall nvs)))
(let ((nvv7 (nvbag-union (nvbag-map (lambda (nvx)
(let ((pair (funcall nvx)))
(let ((nvx_ (pair-fst pair))
(nvy (pair-snd pair)))
(declare (ignore nvx_))
nvy))) nvv6))))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv6)) :snd nvv7)))
(if (inr-p dec)
(let ((nvv7 (nvbag-union (nvbag-map (lambda (nvx)
(let ((pair (funcall nvx)))
(let ((nvx_ (pair-fst pair))
(nvy (pair-snd pair)))
(declare (ignore nvx_))
nvy))) nvv5))))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv5)) :snd nvv7))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(if (inr-p dec)
(let ((dec (nvname_eq nvx (make-pair :fst "bcast" :snd (make-axiom)))))
(if (inl-p dec)
(let ((nvv5 (nvmap (funcall (funcall (funcall (nvaneris_v2_out_tr (funcall nvOp) (make-pair :fst "bcast" :snd (make-axiom)) (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (make-pair :fst "response" :snd (make-axiom)) (make-pair :fst "swap" :snd (make-axiom)) (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom)))) (funcall nvf))
(lambda () (nvaneris_v2_propose_inr (funcall nvOp) (make-pair :fst "bcast" :snd (make-axiom)) (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (funcall nvldrs) (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (make-pair :fst "response" :snd (make-axiom)) (make-pair :fst "swap" :snd (make-axiom)) (funcall nvlocs) (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom)))) (funcall nvf))))
(lambda () (funcall nvi)))
(lambda () nvy)) (funcall nvs))))
(let ((dec (nvbag-null nvv5)))
(if (inl-p dec)
(let ((nvv6 (funcall nvs)))
(let ((nvv7 (nvbag-union (nvbag-map (lambda (nvx)
(let ((pair (funcall nvx)))
(let ((nvx_ (pair-fst pair))
(nvy (pair-snd pair)))
(declare (ignore nvx_))
nvy))) nvv6))))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv6)) :snd nvv7)))
(if (inr-p dec)
(let ((nvv7 (nvbag-union (nvbag-map (lambda (nvx)
(let ((pair (funcall nvx)))
(let ((nvx_ (pair-fst pair))
(nvy (pair-snd pair)))
(declare (ignore nvx_))
nvy))) nvv5))))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv5)) :snd nvv7))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(if (inr-p dec)
(let ((dec (nvname_eq nvx (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nvv5 (nvmap (funcall (funcall (funcall (nvaneris_v2_out_tr (funcall nvOp) (make-pair :fst "bcast" :snd (make-axiom)) (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (make-pair :fst "response" :snd (make-axiom)) (make-pair :fst "swap" :snd (make-axiom)) (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom)))) (funcall nvf))
(lambda () (nvaneris_v2_on_decision (funcall nvOp) (make-pair :fst "bcast" :snd (make-axiom)) (funcall nvclients) (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (funcall nvldrs) (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (make-pair :fst "response" :snd (make-axiom)) (make-pair :fst "swap" :snd (make-axiom)) (funcall nvlocs) (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom)))) (funcall nvf))))
(lambda () (funcall nvi)))
(lambda () nvy)) (funcall nvs))))
(let ((dec (nvbag-null nvv5)))
(if (inl-p dec)
(let ((nvv6 (funcall nvs)))
(let ((nvv7 (nvbag-union (nvbag-map (lambda (nvx)
(let ((pair (funcall nvx)))
(let ((nvx_ (pair-fst pair))
(nvy (pair-snd pair)))
(declare (ignore nvx_))
nvy))) nvv6))))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv6)) :snd nvv7)))
(if (inr-p dec)
(let ((nvv7 (nvbag-union (nvbag-map (lambda (nvx)
(let ((pair (funcall nvx)))
(let ((nvx_ (pair-fst pair))
(nvy (pair-snd pair)))
(declare (ignore nvx_))
nvy))) nvv5))))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv5)) :snd nvv7))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(if (inr-p dec)
(let ((nvv6 (funcall nvs)))
(let ((nvv7 (nvbag-union (nvbag-map (lambda (nvx)
(let ((pair (funcall nvx)))
(let ((nvx_ (pair-fst pair))
(nvy (pair-snd pair)))
(declare (ignore nvx_))
nvy))) nvv6))))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvv6)) :snd nvv7)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))))))
(lambda () (make-pair :fst (make-pair :fst (make-pair :fst 1 :snd (make-pair :fst (make-inr :val (make-axiom)) :snd (make-pair :fst (make-axiom) :snd (make-pair :fst (make-axiom) :snd (make-pair :fst (make-axiom) :snd (make-pair :fst "2/3" :snd (make-axiom))))))) :snd (make-axiom)) :snd (make-axiom))))
(if (inr-p dec)
(nvhdf-halt)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))))))))))))))

