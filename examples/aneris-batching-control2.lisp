(defun nvlist (nvT)
(declare (ignore nvT))
"REC")

(defun nvbtrue ()
(make-inl :val (make-axiom)))

(defun nvbfalse ()
(make-inr :val (make-axiom)))

(defun nveq_int (nvi nvj)
(if (= nvi nvj)
(nvbtrue)
(nvbfalse)))

(defun nvint-deq ()
(lambda (nva)
(lambda (nvb)
(nveq_int (funcall nva) (funcall nvb)))))

(defun nveq_atom (nvx nvy)
(if (string= nvx nvy)
(nvbtrue)
(nvbfalse)))

(defun nvatom-deq ()
(lambda (nva)
(lambda (nvb)
(nveq_atom (funcall nva) (funcall nvb)))))

(defun nvband (nvp nvq)
(if (inl-p nvp)
nvq
(nvbfalse)))

(defun nvnull (nvas)
(if (pair-p nvas)
(nvbfalse)
(if (axiom-p nvas)
(nvbtrue)
(error "bottom"))))

(defun nvlist-deq (nveq)
(lambda (nvas)
(lambda (nvbs)
(funcall (funcall (fix "nvlist_ind" (lambda (nvlist_ind)
(lambda (nvL)
(let ((nvv (funcall nvL)))
(if (pair-p nvv)
(let ((pair nvv))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(lambda (nvL)
(funcall (fix "nvlist_ind_" (lambda (nvlist_ind_)
(declare (ignore nvlist_ind_))
(lambda (nvL)
(let ((nvv (funcall nvL)))
(if (pair-p nvv)
(let ((pair nvv))
(let ((nvh_ (pair-fst pair))
(nvt_ (pair-snd pair)))
(nvband (funcall (funcall nveq
(lambda () nvh))
(lambda () nvh_)) (funcall (funcall (funcall nvlist_ind)
(lambda () nvt))
(lambda () nvt_)))))
(if (axiom-p nvv)
(nvbfalse)
(error "bottom")))))))
(lambda () (funcall nvL))))))
(if (axiom-p nvv)
(lambda (nvL)
(nvnull (funcall nvL)))
(error "bottom")))))))
(lambda () (funcall nvas)))
(lambda () (funcall nvbs))))))

(defun nvpi1 (nvt)
(let ((pair nvt))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(declare (ignore nvy))
nvx)))

(defun nvpi2 (nvt)
(let ((pair nvt))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(declare (ignore nvx))
nvy)))

(defun nvproddeq (nva nvb)
(lambda (nvp)
(lambda (nvq)
(nvband (funcall (funcall nva
(lambda () (nvpi1 (funcall nvp))))
(lambda () (nvpi1 (funcall nvq)))) (funcall (funcall nvb
(lambda () (nvpi2 (funcall nvp))))
(lambda () (nvpi2 (funcall nvq))))))))

(defun nvproduct-deq (nvAA nvBB nva nvb)
(declare (ignore nvAA))
(declare (ignore nvBB))
(nvproddeq nva nvb))

(defun nvsumdeq (nva nvb)
(lambda (nvp)
(lambda (nvq)
(let ((dec (funcall nvp)))
(if (inl-p dec)
(let ((nvpa (inl-val dec)))
(let ((dec (funcall nvq)))
(if (inl-p dec)
(let ((nvqa (inl-val dec)))
(funcall (funcall nva
(lambda () nvpa))
(lambda () nvqa)))
(if (inr-p dec)
(nvbfalse)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(if (inr-p dec)
(let ((nvpb (inr-val dec)))
(let ((dec (funcall nvq)))
(if (inl-p dec)
(nvbfalse)
(if (inr-p dec)
(let ((nvqb (inr-val dec)))
(funcall (funcall nvb
(lambda () nvpb))
(lambda () nvqb)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))

(defun nvunion-deq (nvAA nvBB nva nvb)
(declare (ignore nvAA))
(declare (ignore nvBB))
(nvsumdeq nva nvb))

(defun nvaneris_control_tagged_cmd_deq (nvOp nveq_Op)
(nvunion-deq "PRODUCT" "PRODUCT" (nvproduct-deq "INT" (nvlist "ATOM") (nvint-deq) (nvlist-deq (nvatom-deq))) (nvproduct-deq "INT" (nvlist nvOp) (nvint-deq) (nvlist-deq nveq_Op))))

(defun nvlt_int (nvi nvj)
(if (< nvi nvj)
(nvbtrue)
(nvbfalse)))

(defun nvbor (nvp nvq)
(if (inl-p nvp)
(nvbtrue)
nvq))

(defun nvreduce (nvf nvk nvas)
(funcall (fix "nvlist_ind" (lambda (nvlist_ind)
(lambda (nvL)
(let ((nvv (funcall nvL)))
(if (pair-p nvv)
(let ((pair nvv))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(funcall (funcall nvf
(lambda () nvh))
(lambda () (funcall (funcall nvlist_ind)
(lambda () nvt))))))
(if (axiom-p nvv)
nvk
(error "bottom")))))))
(lambda () nvas)))

(defun nvdeq-member (nveq nvx nvL)
(nvreduce (lambda (nva)
(lambda (nvb)
(nvbor (funcall (funcall nveq
(lambda () (funcall nva)))
(lambda () nvx)) (funcall nvb)))) (nvbfalse) nvL))

(defun nvsingle-bag (nvx)
(make-pair :fst nvx :snd (make-axiom)))

(defun nvrsc4_when_new_proposal (nvCmd)
(declare (ignore nvCmd))
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvzzc)
(lambda (nvz)
(let ((pair (funcall nvzzc)))
(let ((nvn (pair-fst pair))
(nvc (pair-snd pair)))
(let ((pair (funcall nvz)))
(let ((nvmax (pair-fst pair))
(nvmissing (pair-snd pair)))
(if (inl-p (nvbor (nvlt_int nvmax nvn) (nvdeq-member (nvint-deq) nvn nvmissing)))
(nvsingle-bag (make-pair :fst nvn :snd nvc))
(make-axiom))))))))))

(defun nvhdf-halt ()
(make-inr :val (make-axiom)))

(defun nvmsg-header (nvm)
(nvpi1 nvm))

(defun nvname-deq ()
(nvlist-deq (nvatom-deq)))

(defun nvname_eq (nvx nvy)
(funcall (funcall (nvname-deq)
(lambda () nvx))
(lambda () nvy)))

(defun nvmsg-body (nvmsg)
(nvpi2 nvmsg))

(defun nvcond-msg-body (nvhdr nvmsg)
(if (inl-p (nvname_eq (nvmsg-header nvmsg) nvhdr))
(nvsingle-bag (nvmsg-body nvmsg))
(make-axiom)))

(defun nvhdf-run (nvP)
(make-inl :val nvP))

(defun nvbase-class-program (nvhdr)
(lambda (nvi)
(declare (ignore nvi))
(funcall (fix "nvmk-hdf" (lambda (nvmk-hdf)
(lambda (nvs0)
(if (inl-p (nvbfalse))
(nvhdf-halt)
(nvhdf-run (lambda (nvm)
(let ((pair (make-pair :fst (funcall nvs0) :snd (nvcond-msg-body nvhdr (funcall nvm)))))
(let ((nvs1 (pair-fst pair))
(nvb (pair-snd pair)))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvs1)) :snd nvb)))))))))
(lambda () (make-axiom)))))

(defun nvrsc4_propose_base-program (nvCmd nvnotify nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvnotify))
(declare (ignore nvmf))
(nvbase-class-program nvpropose))

(defun nvrsc4_vote2prop (nvCmd)
(declare (ignore nvCmd))
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvz (pair-fst pair))
(nvloc_ (pair-snd pair)))
(declare (ignore nvloc_))
(let ((pair nvz))
(let ((nvz (pair-fst pair))
(nvc (pair-snd pair)))
(let ((pair nvz))
(let ((nvn (pair-fst pair))
(nvi (pair-snd pair)))
(declare (ignore nvi))
(nvsingle-bag (make-pair :fst nvn :snd nvc)))))))))))

(defun nvrsc4_vote_base-program (nvCmd nvnotify nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvnotify))
(declare (ignore nvpropose))
(declare (ignore nvmf))
(nvbase-class-program (make-pair :fst "rsc4" :snd (make-pair :fst "vote" :snd (make-axiom)))))

(defun nvisr (nvx)
(let ((dec nvx))
(if (inl-p dec)
(nvbfalse)
(if (inr-p dec)
(nvbtrue)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))

(defun nvhdf-halted (nvP)
(nvisr nvP))

(defun nvhdf-ap (nvX nva)
(let ((dec nvX))
(if (inl-p dec)
(let ((nvP (inl-val dec)))
(funcall nvP
(lambda () nva)))
(if (inr-p dec)
(make-pair :fst (make-inr :val (make-axiom)) :snd (make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))

(defun nvmap (nvf nvas)
(funcall (fix "nvlist_ind" (lambda (nvlist_ind)
(lambda (nvL)
(let ((nvv (funcall nvL)))
(if (pair-p nvv)
(let ((pair nvv))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(make-pair :fst (funcall nvf
(lambda () nvh)) :snd (funcall (funcall nvlist_ind)
(lambda () nvt)))))
(if (axiom-p nvv)
(make-axiom)
(error "bottom")))))))
(lambda () nvas)))

(defun nvbag-map (nvf nvbs)
(nvmap nvf nvbs))

(defun nvappend (nvas nvbs)
(funcall (fix "nvlist_ind" (lambda (nvlist_ind)
(lambda (nvL)
(let ((nvv (funcall nvL)))
(if (pair-p nvv)
(let ((pair nvv))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(make-pair :fst nvh :snd (funcall (funcall nvlist_ind)
(lambda () nvt)))))
(if (axiom-p nvv)
nvbs
(error "bottom")))))))
(lambda () nvas)))

(defun nvconcat (nvll)
(nvreduce (lambda (nvl)
(lambda (nvl_)
(nvappend (funcall nvl) (funcall nvl_)))) (make-axiom) nvll))

(defun nvbag-union (nvbbs)
(nvconcat nvbbs))

(defun nvhdf-compose0 (nvf nvX)
(funcall (fix "nvmk-hdf" (lambda (nvmk-hdf)
(lambda (nvs0)
(if (inl-p (nvhdf-halted (funcall nvs0)))
(nvhdf-halt)
(nvhdf-run (lambda (nvm)
(let ((pair (let ((pair (nvhdf-ap (funcall nvs0) (funcall nvm))))
(let ((nvX_ (pair-fst pair))
(nvbs (pair-snd pair)))
(let ((nvout (nvbag-union (nvbag-map (lambda (nvx)
(funcall nvf
(lambda () (funcall nvx)))) nvbs))))
(make-pair :fst nvX_ :snd nvout))))))
(let ((nvs1 (pair-fst pair))
(nvb (pair-snd pair)))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvs1)) :snd nvb)))))))))
(lambda () nvX)))

(defun nveclass0-program (nvf nvpr)
(lambda (nvi)
(nvhdf-compose0 (funcall nvf
(lambda () (funcall nvi))) (funcall nvpr
(lambda () (funcall nvi))))))

(defun nvbag-append (nvas nvbs)
(nvappend nvas nvbs))

(defun nvhdf-parallel (nvX nvY)
(funcall (fix "nvmk-hdf" (lambda (nvmk-hdf)
(lambda (nvs0)
(if (inl-p (let ((pair (funcall nvs0)))
(let ((nvX (pair-fst pair))
(nvY (pair-snd pair)))
(nvband (nvhdf-halted nvX) (nvhdf-halted nvY)))))
(nvhdf-halt)
(nvhdf-run (lambda (nvm)
(let ((pair (let ((pair (funcall nvs0)))
(let ((nvX (pair-fst pair))
(nvY (pair-snd pair)))
(let ((pair (nvhdf-ap nvX (funcall nvm))))
(let ((nvX_ (pair-fst pair))
(nvxs (pair-snd pair)))
(let ((pair (nvhdf-ap nvY (funcall nvm))))
(let ((nvY_ (pair-fst pair))
(nvys (pair-snd pair)))
(let ((nvout (nvbag-append nvxs nvys)))
(make-pair :fst (make-pair :fst nvX_ :snd nvY_) :snd nvout))))))))))
(let ((nvs1 (pair-fst pair))
(nvb (pair-snd pair)))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvs1)) :snd nvb)))))))))
(lambda () (make-pair :fst nvX :snd nvY))))

(defun nvparallel-class-program (nvX nvY)
(lambda (nvi)
(nvhdf-parallel (funcall nvX
(lambda () (funcall nvi))) (funcall nvY
(lambda () (funcall nvi))))))

(defun nvrsc4_Proposal-program (nvCmd nvnotify nvpropose nvmf)
(nvparallel-class-program (nvrsc4_propose_base-program nvCmd nvnotify nvpropose nvmf) (nveclass0-program (nvrsc4_vote2prop nvCmd) (nvrsc4_vote_base-program nvCmd nvnotify nvpropose nvmf))))

(defun nvhdf-compose1 (nvf nvX)
(funcall (fix "nvmk-hdf" (lambda (nvmk-hdf)
(lambda (nvs0)
(if (inl-p (nvhdf-halted (funcall nvs0)))
(nvhdf-halt)
(nvhdf-run (lambda (nvm)
(let ((pair (let ((pair (nvhdf-ap (funcall nvs0) (funcall nvm))))
(let ((nvX_ (pair-fst pair))
(nvbs (pair-snd pair)))
(let ((nvout (nvbag-map nvf nvbs)))
(make-pair :fst nvX_ :snd nvout))))))
(let ((nvs1 (pair-fst pair))
(nvb (pair-snd pair)))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvs1)) :snd nvb)))))))))
(lambda () nvX)))

(defun nveclass1-program (nvf nvpr)
(lambda (nvi)
(nvhdf-compose1 (funcall nvf
(lambda () (funcall nvi))) (funcall nvpr
(lambda () (funcall nvi))))))

(defun nvrsc4_init ()
(lambda (nvx)
(lambda (nvloc)
(declare (ignore nvloc))
(funcall nvx))))

(defun nvfrom-upto (nvn nvm)
  (funcall (fix (format nil "nvfrom-upto(~A,~A)" nvn nvm)
		(lambda (nvfrom-upto)
		  (lambda (nvn)
		    (if (inl-p (nvlt_int (funcall nvn) nvm))
			(make-pair :fst (funcall nvn)
				   :snd (let ((nvn_ (+ (funcall nvn) 1)))
					  (funcall (funcall nvfrom-upto)
						   (lambda () nvn_))))
			(make-axiom)))))
	   (lambda () nvn)))

(defun nvbnot (nvb)
(if (inl-p nvb)
(nvbfalse)
(nvbtrue)))

(defun nvfilter (nvP nvl)
(nvreduce (lambda (nva)
(lambda (nvv)
(if (inl-p (funcall nvP
(lambda () (funcall nva))))
(make-pair :fst (funcall nva) :snd (funcall nvv))
(funcall nvv)))) (make-axiom) nvl))

(defun nvlist-diff (nveq nvas nvbs)
(nvfilter (lambda (nva)
(nvbnot (nvdeq-member nveq (funcall nva) nvbs))) nvas))

(defun nvrsc4_onnewpropose (nvCmd)
(declare (ignore nvCmd))
(lambda (nvzza)
(lambda (nvz)
(let ((pair (funcall nvzza)))
(let ((nvn (pair-fst pair))
(nvc (pair-snd pair)))
(declare (ignore nvc))
(let ((pair (funcall nvz)))
(let ((nvmax (pair-fst pair))
(nvmissing (pair-snd pair)))
(if (inl-p (nvlt_int nvmax nvn))
(make-pair :fst nvn :snd (nvappend nvmissing (nvfrom-upto (+ nvmax 1) nvn)))
(make-pair :fst nvmax :snd (nvlist-diff (nvint-deq) nvmissing (make-pair :fst nvn :snd (make-axiom))))))))))))

(defun nvrsc4_update_replica (nvCmd)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvzzb)
(lambda (nvz)
(let ((pair (funcall nvzzb)))
(let ((nvn (pair-fst pair))
(nvc (pair-snd pair)))
(let ((pair (funcall nvz)))
(let ((nvmax (pair-fst pair))
(nvmissing (pair-snd pair)))
(if (inl-p (nvbor (nvlt_int nvmax nvn) (nvdeq-member (nvint-deq) nvn nvmissing)))
(funcall (funcall (nvrsc4_onnewpropose nvCmd)
(lambda () (make-pair :fst nvn :snd nvc)))
(lambda () (make-pair :fst nvmax :snd nvmissing)))
(make-pair :fst nvmax :snd nvmissing))))))))))

(defun nvbag-null (nvbs)
(nvnull nvbs))

(defun nvhdf-memory (nvX nvbs)
(funcall (fix "nvmk-hdf" (lambda (nvmk-hdf)
(lambda (nvs0)
(if (inl-p (nvbfalse))
(nvhdf-halt)
(nvhdf-run (lambda (nvm)
(let ((pair (let ((pair (funcall nvs0)))
(let ((nvX (pair-fst pair))
(nvs (pair-snd pair)))
(let ((pair (nvhdf-ap nvX (funcall nvm))))
(let ((nvX_ (pair-fst pair))
(nvfs (pair-snd pair)))
(let ((nvb (nvbag-union (nvbag-map (lambda (nvx)
(nvbag-map (funcall nvx) nvs)) nvfs))))
(let ((nvs_ (if (inl-p (nvbag-null nvb))
nvs
nvb)))
(make-pair :fst (make-pair :fst nvX_ :snd nvs_) :snd nvs)))))))))
(let ((nvs1 (pair-fst pair))
(nvb (pair-snd pair)))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvs1)) :snd nvb)))))))))
(lambda () (make-pair :fst nvX :snd nvbs))))

(defun nvloop-class-memory-program (nvpr nvinit)
(lambda (nvi)
(nvhdf-memory (funcall nvpr
(lambda () (funcall nvi))) (funcall nvinit
(lambda () (funcall nvi))))))

(defun nvmemory-class1-program (nvinit nvtr nvpr)
(nvloop-class-memory-program (nveclass1-program nvtr nvpr) (lambda (nvloc)
(nvsingle-bag (funcall nvinit
(lambda () (funcall nvloc)))))))

(defun nvrsc4_ReplicaState-program (nvCmd nvnotify nvpropose nvmf)
(nvmemory-class1-program (funcall (nvrsc4_init)
(lambda () (make-pair :fst 0 :snd (make-axiom)))) (nvrsc4_update_replica nvCmd) (nvrsc4_Proposal-program nvCmd nvnotify nvpropose nvmf)))

(defun nvhdf-compose2 (nvX nvY)
(funcall (fix "nvmk-hdf" (lambda (nvmk-hdf)
(lambda (nvs0)
(if (inl-p (let ((pair (funcall nvs0)))
(let ((nvX (pair-fst pair))
(nvY (pair-snd pair)))
(nvbor (nvhdf-halted nvX) (nvhdf-halted nvY)))))
(nvhdf-halt)
(nvhdf-run (lambda (nvm)
(let ((pair (let ((pair (funcall nvs0)))
(let ((nvX (pair-fst pair))
(nvY (pair-snd pair)))
(let ((pair (nvhdf-ap nvX (funcall nvm))))
(let ((nvX_ (pair-fst pair))
(nvfs (pair-snd pair)))
(let ((pair (nvhdf-ap nvY (funcall nvm))))
(let ((nvY_ (pair-fst pair))
(nvbs (pair-snd pair)))
(let ((nvout (nvbag-union (nvbag-map (lambda (nvx)
(nvbag-union (nvbag-map (lambda (nvx_)
(funcall (funcall nvx)
(lambda () (funcall nvx_)))) nvbs))) nvfs))))
(make-pair :fst (make-pair :fst nvX_ :snd nvY_) :snd nvout))))))))))
(let ((nvs1 (pair-fst pair))
(nvb (pair-snd pair)))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvs1)) :snd nvb)))))))))
(lambda () (make-pair :fst nvX :snd nvY))))

(defun nveclass2-program (nvXpr nvYpr)
(lambda (nvi)
(nvhdf-compose2 (funcall nvXpr
(lambda () (funcall nvi))) (funcall nvYpr
(lambda () (funcall nvi))))))

(defun nvrsc4_NewVoters-program (nvCmd nvnotify nvpropose nvmf)
(nveclass2-program (nveclass1-program (nvrsc4_when_new_proposal nvCmd) (nvrsc4_Proposal-program nvCmd nvnotify nvpropose nvmf)) (nvrsc4_ReplicaState-program nvCmd nvnotify nvpropose nvmf)))

(defun nvmake-Msg (nvhdr nvval)
(make-pair :fst nvhdr :snd nvval))

(defun nvmake-msg-interface (nvi nvl nvm)
(make-pair :fst nvi :snd (make-pair :fst nvl :snd nvm)))

(defun nvmk-msg-interface (nvl nvm)
(nvmake-msg-interface 0 nvl nvm))

(defun nvrsc4_vote_broadcast (nvCmd nvnotify nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvnotify))
(declare (ignore nvpropose))
(declare (ignore nvmf))
(lambda (nvlocs)
(lambda (nvz)
(nvbag-map (lambda (nvl)
(nvmk-msg-interface (funcall nvl) (nvmake-Msg (make-pair :fst "rsc4" :snd (make-pair :fst "vote" :snd (make-axiom))) (funcall nvz)))) (funcall nvlocs)))))

(defun nvhdf-return (nvx)
(nvhdf-run (lambda (nvm)
(declare (ignore nvm))
(make-pair :fst (nvhdf-halt) :snd nvx))))

(defun nvreturn-loc-bag-class-program (nvx)
(lambda (nvi)
(nvhdf-return (funcall nvx
(lambda () (funcall nvi))))))

(defun nvrsc4_newvote (nvCmd)
(declare (ignore nvCmd))
(lambda (nvni)
(lambda (nvzv)
(lambda (nvz)
(let ((pair (funcall nvzv)))
(let ((nvzw (pair-fst pair))
(nvsender (pair-snd pair)))
(let ((pair nvzw))
(let ((nvni_ (pair-fst pair))
(nvc (pair-snd pair)))
(declare (ignore nvc))
(let ((pair (funcall nvz)))
(let ((nvcmds (pair-fst pair))
(nvz (pair-snd pair)))
(declare (ignore nvcmds))
(nvband (funcall (funcall (nvproduct-deq "INT" "INT" (nvint-deq) (nvint-deq))
(lambda () (funcall nvni)))
(lambda () nvni_)) (nvbnot (nvdeq-member (lambda (nva)
(lambda (nvb)
(if (string= (funcall nva) (funcall nvb))
(make-inl :val (make-axiom))
(make-inr :val (make-axiom))))) nvsender nvz)))))))))))))

(defun nvlength (nvas)
(funcall (fix "nvlist_ind" (lambda (nvlist_ind)
(lambda (nvL)
(let ((nvv (funcall nvL)))
(if (pair-p nvv)
(let ((pair nvv))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(declare (ignore nvh))
(+ (funcall (funcall nvlist_ind)
(lambda () nvt)) 1)))
(if (axiom-p nvv)
0
(error "bottom")))))))
(lambda () nvas)))

(defun nvposs-maj (nveq nvL nvx)
(funcall (funcall (fix "nvlist_accum" (lambda (nvlist_accum)
(lambda (nvy)
(lambda (nvL)
(let ((nvv (funcall nvL)))
(if (pair-p nvv)
(let ((pair nvv))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(funcall (funcall (funcall nvlist_accum)
(lambda () (let ((pair (funcall nvy)))
(let ((nvn (pair-fst pair))
(nvx (pair-snd pair)))
(if (inl-p (funcall (funcall nveq
(lambda () nvh))
(lambda () nvx)))
(make-pair :fst (+ nvn 1) :snd nvx)
(if (inl-p (nveq_int nvn 0))
(make-pair :fst 1 :snd nvh)
(make-pair :fst (- nvn 1) :snd nvx)))))))
(lambda () nvt))))
(if (axiom-p nvv)
(funcall nvy)
(error "bottom"))))))))
(lambda () (make-pair :fst 0 :snd nvx)))
(lambda () nvL)))

(defun nvrsc4_decided_send (nvCmd nvnotify nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvnotify))
(declare (ignore nvpropose))
(declare (ignore nvmf))
(lambda (nvl)
(lambda (nvz)
(nvmk-msg-interface (funcall nvl) (nvmake-Msg (make-pair :fst "rsc4" :snd (make-pair :fst "decided" :snd (make-axiom))) (funcall nvz))))))

(defun nvrsc4_retry_send (nvCmd nvnotify nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvnotify))
(declare (ignore nvpropose))
(declare (ignore nvmf))
(lambda (nvl)
(lambda (nvz)
(nvmk-msg-interface (funcall nvl) (nvmake-Msg (make-pair :fst "rsc4" :snd (make-pair :fst "retry" :snd (make-axiom))) (funcall nvz))))))

(defun nvrsc4_roundout (nvCmd nvcmdeq nvcoeff nvflrs nvnotify nvpropose nvmf)
(lambda (nvloc)
(lambda (nvzs)
(lambda (nvz)
(let ((pair (funcall nvzs)))
(let ((nvzt (pair-fst pair))
(nvsender (pair-snd pair)))
(declare (ignore nvsender))
(let ((pair nvzt))
(let ((nvzu (pair-fst pair))
(nvc (pair-snd pair)))
(let ((pair nvzu))
(let ((nvn (pair-fst pair))
(nvi (pair-snd pair)))
(let ((pair (funcall nvz)))
(let ((nvcmds (pair-fst pair))
(nvz (pair-snd pair)))
(declare (ignore nvz))
(if (inl-p (nveq_int (nvlength nvcmds) (* nvcoeff nvflrs)))
(let ((pair (nvposs-maj nvcmdeq (make-pair :fst nvc :snd nvcmds) nvc)))
(let ((nvk (pair-fst pair))
(nvx (pair-snd pair)))
(if (inl-p (nveq_int nvk (+ (* nvcoeff nvflrs) 1)))
(nvsingle-bag (funcall (funcall (nvrsc4_decided_send nvCmd nvnotify nvpropose nvmf)
(lambda () (funcall nvloc)))
(lambda () (make-pair :fst nvn :snd nvx))))
(nvsingle-bag (funcall (funcall (nvrsc4_retry_send nvCmd nvnotify nvpropose nvmf)
(lambda () (funcall nvloc)))
(lambda () (make-pair :fst (make-pair :fst nvn :snd (+ nvi 1)) :snd nvx)))))))
(make-axiom))))))))))))))

(defun nvrsc4_when_quorum (nvCmd nvcmdeq nvcoeff nvflrs nvnotify nvpropose nvmf)
(lambda (nvni)
(lambda (nvloc)
(lambda (nvvt)
(lambda (nvstate)
(if (inl-p (funcall (funcall (funcall (nvrsc4_newvote nvCmd)
(lambda () (funcall nvni)))
(lambda () (funcall nvvt)))
(lambda () (funcall nvstate))))
(funcall (funcall (funcall (nvrsc4_roundout nvCmd nvcmdeq nvcoeff nvflrs nvnotify nvpropose nvmf)
(lambda () (funcall nvloc)))
(lambda () (funcall nvvt)))
(lambda () (funcall nvstate)))
(make-axiom)))))))

(defun nvrsc4_addvote (nvCmd)
(declare (ignore nvCmd))
(lambda (nvzx)
(lambda (nvz)
(let ((pair (funcall nvzx)))
(let ((nvzy (pair-fst pair))
(nvsender (pair-snd pair)))
(let ((pair nvzy))
(let ((nvni (pair-fst pair))
(nvc (pair-snd pair)))
(declare (ignore nvni))
(let ((pair (funcall nvz)))
(let ((nvcmds (pair-fst pair))
(nvz (pair-snd pair)))
(make-pair :fst (make-pair :fst nvc :snd nvcmds) :snd (make-pair :fst nvsender :snd nvz)))))))))))

(defun nvrsc4_add_to_quorum (nvCmd)
(lambda (nvni)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvvt)
(lambda (nvstate)
(if (inl-p (funcall (funcall (funcall (nvrsc4_newvote nvCmd)
(lambda () (funcall nvni)))
(lambda () (funcall nvvt)))
(lambda () (funcall nvstate))))
(funcall (funcall (nvrsc4_addvote nvCmd)
(lambda () (funcall nvvt)))
(lambda () (funcall nvstate)))
(funcall nvstate)))))))

(defun nvrsc4_QuorumState-program (nvCmd nvnotify nvpropose nvmf)
(lambda (nvni)
(nvmemory-class1-program (funcall (nvrsc4_init)
(lambda () (make-pair :fst (make-axiom) :snd (make-axiom)))) (funcall (nvrsc4_add_to_quorum nvCmd)
(lambda () (funcall nvni))) (nvrsc4_vote_base-program nvCmd nvnotify nvpropose nvmf))))

(defun nvrsc4_Quorum-program (nvCmd nvcmdeq nvcoeff nvflrs nvnotify nvpropose nvmf)
(lambda (nvni)
(nveclass2-program (nveclass1-program (funcall (nvrsc4_when_quorum nvCmd nvcmdeq nvcoeff nvflrs nvnotify nvpropose nvmf)
(lambda () (funcall nvni))) (nvrsc4_vote_base-program nvCmd nvnotify nvpropose nvmf)) (funcall (nvrsc4_QuorumState-program nvCmd nvnotify nvpropose nvmf)
(lambda () (funcall nvni))))))

(defun nvhdf-once (nvX)
(funcall (fix "nvmk-hdf" (lambda (nvmk-hdf)
(lambda (nvs0)
(if (inl-p (nvhdf-halted (funcall nvs0)))
(nvhdf-halt)
(nvhdf-run (lambda (nvm)
(let ((pair (let ((pair (nvhdf-ap (funcall nvs0) (funcall nvm))))
(let ((nvX_ (pair-fst pair))
(nvb (pair-snd pair)))
(make-pair :fst (if (inl-p (nvbag-null nvb))
nvX_
(nvhdf-halt)) :snd nvb)))))
(let ((nvs1 (pair-fst pair))
(nvb (pair-snd pair)))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvs1)) :snd nvb)))))))))
(lambda () nvX)))

(defun nvonce-class-program (nvpr)
(lambda (nvi)
(nvhdf-once (funcall nvpr
(lambda () (funcall nvi))))))

(defun nvrsc4_Round-program (nvCmd nvcmdeq nvcoeff nvflrs nvlocs nvnotify nvpropose nvmf)
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvni (pair-fst pair))
(nvc (pair-snd pair)))
(nvparallel-class-program (nvreturn-loc-bag-class-program (lambda (nvloc)
(funcall (funcall (nvrsc4_vote_broadcast nvCmd nvnotify nvpropose nvmf)
(lambda () nvlocs))
(lambda () (make-pair :fst (make-pair :fst nvni :snd nvc) :snd (funcall nvloc)))))) (nvonce-class-program (funcall (nvrsc4_Quorum-program nvCmd nvcmdeq nvcoeff nvflrs nvnotify nvpropose nvmf)
(lambda () nvni))))))))

(defun nvrsc4_notify_broadcast (nvCmd nvnotify nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvpropose))
(declare (ignore nvmf))
(lambda (nvlocs)
(lambda (nvz)
(nvbag-map (lambda (nvl)
(nvmk-msg-interface (funcall nvl) (nvmake-Msg nvnotify (funcall nvz)))) (funcall nvlocs)))))

(defun nvrsc4_decision (nvCmd nvclients nvnotify nvpropose nvmf)
(lambda (nvn)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvm (pair-fst pair))
(nvc (pair-snd pair)))
(if (inl-p (nveq_int nvm (funcall nvn)))
(funcall (funcall (nvrsc4_notify_broadcast nvCmd nvnotify nvpropose nvmf)
(lambda () nvclients))
(lambda () (make-pair :fst nvm :snd nvc)))
(make-axiom))))))))

(defun nvrsc4_decided_base-program (nvCmd nvnotify nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvnotify))
(declare (ignore nvpropose))
(declare (ignore nvmf))
(nvbase-class-program (make-pair :fst "rsc4" :snd (make-pair :fst "decided" :snd (make-axiom)))))

(defun nvrsc4_Notify-program (nvCmd nvclients nvnotify nvpropose nvmf)
(lambda (nvn)
(nvonce-class-program (nveclass0-program (funcall (nvrsc4_decision nvCmd nvclients nvnotify nvpropose nvmf)
(lambda () (funcall nvn))) (nvrsc4_decided_base-program nvCmd nvnotify nvpropose nvmf)))))

(defun nvrsc4_when_new_round (nvCmd)
(declare (ignore nvCmd))
(lambda (nvn)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvz)
(lambda (nvround)
(let ((pair (funcall nvz)))
(let ((nvz (pair-fst pair))
(nvc (pair-snd pair)))
(let ((pair nvz))
(let ((nvm (pair-fst pair))
(nvi (pair-snd pair)))
(if (inl-p (nvband (nveq_int (funcall nvn) nvm) (nvlt_int (funcall nvround) nvi)))
(nvsingle-bag (make-pair :fst (make-pair :fst nvm :snd nvi) :snd nvc))
(make-axiom)))))))))))

(defun nvrsc4_retry_base-program (nvCmd nvnotify nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvnotify))
(declare (ignore nvpropose))
(declare (ignore nvmf))
(nvbase-class-program (make-pair :fst "rsc4" :snd (make-pair :fst "retry" :snd (make-axiom)))))

(defun nvrsc4_vote2retry (nvCmd)
(declare (ignore nvCmd))
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvz (pair-fst pair))
(nvsender (pair-snd pair)))
(declare (ignore nvsender))
(let ((pair nvz))
(let ((nvni (pair-fst pair))
(nvc (pair-snd pair)))
(nvsingle-bag (make-pair :fst nvni :snd nvc)))))))))

(defun nvrsc4_RoundInfo-program (nvCmd nvnotify nvpropose nvmf)
(nvparallel-class-program (nvrsc4_retry_base-program nvCmd nvnotify nvpropose nvmf) (nveclass0-program (nvrsc4_vote2retry nvCmd) (nvrsc4_vote_base-program nvCmd nvnotify nvpropose nvmf))))

(defun nvrsc4_update_round (nvCmd)
(declare (ignore nvCmd))
(lambda (nvn)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvz)
(lambda (nvround)
(let ((pair (funcall nvz)))
(let ((nvz (pair-fst pair))
(nvc (pair-snd pair)))
(declare (ignore nvc))
(let ((pair nvz))
(let ((nvm (pair-fst pair))
(nvi (pair-snd pair)))
(if (inl-p (nvband (nveq_int (funcall nvn) nvm) (nvlt_int (funcall nvround) nvi)))
nvi
(funcall nvround)))))))))))

(defun nvrsc4_NewRoundsState-program (nvCmd nvnotify nvpropose nvmf)
(lambda (nvn)
(nvmemory-class1-program (funcall (nvrsc4_init)
(lambda () 0)) (funcall (nvrsc4_update_round nvCmd)
(lambda () (funcall nvn))) (nvrsc4_RoundInfo-program nvCmd nvnotify nvpropose nvmf))))

(defun nvrsc4_NewRounds-program (nvCmd nvnotify nvpropose nvmf)
(lambda (nvn)
(nveclass2-program (nveclass1-program (funcall (nvrsc4_when_new_round nvCmd)
(lambda () (funcall nvn))) (nvrsc4_RoundInfo-program nvCmd nvnotify nvpropose nvmf)) (funcall (nvrsc4_NewRoundsState-program nvCmd nvnotify nvpropose nvmf)
(lambda () (funcall nvn))))))

(defun nvbind-nxt (nvY nvp nva)
(let ((pair nvp))
(let ((nvX (pair-fst pair))
(nvys (pair-snd pair)))
(let ((pair (nvhdf-ap nvX nva)))
(let ((nvX_ (pair-fst pair))
(nvb (pair-snd pair)))
(let ((nvybs (nvbag-map (lambda (nvP)
(nvhdf-ap (funcall nvP) nva)) (nvbag-append nvys (nvbag-map nvY nvb)))))
(let ((nvys_ (nvfilter (lambda (nvx)
(nvbnot (nvhdf-halted (funcall nvx)))) (nvbag-map (lambda (nvyb)
(nvpi1 (funcall nvyb))) nvybs))))
(let ((nvout (nvbag-union (nvbag-map (lambda (nvx)
(nvpi2 (funcall nvx))) nvybs))))
(make-pair :fst (make-pair :fst nvX_ :snd nvys_) :snd nvout)))))))))

(defun nvhdf-bind (nvX nvY)
(funcall (fix "nvmk-hdf" (lambda (nvmk-hdf)
(lambda (nvs0)
(if (inl-p (let ((pair (funcall nvs0)))
(let ((nvX (pair-fst pair))
(nvys (pair-snd pair)))
(nvband (nvhdf-halted nvX) (nvbag-null nvys)))))
(nvhdf-halt)
(nvhdf-run (lambda (nvm)
(let ((pair (nvbind-nxt nvY (funcall nvs0) (funcall nvm))))
(let ((nvs1 (pair-fst pair))
(nvb (pair-snd pair)))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvs1)) :snd nvb)))))))))
(lambda () (make-pair :fst nvX :snd (make-axiom)))))

(defun nvbind-class-program (nvxpr nvypr)
(lambda (nvi)
(nvhdf-bind (funcall nvxpr
(lambda () (funcall nvi))) (lambda (nvx)
(funcall (funcall nvypr
(lambda () (funcall nvx)))
(lambda () (funcall nvi)))))))

(defun nvhdf-until (nvX nvY)
(funcall (fix "nvmk-hdf" (lambda (nvmk-hdf)
(lambda (nvs0)
(if (inl-p (nvhdf-halted (nvpi1 (funcall nvs0))))
(nvhdf-halt)
(nvhdf-run (lambda (nvm)
(let ((pair (let ((pair (funcall nvs0)))
(let ((nvX (pair-fst pair))
(nvY (pair-snd pair)))
(let ((pair (nvhdf-ap nvX (funcall nvm))))
(let ((nvX_ (pair-fst pair))
(nvb (pair-snd pair)))
(let ((pair (nvhdf-ap nvY (funcall nvm))))
(let ((nvY_ (pair-fst pair))
(nvc (pair-snd pair)))
(make-pair :fst (make-pair :fst (if (inl-p (nvbag-null nvc))
nvX_
(nvhdf-halt)) :snd nvY_) :snd nvb)))))))))
(let ((nvs1 (pair-fst pair))
(nvb (pair-snd pair)))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvs1)) :snd nvb)))))))))
(lambda () (make-pair :fst nvX :snd nvY))))

(defun nvuntil-class-program (nvxpr nvypr)
(lambda (nvi)
(nvhdf-until (funcall nvxpr
(lambda () (funcall nvi))) (funcall nvypr
(lambda () (funcall nvi))))))

(defun nvrsc4_Voter-program (nvCmd nvclients nvcmdeq nvcoeff nvflrs nvlocs nvnotify nvpropose nvmf)
(lambda (nvzz)
(let ((pair (funcall nvzz)))
(let ((nvn (pair-fst pair))
(nvc (pair-snd pair)))
(nvparallel-class-program (nvparallel-class-program (funcall (nvrsc4_Round-program nvCmd nvcmdeq nvcoeff nvflrs nvlocs nvnotify nvpropose nvmf)
(lambda () (make-pair :fst (make-pair :fst nvn :snd 0) :snd nvc))) (funcall (nvrsc4_Notify-program nvCmd nvclients nvnotify nvpropose nvmf)
(lambda () nvn))) (nvuntil-class-program (nvbind-class-program (funcall (nvrsc4_NewRounds-program nvCmd nvnotify nvpropose nvmf)
(lambda () nvn)) (lambda (nvz)
(funcall (nvrsc4_Round-program nvCmd nvcmdeq nvcoeff nvflrs nvlocs nvnotify nvpropose nvmf)
(lambda () (funcall nvz))))) (funcall (nvrsc4_Notify-program nvCmd nvclients nvnotify nvpropose nvmf)
(lambda () nvn))))))))

(defun nvrsc4_Replica-program (nvCmd nvclients nvcmdeq nvcoeff nvflrs nvlocs nvnotify nvpropose nvmf)
(nvbind-class-program (nvrsc4_NewVoters-program nvCmd nvnotify nvpropose nvmf) (lambda (nvz)
(funcall (nvrsc4_Voter-program nvCmd nvclients nvcmdeq nvcoeff nvflrs nvlocs nvnotify nvpropose nvmf)
(lambda () (funcall nvz))))))

(defun nvbag-deq-member (nveq nvx nvb)
(nvdeq-member nveq nvx nvb))

(defun nvclass-at-program (nvpr nvlocs)
(lambda (nvi)
(if (inl-p (nvbag-deq-member (lambda (nva)
(lambda (nvb)
(if (string= (funcall nva) (funcall nvb))
(make-inl :val (make-axiom))
(make-inr :val (make-axiom))))) (funcall nvi) nvlocs))
(funcall nvpr
(lambda () (funcall nvi)))
(nvhdf-halt))))

(defun nvrsc4_main-program (nvCmd nvclients nvcmdeq nvcoeff nvflrs nvlocs nvnotify nvpropose nvmf)
(nvclass-at-program (nvrsc4_Replica-program nvCmd nvclients nvcmdeq nvcoeff nvflrs nvlocs nvnotify nvpropose nvmf) nvlocs))

(defun nvaneris_control_rsc4_main-program (nvOp nveq_Op nvflrs nvlocs nvreps nvmf)
(nvrsc4_main-program "UNION" nvreps (nvaneris_control_tagged_cmd_deq nvOp nveq_Op) 2 nvflrs nvlocs (make-pair :fst "decision" :snd (make-axiom)) (make-pair :fst "rsc4" :snd (make-pair :fst "propose" :snd (make-axiom))) nvmf))

(defun nvle_int (nvi nvj)
(nvbnot (nvlt_int nvj nvi)))

(defun nvaneris_pax_v1_higher_leader (nvldrs nvldrs_uid)
(lambda (nvloc)
(let ((nvid (funcall nvldrs_uid
(lambda () (funcall nvloc)))))
(funcall (funcall (fix "nvlist_accum" (lambda (nvlist_accum)
(lambda (nvy)
(lambda (nvL)
(let ((nvv (funcall nvL)))
(if (pair-p nvv)
(let ((pair nvv))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(funcall (funcall (funcall nvlist_accum)
(lambda () (let ((nvi (funcall nvldrs_uid
(lambda () nvh))))
(if (inl-p (nvle_int nvi nvid))
(funcall nvy)
(let ((dec (funcall nvy)))
(if (inl-p dec)
(let ((nvl (inl-val dec)))
(if (inl-p (nvlt_int nvi (funcall nvldrs_uid
(lambda () nvl))))
(make-inl :val nvh)
(funcall nvy)))
(if (inr-p dec)
(make-inl :val nvh)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))))
(lambda () nvt))))
(if (axiom-p nvv)
(funcall nvy)
(error "bottom"))))))))
(lambda () (make-inr :val (make-axiom))))
(lambda () nvldrs)))))

(defun nvaneris_pax_v1_HigherLeader-program (nvCmd nvdecision nvldrs nvldrs_uid nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvmf))
(nvreturn-loc-bag-class-program (lambda (nvldr)
(nvsingle-bag (funcall (nvaneris_pax_v1_higher_leader nvldrs nvldrs_uid)
(lambda () (funcall nvldr)))))))

(defun nvaneris_pax_v1_ping_send (nvCmd nvdecision nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvmf))
(lambda (nvl)
(lambda (nvz)
(nvmk-msg-interface (funcall nvl) (nvmake-Msg (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "ping" :snd (make-axiom))) (funcall nvz))))))

(defun nvaneris_pax_v1_react__send (nvCmd nvdecision nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvmf))
(lambda (nvn)
(lambda (nvl)
(lambda (nvz)
(nvmake-msg-interface (funcall nvn) (funcall nvl) (nvmake-Msg (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "react" :snd (make-axiom))) (funcall nvz)))))))

(defun nvaneris_pax_v1_start_send (nvCmd nvdecision nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvmf))
(lambda (nvl)
(lambda (nvz)
(nvmk-msg-interface (funcall nvl) (nvmake-Msg (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "start" :snd (make-axiom))) (funcall nvz))))))

(defun nvaneris_pax_v1_react_base-program (nvCmd nvdecision nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvmf))
(nvbase-class-program (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "react" :snd (make-axiom)))))

(defun nvaneris_pax_v1_pong_base-program (nvCmd nvdecision nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvmf))
(nvbase-class-program (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "pong" :snd (make-axiom)))))

(defun nvmemory-class2-program (nvinit nvtr1 nvpr1 nvtr2 nvpr2)
(nvloop-class-memory-program (nvparallel-class-program (nveclass1-program nvtr1 nvpr1) (nveclass1-program nvtr2 nvpr2)) (lambda (nvloc)
(nvsingle-bag (funcall nvinit
(lambda () (funcall nvloc)))))))

(defun nvaneris_pax_v1_MonitorState-program (nvCmd nvdecision nvpropose nvmf)
(lambda (nvloc)
(declare (ignore nvloc))
(nvmemory-class2-program (lambda (nvz)
(declare (ignore nvz))
(nvbfalse)) (lambda (nvz)
(declare (ignore nvz))
(lambda (nvz)
(declare (ignore nvz))
(lambda (nvz)
(declare (ignore nvz))
(nvbtrue)))) (nvaneris_pax_v1_pong_base-program nvCmd nvdecision nvpropose nvmf) (lambda (nvz)
(declare (ignore nvz))
(lambda (nvz)
(declare (ignore nvz))
(lambda (nvz)
(declare (ignore nvz))
(nvbfalse)))) (nvaneris_pax_v1_react_base-program nvCmd nvdecision nvpropose nvmf))))

(defun nvaneris_pax_v1_MonitorReact-program (nvCmd nvdecision nvpropose nvmf)
(lambda (nvloc)
(let ((nvF (lambda (nvldr)
(lambda (nvz)
(declare (ignore nvz))
(lambda (nvreceived_pong)
(if (inl-p (funcall nvreceived_pong))
(nvbag-append (nvsingle-bag (funcall (funcall (nvaneris_pax_v1_ping_send nvCmd nvdecision nvpropose nvmf)
(lambda () (funcall nvloc)))
(lambda () (funcall nvldr)))) (nvsingle-bag (funcall (funcall (funcall (nvaneris_pax_v1_react__send nvCmd nvdecision nvpropose nvmf)
(lambda () 10000))
(lambda () (funcall nvldr)))
(lambda () (make-axiom)))))
(nvsingle-bag (funcall (funcall (nvaneris_pax_v1_start_send nvCmd nvdecision nvpropose nvmf)
(lambda () (funcall nvldr)))
(lambda () (make-axiom))))))))))
(nveclass2-program (nveclass1-program nvF (nvaneris_pax_v1_react_base-program nvCmd nvdecision nvpropose nvmf)) (funcall (nvaneris_pax_v1_MonitorState-program nvCmd nvdecision nvpropose nvmf)
(lambda () (funcall nvloc)))))))

(defun nvaneris_pax_v1_MonitorHigherLeader-program (nvCmd nvdecision nvpropose nvmf)
(lambda (nvloc)
(nvparallel-class-program (nvparallel-class-program (nvreturn-loc-bag-class-program (lambda (nvldr)
(nvsingle-bag (funcall (funcall (nvaneris_pax_v1_ping_send nvCmd nvdecision nvpropose nvmf)
(lambda () (funcall nvloc)))
(lambda () (funcall nvldr)))))) (nvreturn-loc-bag-class-program (lambda (nvldr)
(nvsingle-bag (funcall (funcall (funcall (nvaneris_pax_v1_react__send nvCmd nvdecision nvpropose nvmf)
(lambda () 10000))
(lambda () (funcall nvldr)))
(lambda () (make-axiom))))))) (funcall (nvaneris_pax_v1_MonitorReact-program nvCmd nvdecision nvpropose nvmf)
(lambda () (funcall nvloc))))))

(defun nvaneris_pax_v1_p1a_broadcast (nvCmd nvdecision nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvmf))
(lambda (nvlocs)
(lambda (nvz)
(nvbag-map (lambda (nvl)
(nvmk-msg-interface (funcall nvl) (nvmake-Msg (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p1a" :snd (make-axiom))) (funcall nvz)))) (funcall nvlocs)))))

(defun nvaneris_pax_v1_ScoutNotify-program (nvCmd nvaccpts nvdecision nvpropose nvmf)
(lambda (nvbn)
(nvreturn-loc-bag-class-program (lambda (nvldr)
(funcall (funcall (nvaneris_pax_v1_p1a_broadcast nvCmd nvdecision nvpropose nvmf)
(lambda () nvaccpts))
(lambda () (make-pair :fst (funcall nvldr) :snd (funcall nvbn))))))))

(defun nvId ()
"ATOM")

(defun nvunit-deq ()
(lambda (nva)
(declare (ignore nva))
(lambda (nvb)
(declare (ignore nvb))
(nvbtrue))))

(defun nvaneris_pax_v1_eq_bnums ()
(lambda (nvbn1)
(lambda (nvbn2)
(funcall (funcall (nvunion-deq "PRODUCT" "EQUAL" (nvproduct-deq "INT" (nvId) (nvint-deq) (lambda (nva)
(lambda (nvb)
(if (string= (funcall nva) (funcall nvb))
(make-inl :val (make-axiom))
(make-inr :val (make-axiom)))))) (nvunit-deq))
(lambda () (funcall nvbn1)))
(lambda () (funcall nvbn2))))))

(defun nvbag-size (nvbs)
(nvlength nvbs))

(defun nvaneris_pax_v1_threshold (nvaccpts)
(/ (+ (nvbag-size nvaccpts) 1) 2))

(defun nvaneris_pax_v1_adopted_send (nvCmd nvdecision nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvmf))
(lambda (nvl)
(lambda (nvz)
(nvmk-msg-interface (funcall nvl) (nvmake-Msg (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "adopted" :snd (make-axiom))) (funcall nvz))))))

(defun nvaneris_pax_v1_preempted_send (nvCmd nvdecision nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvmf))
(lambda (nvl)
(lambda (nvz)
(nvmk-msg-interface (funcall nvl) (nvmake-Msg (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "preempted" :snd (make-axiom))) (funcall nvz))))))

(defun nvaneris_pax_v1_scout_output (nvCmd nvaccpts nvdecision nvpropose nvmf)
(lambda (nvbnum)
(lambda (nvldr)
(lambda (nvzl)
(lambda (nvz)
(let ((pair (funcall nvzl)))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(declare (ignore nvw))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz_ (pair-snd pair)))
(declare (ignore nvz_))
(let ((pair (funcall nvz)))
(let ((nvwaitfor (pair-fst pair))
(nvpvalues (pair-snd pair)))
(if (inl-p (funcall (funcall (nvaneris_pax_v1_eq_bnums)
(lambda () (funcall nvbnum)))
(lambda () nvx)))
(if (inl-p (funcall (funcall (nvaneris_pax_v1_eq_bnums)
(lambda () (funcall nvbnum)))
(lambda () nvy)))
(if (inl-p (nvlt_int (nvbag-size nvwaitfor) (nvaneris_pax_v1_threshold nvaccpts)))
(nvsingle-bag (funcall (funcall (nvaneris_pax_v1_adopted_send nvCmd nvdecision nvpropose nvmf)
(lambda () (funcall nvldr)))
(lambda () (make-pair :fst (funcall nvbnum) :snd nvpvalues))))
(make-axiom))
(nvsingle-bag (funcall (funcall (nvaneris_pax_v1_preempted_send nvCmd nvdecision nvpropose nvmf)
(lambda () (funcall nvldr)))
(lambda () nvy))))
(make-axiom)))))))))))))))

(defun nvaneris_pax_v1_p1b_base-program (nvCmd nvdecision nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvmf))
(nvbase-class-program (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p1b" :snd (make-axiom)))))

(defun nvaneris_pax_v1_init_pvalues (nvCmd)
(declare (ignore nvCmd))
(make-axiom))

(defun nvaneris_pax_v1_init_scout (nvCmd nvaccpts)
(make-pair :fst nvaccpts :snd (nvaneris_pax_v1_init_pvalues nvCmd)))

(defun nvbag-remove (nveq nvbs nvx)
(nvfilter (lambda (nvx_)
(nvbnot (funcall (funcall nveq
(lambda () nvx))
(lambda () (funcall nvx_))))) nvbs))

(defun nvaneris_pax_v1_prp2slt (nvCmd)
(declare (ignore nvCmd))
(lambda (nvproposal)
(nvpi1 (funcall nvproposal))))

(defun nvaneris_pax_v1_pv2prp (nvCmd)
(declare (ignore nvCmd))
(lambda (nvpvalue)
(nvpi2 (funcall nvpvalue))))

(defun nvint-minus-comparison (nvf)
(lambda (nvx)
(lambda (nvy)
(- (funcall nvf
(lambda () (funcall nvx))) (funcall nvf
(lambda () (funcall nvy)))))))

(defun nvaneris_pax_v1_leq_bnum_ (nvldrs_uid)
(lambda (nvza)
(lambda (nvz)
(let ((pair (funcall nvza)))
(let ((nvi1 (pair-fst pair))
(nvl1 (pair-snd pair)))
(let ((pair (funcall nvz)))
(let ((nvi2 (pair-fst pair))
(nvl2 (pair-snd pair)))
(nvbor (nvlt_int nvi1 nvi2) (nvband (nveq_int nvi1 nvi2) (nvle_int (funcall nvldrs_uid
(lambda () nvl1)) (funcall nvldrs_uid
(lambda () nvl2))))))))))))

(defun nvaneris_pax_v1_leq_bnum (nvldrs_uid)
(lambda (nvbn1)
(lambda (nvbn2)
(let ((dec (funcall nvbn1)))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(let ((dec (funcall nvbn2)))
(if (inl-p dec)
(let ((nvx2 (inl-val dec)))
(funcall (funcall (nvaneris_pax_v1_leq_bnum_ nvldrs_uid)
(lambda () nvx1))
(lambda () nvx2)))
(if (inr-p dec)
(nvbfalse)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(if (inr-p dec)
(nvbtrue)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))

(defun nvaneris_pax_v1_pv2bn (nvCmd)
(declare (ignore nvCmd))
(lambda (nvpvalue)
(nvpi1 (funcall nvpvalue))))

(defun nvinsert-combine (nvcmp nvf nvx nvl)
(funcall (fix "nvlist_ind" (lambda (nvlist_ind)
(lambda (nvL)
(let ((nvv (funcall nvL)))
(if (pair-p nvv)
(let ((pair nvv))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(let ((nvtst (funcall (funcall nvcmp
(lambda () nvx))
(lambda () nvh))))
(if (inl-p (nveq_int nvtst 0))
(make-pair :fst (funcall (funcall nvf
(lambda () nvx))
(lambda () nvh)) :snd nvt)
(if (inl-p (nvlt_int 0 nvtst))
(make-pair :fst nvx :snd (make-pair :fst nvh :snd nvt))
(make-pair :fst nvh :snd (funcall (funcall nvlist_ind)
(lambda () nvt))))))))
(if (axiom-p nvv)
(make-pair :fst nvx :snd (make-axiom))
(error "bottom")))))))
(lambda () nvl)))

(defun nvaneris_pax_v1_add_pvalue (nvCmd nvldrs_uid)
(lambda (nvpvalues)
(lambda (nvpvalue)
(nvinsert-combine (nvint-minus-comparison (lambda (nvpv)
(funcall (nvaneris_pax_v1_prp2slt nvCmd)
(lambda () (funcall (nvaneris_pax_v1_pv2prp nvCmd)
(lambda () (funcall nvpv))))))) (lambda (nvpv1)
(lambda (nvpv2)
(if (inl-p (funcall (funcall (nvaneris_pax_v1_leq_bnum nvldrs_uid)
(lambda () (funcall (nvaneris_pax_v1_pv2bn nvCmd)
(lambda () (funcall nvpv1)))))
(lambda () (funcall (nvaneris_pax_v1_pv2bn nvCmd)
(lambda () (funcall nvpv2))))))
(funcall nvpv2)
(funcall nvpv1)))) (funcall nvpvalue) (funcall nvpvalues)))))

(defun nvaneris_pax_v1_add_new_pvalues (nvCmd nvldrs_uid)
(lambda (nvpvals1)
(lambda (nvpvals2)
(nvreduce (lambda (nvpv)
(lambda (nvr)
(funcall (funcall (nvaneris_pax_v1_add_pvalue nvCmd nvldrs_uid)
(lambda () (funcall nvr)))
(lambda () (funcall nvpv))))) (funcall nvpvals2) (funcall nvpvals1)))))

(defun nvaneris_pax_v1_on_p1b (nvCmd nvldrs_uid)
(lambda (nvbnum)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvzj)
(lambda (nvz)
(let ((pair (funcall nvzj)))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz_ (pair-snd pair)))
(let ((pair (funcall nvz)))
(let ((nvwaitfor (pair-fst pair))
(nvpvalues (pair-snd pair)))
(if (inl-p (nvband (funcall (funcall (nvaneris_pax_v1_eq_bnums)
(lambda () (funcall nvbnum)))
(lambda () nvx)) (funcall (funcall (nvaneris_pax_v1_eq_bnums)
(lambda () (funcall nvbnum)))
(lambda () nvy))))
(let ((nvwaitfor_ (nvbag-remove (lambda (nva)
(lambda (nvb)
(if (string= (funcall nva) (funcall nvb))
(make-inl :val (make-axiom))
(make-inr :val (make-axiom))))) nvwaitfor nvw)))
(let ((nvpvalues_ (funcall (funcall (nvaneris_pax_v1_add_new_pvalues nvCmd nvldrs_uid)
(lambda () nvpvalues))
(lambda () nvz_))))
(make-pair :fst nvwaitfor_ :snd nvpvalues_)))
(make-pair :fst nvwaitfor :snd nvpvalues)))))))))))))))

(defun nvhdf-state (nvX nvbs)
(funcall (fix "nvmk-hdf" (lambda (nvmk-hdf)
(lambda (nvs0)
(if (inl-p (nvbfalse))
(nvhdf-halt)
(nvhdf-run (lambda (nvm)
(let ((pair (let ((pair (funcall nvs0)))
(let ((nvX (pair-fst pair))
(nvs (pair-snd pair)))
(let ((pair (nvhdf-ap nvX (funcall nvm))))
(let ((nvX_ (pair-fst pair))
(nvfs (pair-snd pair)))
(let ((nvb (nvbag-union (nvbag-map (lambda (nvx)
(nvbag-map (funcall nvx) nvs)) nvfs))))
(let ((nvs_ (if (inl-p (nvbag-null nvb))
nvs
nvb)))
(make-pair :fst (make-pair :fst nvX_ :snd nvs_) :snd nvs_)))))))))
(let ((nvs1 (pair-fst pair))
(nvb (pair-snd pair)))
(make-pair :fst (funcall (funcall nvmk-hdf)
(lambda () nvs1)) :snd nvb)))))))))
(lambda () (make-pair :fst nvX :snd nvbs))))

(defun nvloop-class-state-program (nvpr nvinit)
(lambda (nvi)
(nvhdf-state (funcall nvpr
(lambda () (funcall nvi))) (funcall nvinit
(lambda () (funcall nvi))))))

(defun nvstate-class1-program (nvinit nvtr nvpr)
(nvloop-class-state-program (nveclass1-program nvtr nvpr) (lambda (nvloc)
(nvsingle-bag (funcall nvinit
(lambda () (funcall nvloc)))))))

(defun nvaneris_pax_v1_ScoutState-program (nvCmd nvaccpts nvdecision nvldrs_uid nvpropose nvmf)
(lambda (nvbn)
(nvstate-class1-program (lambda (nvloc)
(declare (ignore nvloc))
(nvaneris_pax_v1_init_scout nvCmd nvaccpts)) (funcall (nvaneris_pax_v1_on_p1b nvCmd nvldrs_uid)
(lambda () (funcall nvbn))) (nvaneris_pax_v1_p1b_base-program nvCmd nvdecision nvpropose nvmf))))

(defun nvaneris_pax_v1_ScoutOutput-program (nvCmd nvaccpts nvdecision nvldrs_uid nvpropose nvmf)
(lambda (nvbn)
(nvonce-class-program (nveclass2-program (nveclass1-program (funcall (nvaneris_pax_v1_scout_output nvCmd nvaccpts nvdecision nvpropose nvmf)
(lambda () (funcall nvbn))) (nvaneris_pax_v1_p1b_base-program nvCmd nvdecision nvpropose nvmf)) (funcall (nvaneris_pax_v1_ScoutState-program nvCmd nvaccpts nvdecision nvldrs_uid nvpropose nvmf)
(lambda () (funcall nvbn)))))))

(defun nvaneris_pax_v1_Scout-program (nvCmd nvaccpts nvdecision nvldrs_uid nvpropose nvmf)
(lambda (nvbn)
(nvparallel-class-program (funcall (nvaneris_pax_v1_ScoutNotify-program nvCmd nvaccpts nvdecision nvpropose nvmf)
(lambda () (funcall nvbn))) (funcall (nvaneris_pax_v1_ScoutOutput-program nvCmd nvaccpts nvdecision nvldrs_uid nvpropose nvmf)
(lambda () (funcall nvbn))))))

(defun nvaneris_pax_v1_mk_bnum ()
(lambda (nvn)
(lambda (nvloc)
(make-inl :val (make-pair :fst (funcall nvn) :snd (funcall nvloc))))))

(defun nvon-loc-class-program (nvpr)
(lambda (nvi)
(funcall (funcall nvpr
(lambda () (funcall nvi)))
(lambda () (funcall nvi)))))

(defun nvaneris_pax_v1_SpawnFirstScout-program (nvCmd nvaccpts nvdecision nvldrs_uid nvpropose nvmf)
(nvon-loc-class-program (lambda (nvldr)
(funcall (nvaneris_pax_v1_Scout-program nvCmd nvaccpts nvdecision nvldrs_uid nvpropose nvmf)
(lambda () (funcall (funcall (nvaneris_pax_v1_mk_bnum)
(lambda () 0))
(lambda () (funcall nvldr))))))))

(defun nvaneris_pax_v1_LeaderStart-program (nvCmd nvaccpts nvdecision nvldrs_uid nvpropose nvmf)
(lambda (nvd)
(let ((dec (funcall nvd)))
(if (inl-p dec)
(let ((nvl (inl-val dec)))
(funcall (nvaneris_pax_v1_MonitorHigherLeader-program nvCmd nvdecision nvpropose nvmf)
(lambda () nvl)))
(if (inr-p dec)
(nvaneris_pax_v1_SpawnFirstScout-program nvCmd nvaccpts nvdecision nvldrs_uid nvpropose nvmf)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))

(defun nvaneris_pax_v1_start_base-program (nvCmd nvdecision nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvmf))
(nvbase-class-program (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "start" :snd (make-axiom)))))

(defun nvaneris_pax_v1_dest_prp (nvCmd)
(declare (ignore nvCmd))
(lambda (nvproposal)
(funcall nvproposal)))

(defun nvaneris_pax_v1_in_proposals (nvCmd)
(lambda (nvslt)
(lambda (nvproposals)
(nvreduce (lambda (nvprp)
(lambda (nvr)
(let ((pair (funcall (nvaneris_pax_v1_dest_prp nvCmd)
(lambda () (funcall nvprp)))))
(let ((nvslt_ (pair-fst pair))
(nvcmd (pair-snd pair)))
(declare (ignore nvcmd))
(if (inl-p (nvlt_int nvslt_ (funcall nvslt)))
(nvbfalse)
(if (inl-p (nveq_int (funcall nvslt) nvslt_))
(nvbtrue)
(funcall nvr))))))) (nvbfalse) (funcall nvproposals)))))

(defun nvaneris_pax_v1_is_in_missing ()
(lambda (nvslt)
(lambda (nvmissing)
(nvreduce (lambda (nvh)
(lambda (nvr)
(if (inl-p (nvlt_int (funcall nvslt) (funcall nvh)))
(nvbfalse)
(if (inl-p (nveq_int (funcall nvslt) (funcall nvh)))
(nvbtrue)
(funcall nvr))))) (nvbfalse) (funcall nvmissing)))))

(defun nvaneris_pax_v1_is_decided ()
(lambda (nvslt)
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvmax (pair-fst pair))
(nvmissing (pair-snd pair)))
(nvband (nvle_int (funcall nvslt) nvmax) (nvbnot (funcall (funcall (nvaneris_pax_v1_is_in_missing)
(lambda () (funcall nvslt)))
(lambda () nvmissing)))))))))

(defun nvaneris_pax_v1_mk_pv (nvCmd)
(declare (ignore nvCmd))
(lambda (nvbn)
(lambda (nvprp)
(make-pair :fst (funcall nvbn) :snd (funcall nvprp)))))

(defun nvaneris_pax_v1_leader_propose (nvCmd)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvproposal)
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz_ (pair-snd pair)))
(let ((nvslt (funcall (nvaneris_pax_v1_prp2slt nvCmd)
(lambda () (funcall nvproposal)))))
(if (inl-p (nvband nvx (nvband (nvbnot (funcall (funcall (nvaneris_pax_v1_in_proposals nvCmd)
(lambda () nvslt))
(lambda () nvy))) (nvbnot (funcall (funcall (nvaneris_pax_v1_is_decided)
(lambda () nvslt))
(lambda () nvz_))))))
(nvsingle-bag (funcall (funcall (nvaneris_pax_v1_mk_pv nvCmd)
(lambda () nvw))
(lambda () (funcall nvproposal))))
(make-axiom)))))))))))))

(defun nvaneris_pax_v1_propose_base-program (nvCmd nvdecision nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvmf))
(nvbase-class-program nvpropose))

(defun nvaneris_pax_v1_init_ballot_num ()
(lambda (nvloc)
(funcall (funcall (nvaneris_pax_v1_mk_bnum)
(lambda () 0))
(lambda () (funcall nvloc)))))

(defun nvaneris_pax_v1_init_active ()
(nvbfalse))

(defun nvaneris_pax_v1_init_proposals (nvCmd)
(declare (ignore nvCmd))
(make-axiom))

(defun nvaneris_pax_v1_init_decided ()
(make-pair :fst 0 :snd (make-axiom)))

(defun nvaneris_pax_v1_init_leader (nvCmd)
(lambda (nvloc)
(make-pair :fst (funcall (nvaneris_pax_v1_init_ballot_num)
(lambda () (funcall nvloc))) :snd (make-pair :fst (nvaneris_pax_v1_init_active) :snd (make-pair :fst (nvaneris_pax_v1_init_proposals nvCmd) :snd (nvaneris_pax_v1_init_decided))))))

(defun nvaneris_pax_v1_mk_prp (nvCmd)
(declare (ignore nvCmd))
(lambda (nvslt)
(lambda (nvcmd)
(make-pair :fst (funcall nvslt) :snd (funcall nvcmd)))))

(defun nvaneris_pax_v1_add_proposal_if_not_in (nvCCmd)
(lambda (nvproposals)
(lambda (nvslt)
(lambda (nvcmd)
(nvinsert-combine (nvint-minus-comparison (nvaneris_pax_v1_prp2slt nvCCmd)) (lambda (nvprp1)
(declare (ignore nvprp1))
(lambda (nvprp2)
(funcall nvprp2))) (funcall (funcall (nvaneris_pax_v1_mk_prp nvCCmd)
(lambda () (funcall nvslt)))
(lambda () (funcall nvcmd))) (funcall nvproposals))))))

(defun nvaneris_pax_v1_on_propose (nvCmd)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvproposal)
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz_ (pair-snd pair)))
(let ((pair (funcall (nvaneris_pax_v1_dest_prp nvCmd)
(lambda () (funcall nvproposal)))))
(let ((nvslt (pair-fst pair))
(nvcmd (pair-snd pair)))
(let ((nvproposals_ (if (inl-p (funcall (funcall (nvaneris_pax_v1_is_decided)
(lambda () nvslt))
(lambda () nvz_)))
nvy
(funcall (funcall (funcall (nvaneris_pax_v1_add_proposal_if_not_in nvCmd)
(lambda () nvy))
(lambda () nvslt))
(lambda () nvcmd)))))
(make-pair :fst nvw :snd (make-pair :fst nvx :snd (make-pair :fst nvproposals_ :snd nvz_))))))))))))))))

(defun nvaneris_pax_v1_dest_pv (nvCmd)
(lambda (nvpvalue)
(let ((pair (funcall nvpvalue)))
(let ((nvbn (pair-fst pair))
(nvprp (pair-snd pair)))
(make-pair :fst nvbn :snd (funcall (nvaneris_pax_v1_dest_prp nvCmd)
(lambda () nvprp)))))))

(defun nvaneris_pax_v1_add_proposal (nvCCmd)
(lambda (nvproposals)
(lambda (nvslt)
(lambda (nvcmd)
(nvinsert-combine (nvint-minus-comparison (nvaneris_pax_v1_prp2slt nvCCmd)) (lambda (nvprp1)
(lambda (nvprp2)
(declare (ignore nvprp2))
(funcall nvprp1))) (funcall (funcall (nvaneris_pax_v1_mk_prp nvCCmd)
(lambda () (funcall nvslt)))
(lambda () (funcall nvcmd))) (funcall nvproposals))))))

(defun nvaneris_pax_v1_update_proposals (nvCmd)
(lambda (nvproposals)
(lambda (nvdecided)
(lambda (nvpvals)
(funcall (funcall (fix "nvlist_accum" (lambda (nvlist_accum)
(lambda (nvy)
(lambda (nvL)
(let ((nvv (funcall nvL)))
(if (pair-p nvv)
(let ((pair nvv))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(funcall (funcall (funcall nvlist_accum)
(lambda () (let ((pair (funcall (nvaneris_pax_v1_dest_pv nvCmd)
(lambda () nvh))))
(let ((nvx (pair-fst pair))
(nvzz (pair-snd pair)))
(declare (ignore nvx))
(let ((pair nvzz))
(let ((nvy_ (pair-fst pair))
(nvz (pair-snd pair)))
(if (inl-p (funcall (funcall (nvaneris_pax_v1_is_decided)
(lambda () nvy_))
(lambda () (funcall nvdecided))))
(funcall nvy)
(funcall (funcall (funcall (nvaneris_pax_v1_add_proposal nvCmd)
(lambda () (funcall nvy)))
(lambda () nvy_))
(lambda () nvz)))))))))
(lambda () nvt))))
(if (axiom-p nvv)
(funcall nvy)
(error "bottom"))))))))
(lambda () (funcall nvproposals)))
(lambda () (funcall nvpvals)))))))

(defun nvaneris_pax_v1_when_adopted (nvCmd)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvzm)
(lambda (nvz)
(let ((pair (funcall nvzm)))
(let ((nvbnum (pair-fst pair))
(nvpvals (pair-snd pair)))
(let ((pair (funcall nvz)))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz_ (pair-snd pair)))
(if (inl-p (funcall (funcall (nvaneris_pax_v1_eq_bnums)
(lambda () nvbnum))
(lambda () nvw)))
(let ((nvproposals_ (funcall (funcall (funcall (nvaneris_pax_v1_update_proposals nvCmd)
(lambda () nvy))
(lambda () nvz_))
(lambda () nvpvals))))
(make-pair :fst nvw :snd (make-pair :fst (nvbtrue) :snd (make-pair :fst nvproposals_ :snd nvz_))))
(make-pair :fst nvw :snd (make-pair :fst nvx :snd (make-pair :fst nvy :snd nvz_))))))))))))))))

(defun nvaneris_pax_v1_adopted_base-program (nvCmd nvdecision nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvmf))
(nvbase-class-program (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "adopted" :snd (make-axiom)))))

(defun nvisl (nvx)
(let ((dec nvx))
(if (inl-p dec)
(nvbtrue)
(if (inr-p dec)
(nvbfalse)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))

(defun nvaneris_pax_v1_is_bnum ()
(lambda (nvbnum)
(nvisl (funcall nvbnum))))

(defun nvaneris_pax_v1_lt_bnum_ (nvldrs_uid)
(lambda (nvzb)
(lambda (nvz)
(let ((pair (funcall nvzb)))
(let ((nvi1 (pair-fst pair))
(nvl1 (pair-snd pair)))
(let ((pair (funcall nvz)))
(let ((nvi2 (pair-fst pair))
(nvl2 (pair-snd pair)))
(nvbor (nvlt_int nvi1 nvi2) (nvband (nveq_int nvi1 nvi2) (nvlt_int (funcall nvldrs_uid
(lambda () nvl1)) (funcall nvldrs_uid
(lambda () nvl2))))))))))))

(defun nvaneris_pax_v1_lt_bnum (nvldrs_uid)
(lambda (nvbn1)
(lambda (nvbn2)
(let ((dec (funcall nvbn1)))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(let ((dec (funcall nvbn2)))
(if (inl-p dec)
(let ((nvx2 (inl-val dec)))
(funcall (funcall (nvaneris_pax_v1_lt_bnum_ nvldrs_uid)
(lambda () nvx1))
(lambda () nvx2)))
(if (inr-p dec)
(nvbfalse)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(if (inr-p dec)
(nvisl (funcall nvbn2))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))

(defun nvaneris_pax_v1_upd_bnum ()
(lambda (nvbnum)
(lambda (nvloc)
(let ((dec (funcall nvbnum)))
(if (inl-p dec)
(let ((nvz (inl-val dec)))
(let ((pair nvz))
(let ((nvr (pair-fst pair))
(nvl (pair-snd pair)))
(declare (ignore nvl))
(funcall (funcall (nvaneris_pax_v1_mk_bnum)
(lambda () (+ nvr 1)))
(lambda () (funcall nvloc))))))
(if (inr-p dec)
(funcall nvbnum)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))

(defun nvaneris_pax_v1_when_preempted (nvCmd nvldrs_uid)
(declare (ignore nvCmd))
(lambda (nvldr)
(lambda (nvbnum)
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz_ (pair-snd pair)))
(if (inl-p (nvband (funcall (nvaneris_pax_v1_is_bnum)
(lambda () (funcall nvbnum))) (funcall (funcall (nvaneris_pax_v1_lt_bnum nvldrs_uid)
(lambda () nvw))
(lambda () (funcall nvbnum)))))
(make-pair :fst (funcall (funcall (nvaneris_pax_v1_upd_bnum)
(lambda () (funcall nvbnum)))
(lambda () (funcall nvldr))) :snd (make-pair :fst (nvbfalse) :snd (make-pair :fst nvy :snd nvz_)))
(make-pair :fst nvw :snd (make-pair :fst nvx :snd (make-pair :fst nvy :snd nvz_))))))))))))))

(defun nvaneris_pax_v1_preempted_base-program (nvCmd nvdecision nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvmf))
(nvbase-class-program (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "preempted" :snd (make-axiom)))))

(defun nvremove-combine (nvcmp nvl)
(funcall (fix "nvlist_ind" (lambda (nvlist_ind)
(lambda (nvL)
(let ((nvv (funcall nvL)))
(if (pair-p nvv)
(let ((pair nvv))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(let ((nvtst (funcall nvcmp
(lambda () nvh))))
(if (inl-p (nveq_int nvtst 0))
nvt
(if (inl-p (nvlt_int 0 nvtst))
(make-pair :fst nvh :snd nvt)
(make-pair :fst nvh :snd (funcall (funcall nvlist_ind)
(lambda () nvt))))))))
(if (axiom-p nvv)
(make-axiom)
(error "bottom")))))))
(lambda () nvl)))

(defun nvaneris_pax_v1_filter_out_proposals (nvCmd)
(lambda (nvslt)
(lambda (nvproposals)
(nvremove-combine (lambda (nvprp)
(- (funcall nvslt) (funcall (nvaneris_pax_v1_prp2slt nvCmd)
(lambda () (funcall nvprp))))) (funcall nvproposals)))))

(defun nvaneris_pax_v1_remove_from_missing ()
(lambda (nvslt)
(lambda (nvmissing)
(nvremove-combine (lambda (nvn)
(- (funcall nvn) (funcall nvslt))) (funcall nvmissing)))))

(defun nvaneris_pax_v1_add_slot_to_decided ()
(lambda (nvslt)
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvmax (pair-fst pair))
(nvmissing (pair-snd pair)))
(if (inl-p (nvlt_int nvmax (funcall nvslt)))
(make-pair :fst (funcall nvslt) :snd (nvappend nvmissing (nvfrom-upto (+ nvmax 1) (funcall nvslt))))
(if (inl-p (nveq_int (funcall nvslt) nvmax))
(make-pair :fst nvmax :snd nvmissing)
(make-pair :fst nvmax :snd (funcall (funcall (nvaneris_pax_v1_remove_from_missing)
(lambda () (funcall nvslt)))
(lambda () nvmissing))))))))))

(defun nvaneris_pax_v1_when_decided (nvCmd)
(lambda (nvldr)
(declare (ignore nvldr))
(lambda (nvslt)
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz_ (pair-snd pair)))
(let ((nvproposals_ (funcall (funcall (nvaneris_pax_v1_filter_out_proposals nvCmd)
(lambda () (funcall nvslt)))
(lambda () nvy))))
(let ((nvdecided_ (funcall (funcall (nvaneris_pax_v1_add_slot_to_decided)
(lambda () (funcall nvslt)))
(lambda () nvz_))))
(make-pair :fst nvw :snd (make-pair :fst nvx :snd (make-pair :fst nvproposals_ :snd nvdecided_)))))))))))))))

(defun nvaneris_pax_v1_decided_base-program (nvCmd nvdecision nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvmf))
(nvbase-class-program (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "decided" :snd (make-axiom)))))

(defun nvmemory-class4-program (nvinit nvtr1 nvpr1 nvtr2 nvpr2 nvtr3 nvpr3 nvtr4 nvpr4)
(nvloop-class-memory-program (nvparallel-class-program (nveclass1-program nvtr1 nvpr1) (nvparallel-class-program (nveclass1-program nvtr2 nvpr2) (nvparallel-class-program (nveclass1-program nvtr3 nvpr3) (nveclass1-program nvtr4 nvpr4)))) (lambda (nvloc)
(nvsingle-bag (funcall nvinit
(lambda () (funcall nvloc)))))))

(defun nvaneris_pax_v1_LeaderState-program (nvCmd nvdecision nvldrs_uid nvpropose nvmf)
(nvmemory-class4-program (nvaneris_pax_v1_init_leader nvCmd) (nvaneris_pax_v1_on_propose nvCmd) (nvaneris_pax_v1_propose_base-program nvCmd nvdecision nvpropose nvmf) (nvaneris_pax_v1_when_adopted nvCmd) (nvaneris_pax_v1_adopted_base-program nvCmd nvdecision nvpropose nvmf) (nvaneris_pax_v1_when_preempted nvCmd nvldrs_uid) (nvaneris_pax_v1_preempted_base-program nvCmd nvdecision nvpropose nvmf) (nvaneris_pax_v1_when_decided nvCmd) (nvaneris_pax_v1_decided_base-program nvCmd nvdecision nvpropose nvmf)))

(defun nvaneris_pax_v1_LeaderPropose-program (nvCmd nvdecision nvldrs_uid nvpropose nvmf)
(nveclass2-program (nveclass1-program (nvaneris_pax_v1_leader_propose nvCmd) (nvaneris_pax_v1_propose_base-program nvCmd nvdecision nvpropose nvmf)) (nvaneris_pax_v1_LeaderState-program nvCmd nvdecision nvldrs_uid nvpropose nvmf)))

(defun nvcons-bag (nvx nvb)
(make-pair :fst nvx :snd nvb))

(defun nvaneris_pax_v1_leader_adopted (nvCmd)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvzp)
(lambda (nvz)
(let ((pair (funcall nvzp)))
(let ((nvbnum (pair-fst pair))
(nvpvals (pair-snd pair)))
(let ((pair (funcall nvz)))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(declare (ignore nvx))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz_ (pair-snd pair)))
(if (inl-p (funcall (funcall (nvaneris_pax_v1_eq_bnums)
(lambda () nvbnum))
(lambda () nvw)))
(funcall (funcall (fix "nvlist_accum" (lambda (nvlist_accum)
(lambda (nvy_)
(lambda (nvL)
(let ((nvv (funcall nvL)))
(if (pair-p nvv)
(let ((pair nvv))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(funcall (funcall (funcall nvlist_accum)
(lambda () (nvcons-bag (funcall (funcall (nvaneris_pax_v1_mk_pv nvCmd)
(lambda () nvbnum))
(lambda () nvh)) (funcall nvy_))))
(lambda () nvt))))
(if (axiom-p nvv)
(funcall nvy_)
(error "bottom"))))))))
(lambda () (make-axiom)))
(lambda () (funcall (funcall (funcall (nvaneris_pax_v1_update_proposals nvCmd)
(lambda () nvy))
(lambda () nvz_))
(lambda () nvpvals))))
(make-axiom))))))))))))))

(defun nvaneris_pax_v1_LeaderAdopted-program (nvCmd nvdecision nvldrs_uid nvpropose nvmf)
(nveclass2-program (nveclass1-program (nvaneris_pax_v1_leader_adopted nvCmd) (nvaneris_pax_v1_adopted_base-program nvCmd nvdecision nvpropose nvmf)) (nvaneris_pax_v1_LeaderState-program nvCmd nvdecision nvldrs_uid nvpropose nvmf)))

(defun nvaneris_pax_v1_p2a_broadcast (nvCmd nvdecision nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvmf))
(lambda (nvlocs)
(lambda (nvz)
(nvbag-map (lambda (nvl)
(nvmk-msg-interface (funcall nvl) (nvmake-Msg (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p2a" :snd (make-axiom))) (funcall nvz)))) (funcall nvlocs)))))

(defun nvaneris_pax_v1_CommanderNotify-program (nvCmd nvaccpts nvdecision nvpropose nvmf)
(lambda (nvpvalue)
(nvreturn-loc-bag-class-program (lambda (nvldr)
(funcall (funcall (nvaneris_pax_v1_p2a_broadcast nvCmd nvdecision nvpropose nvmf)
(lambda () nvaccpts))
(lambda () (make-pair :fst (funcall nvldr) :snd (funcall nvpvalue))))))))

(defun nvaneris_pax_v1_decision_broadcast (nvCmd nvdecision nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvpropose))
(declare (ignore nvmf))
(lambda (nvlocs)
(lambda (nvz)
(nvbag-map (lambda (nvl)
(nvmk-msg-interface (funcall nvl) (nvmake-Msg nvdecision (funcall nvz)))) (funcall nvlocs)))))

(defun nvaneris_pax_v1_decided_broadcast (nvCmd nvdecision nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvmf))
(lambda (nvlocs)
(lambda (nvz)
(nvbag-map (lambda (nvl)
(nvmk-msg-interface (funcall nvl) (nvmake-Msg (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "decided" :snd (make-axiom))) (funcall nvz)))) (funcall nvlocs)))))

(defun nvaneris_pax_v1_commander_output (nvCmd nvaccpts nvdecision nvldrs nvpropose nvreps nvmf)
(lambda (nvpvalue)
(lambda (nvldr)
(lambda (nvz)
(lambda (nvwaitfor)
(let ((pair (funcall nvz)))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(declare (ignore nvw))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz_ (pair-snd pair)))
(let ((pair (funcall (nvaneris_pax_v1_dest_pv nvCmd)
(lambda () (funcall nvpvalue)))))
(let ((nvx_ (pair-fst pair))
(nvzz (pair-snd pair)))
(let ((pair nvzz))
(let ((nvy_ (pair-fst pair))
(nvz (pair-snd pair)))
(if (inl-p (nvband (funcall (funcall (nvaneris_pax_v1_eq_bnums)
(lambda () nvx_))
(lambda () nvx)) (nveq_int nvy_ nvy)))
(if (inl-p (funcall (funcall (nvaneris_pax_v1_eq_bnums)
(lambda () nvx_))
(lambda () nvz_)))
(if (inl-p (nvlt_int (nvbag-size (funcall nvwaitfor)) (nvaneris_pax_v1_threshold nvaccpts)))
(nvbag-append (funcall (funcall (nvaneris_pax_v1_decision_broadcast nvCmd nvdecision nvpropose nvmf)
(lambda () nvreps))
(lambda () (funcall (funcall (nvaneris_pax_v1_mk_prp nvCmd)
(lambda () nvy_))
(lambda () nvz)))) (funcall (funcall (nvaneris_pax_v1_decided_broadcast nvCmd nvdecision nvpropose nvmf)
(lambda () nvldrs))
(lambda () nvy_)))
(make-axiom))
(nvsingle-bag (funcall (funcall (nvaneris_pax_v1_preempted_send nvCmd nvdecision nvpropose nvmf)
(lambda () (funcall nvldr)))
(lambda () nvz_))))
(make-axiom)))))))))))))))))

(defun nvaneris_pax_v1_p2b_base-program (nvCmd nvdecision nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvmf))
(nvbase-class-program (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p2b" :snd (make-axiom)))))

(defun nvaneris_pax_v1_on_p2b ()
(lambda (nvbnum)
(lambda (nvslt)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvz)
(lambda (nvwaitfor)
(let ((pair (funcall nvz)))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz_ (pair-snd pair)))
(if (inl-p (nvband (funcall (funcall (nvaneris_pax_v1_eq_bnums)
(lambda () (funcall nvbnum)))
(lambda () nvx)) (nvband (nveq_int (funcall nvslt) nvy) (funcall (funcall (nvaneris_pax_v1_eq_bnums)
(lambda () (funcall nvbnum)))
(lambda () nvz_)))))
(nvbag-remove (lambda (nva)
(lambda (nvb)
(if (string= (funcall nva) (funcall nvb))
(make-inl :val (make-axiom))
(make-inr :val (make-axiom))))) (funcall nvwaitfor) nvw)
(funcall nvwaitfor))))))))))))))

(defun nvaneris_pax_v1_CommanderState-program (nvCmd nvaccpts nvdecision nvpropose nvmf)
(lambda (nvbn)
(lambda (nvs)
(nvstate-class1-program (lambda (nvloc)
(declare (ignore nvloc))
nvaccpts) (funcall (funcall (nvaneris_pax_v1_on_p2b)
(lambda () (funcall nvbn)))
(lambda () (funcall nvs))) (nvaneris_pax_v1_p2b_base-program nvCmd nvdecision nvpropose nvmf)))))

(defun nvaneris_pax_v1_CommanderOutput-program (nvCmd nvaccpts nvdecision nvldrs nvpropose nvreps nvmf)
(lambda (nvpvalue)
(let ((pair (funcall (nvaneris_pax_v1_dest_pv nvCmd)
(lambda () (funcall nvpvalue)))))
(let ((nvx (pair-fst pair))
(nvzz (pair-snd pair)))
(let ((pair nvzz))
(let ((nvy (pair-fst pair))
(nvz (pair-snd pair)))
(declare (ignore nvz))
(nvonce-class-program (nveclass2-program (nveclass1-program (funcall (nvaneris_pax_v1_commander_output nvCmd nvaccpts nvdecision nvldrs nvpropose nvreps nvmf)
(lambda () (funcall nvpvalue))) (nvaneris_pax_v1_p2b_base-program nvCmd nvdecision nvpropose nvmf)) (funcall (funcall (nvaneris_pax_v1_CommanderState-program nvCmd nvaccpts nvdecision nvpropose nvmf)
(lambda () nvx))
(lambda () nvy))))))))))

(defun nvaneris_pax_v1_Commander-program (nvCmd nvaccpts nvdecision nvldrs nvpropose nvreps nvmf)
(lambda (nvpvalue)
(nvparallel-class-program (funcall (nvaneris_pax_v1_CommanderNotify-program nvCmd nvaccpts nvdecision nvpropose nvmf)
(lambda () (funcall nvpvalue))) (funcall (nvaneris_pax_v1_CommanderOutput-program nvCmd nvaccpts nvdecision nvldrs nvpropose nvreps nvmf)
(lambda () (funcall nvpvalue))))))

(defun nvaneris_pax_v1_leader_preempted (nvCmd nvldrs_uid)
(declare (ignore nvCmd))
(lambda (nvldr)
(lambda (nvbnum)
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(declare (ignore nvx))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz_ (pair-snd pair)))
(declare (ignore nvy))
(declare (ignore nvz_))
(if (inl-p (nvband (funcall (nvaneris_pax_v1_is_bnum)
(lambda () (funcall nvbnum))) (funcall (funcall (nvaneris_pax_v1_lt_bnum nvldrs_uid)
(lambda () nvw))
(lambda () (funcall nvbnum)))))
(nvsingle-bag (funcall (funcall (nvaneris_pax_v1_upd_bnum)
(lambda () (funcall nvbnum)))
(lambda () (funcall nvldr))))
(make-axiom))))))))))))

(defun nvaneris_pax_v1_LeaderPreempted-program (nvCmd nvdecision nvldrs_uid nvpropose nvmf)
(nveclass2-program (nveclass1-program (nvaneris_pax_v1_leader_preempted nvCmd nvldrs_uid) (nvaneris_pax_v1_preempted_base-program nvCmd nvdecision nvpropose nvmf)) (nvaneris_pax_v1_LeaderState-program nvCmd nvdecision nvldrs_uid nvpropose nvmf)))

(defun nvaneris_pax_v1_pong_send (nvCmd nvdecision nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvmf))
(lambda (nvl)
(lambda (nvz)
(nvmk-msg-interface (funcall nvl) (nvmake-Msg (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "pong" :snd (make-axiom))) (funcall nvz))))))

(defun nvaneris_pax_v1_ping_base-program (nvCmd nvdecision nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvmf))
(nvbase-class-program (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "ping" :snd (make-axiom)))))

(defun nvaneris_pax_v1_Leader-program (nvCmd nvaccpts nvdecision nvldrs nvldrs_uid nvpropose nvreps nvmf)
(nvparallel-class-program (nvparallel-class-program (nvparallel-class-program (nvparallel-class-program (nvbind-class-program (nvaneris_pax_v1_HigherLeader-program nvCmd nvdecision nvldrs nvldrs_uid nvpropose nvmf) (lambda (nvz)
(funcall (nvaneris_pax_v1_LeaderStart-program nvCmd nvaccpts nvdecision nvldrs_uid nvpropose nvmf)
(lambda () (funcall nvz))))) (nvbind-class-program (nvonce-class-program (nvaneris_pax_v1_start_base-program nvCmd nvdecision nvpropose nvmf)) (lambda (nvz)
(declare (ignore nvz))
(nvaneris_pax_v1_SpawnFirstScout-program nvCmd nvaccpts nvdecision nvldrs_uid nvpropose nvmf)))) (nvbind-class-program (nvparallel-class-program (nvaneris_pax_v1_LeaderPropose-program nvCmd nvdecision nvldrs_uid nvpropose nvmf) (nvaneris_pax_v1_LeaderAdopted-program nvCmd nvdecision nvldrs_uid nvpropose nvmf)) (lambda (nvz)
(funcall (nvaneris_pax_v1_Commander-program nvCmd nvaccpts nvdecision nvldrs nvpropose nvreps nvmf)
(lambda () (funcall nvz)))))) (nvbind-class-program (nvaneris_pax_v1_LeaderPreempted-program nvCmd nvdecision nvldrs_uid nvpropose nvmf) (lambda (nvz)
(funcall (nvaneris_pax_v1_Scout-program nvCmd nvaccpts nvdecision nvldrs_uid nvpropose nvmf)
(lambda () (funcall nvz)))))) (nveclass0-program (lambda (nvz)
(declare (ignore nvz))
(lambda (nvloc)
(nvsingle-bag (funcall (funcall (nvaneris_pax_v1_pong_send nvCmd nvdecision nvpropose nvmf)
(lambda () (funcall nvloc)))
(lambda () (make-axiom)))))) (nvaneris_pax_v1_ping_base-program nvCmd nvdecision nvpropose nvmf))))

(defun nvaneris_pax_v1_p1b_send (nvCmd nvdecision nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvmf))
(lambda (nvl)
(lambda (nvz)
(nvmk-msg-interface (funcall nvl) (nvmake-Msg (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p1b" :snd (make-axiom))) (funcall nvz))))))

(defun nvaneris_pax_v1_p1a_base-program (nvCmd nvdecision nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvmf))
(nvbase-class-program (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p1a" :snd (make-axiom)))))

(defun nvaneris_pax_v1_dummy_ballot ()
(make-inr :val (make-axiom)))

(defun nvaneris_pax_v1_init_accepted (nvCmd)
(declare (ignore nvCmd))
(make-axiom))

(defun nvaneris_pax_v1_init_acceptor (nvCmd)
(make-pair :fst (nvaneris_pax_v1_dummy_ballot) :snd (nvaneris_pax_v1_init_accepted nvCmd)))

(defun nvaneris_pax_v1_max_bnum (nvldrs_uid)
(lambda (nvbn1)
(lambda (nvbn2)
(if (inl-p (funcall (funcall (nvaneris_pax_v1_leq_bnum nvldrs_uid)
(lambda () (funcall nvbn1)))
(lambda () (funcall nvbn2))))
(funcall nvbn2)
(funcall nvbn1)))))

(defun nvaneris_pax_v1_on_p1a (nvCmd nvldrs_uid)
(declare (ignore nvCmd))
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvze)
(lambda (nvz)
(let ((pair (funcall nvze)))
(let ((nvloc (pair-fst pair))
(nvbnum (pair-snd pair)))
(declare (ignore nvloc))
(let ((pair (funcall nvz)))
(let ((nvballot_num (pair-fst pair))
(nvaccepted (pair-snd pair)))
(make-pair :fst (funcall (funcall (nvaneris_pax_v1_max_bnum nvldrs_uid)
(lambda () nvbnum))
(lambda () nvballot_num)) :snd nvaccepted)))))))))

(defun nvaneris_pax_v1_on_p2a (nvCmd nvldrs_uid)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvzf)
(lambda (nvz)
(let ((pair (funcall nvzf)))
(let ((nvloc (pair-fst pair))
(nvpvalue (pair-snd pair)))
(declare (ignore nvloc))
(let ((pair (funcall nvz)))
(let ((nvballot_num (pair-fst pair))
(nvaccepted (pair-snd pair)))
(let ((nvbn (funcall (nvaneris_pax_v1_pv2bn nvCmd)
(lambda () nvpvalue))))
(let ((nvballot_num_ (funcall (funcall (nvaneris_pax_v1_max_bnum nvldrs_uid)
(lambda () nvbn))
(lambda () nvballot_num))))
(let ((nvaccepted_ (if (inl-p (funcall (funcall (nvaneris_pax_v1_leq_bnum nvldrs_uid)
(lambda () nvballot_num))
(lambda () nvbn)))
(funcall (funcall (nvaneris_pax_v1_add_pvalue nvCmd nvldrs_uid)
(lambda () nvaccepted))
(lambda () nvpvalue))
nvaccepted)))
(make-pair :fst nvballot_num_ :snd nvaccepted_))))))))))))

(defun nvaneris_pax_v1_p2a_base-program (nvCmd nvdecision nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvmf))
(nvbase-class-program (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p2a" :snd (make-axiom)))))

(defun nvstate-class2-program (nvinit nvtr1 nvpr1 nvtr2 nvpr2)
(nvloop-class-state-program (nvparallel-class-program (nveclass1-program nvtr1 nvpr1) (nveclass1-program nvtr2 nvpr2)) (lambda (nvloc)
(nvsingle-bag (funcall nvinit
(lambda () (funcall nvloc)))))))

(defun nvaneris_pax_v1_AcceptorState-program (nvCmd nvdecision nvldrs_uid nvpropose nvmf)
(nvstate-class2-program (lambda (nvloc)
(declare (ignore nvloc))
(nvaneris_pax_v1_init_acceptor nvCmd)) (nvaneris_pax_v1_on_p1a nvCmd nvldrs_uid) (nvaneris_pax_v1_p1a_base-program nvCmd nvdecision nvpropose nvmf) (nvaneris_pax_v1_on_p2a nvCmd nvldrs_uid) (nvaneris_pax_v1_p2a_base-program nvCmd nvdecision nvpropose nvmf)))

(defun nvaneris_pax_v1_AcceptorsP1a-program (nvCmd nvdecision nvldrs_uid nvpropose nvmf)
(let ((nvf (lambda (nvloc)
(lambda (nvzh)
(lambda (nvz)
(let ((pair (funcall nvzh)))
(let ((nvldr (pair-fst pair))
(nvbn (pair-snd pair)))
(let ((pair (funcall nvz)))
(let ((nvbnum (pair-fst pair))
(nvpvals (pair-snd pair)))
(nvsingle-bag (funcall (funcall (nvaneris_pax_v1_p1b_send nvCmd nvdecision nvpropose nvmf)
(lambda () nvldr))
(lambda () (make-pair :fst (funcall nvloc) :snd (make-pair :fst nvbn :snd (make-pair :fst nvbnum :snd nvpvals)))))))))))))))
(nveclass2-program (nveclass1-program nvf (nvaneris_pax_v1_p1a_base-program nvCmd nvdecision nvpropose nvmf)) (nvaneris_pax_v1_AcceptorState-program nvCmd nvdecision nvldrs_uid nvpropose nvmf))))

(defun nvaneris_pax_v1_p2b_send (nvCmd nvdecision nvpropose nvmf)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvmf))
(lambda (nvl)
(lambda (nvz)
(nvmk-msg-interface (funcall nvl) (nvmake-Msg (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p2b" :snd (make-axiom))) (funcall nvz))))))

(defun nvaneris_pax_v1_AcceptorsP2a-program (nvCmd nvdecision nvldrs_uid nvpropose nvmf)
(let ((nvf (lambda (nvloc)
(lambda (nvzi)
(lambda (nvz)
(let ((pair (funcall nvzi)))
(let ((nvldr (pair-fst pair))
(nvpvalue (pair-snd pair)))
(let ((pair (funcall nvz)))
(let ((nvbnum (pair-fst pair))
(nvz (pair-snd pair)))
(declare (ignore nvz))
(let ((pair (funcall (nvaneris_pax_v1_dest_pv nvCmd)
(lambda () nvpvalue))))
(let ((nvx (pair-fst pair))
(nvzz (pair-snd pair)))
(let ((pair nvzz))
(let ((nvy (pair-fst pair))
(nvz (pair-snd pair)))
(declare (ignore nvz))
(nvsingle-bag (funcall (funcall (nvaneris_pax_v1_p2b_send nvCmd nvdecision nvpropose nvmf)
(lambda () nvldr))
(lambda () (make-pair :fst (funcall nvloc) :snd (make-pair :fst nvx :snd (make-pair :fst nvy :snd nvbnum)))))))))))))))))))
(nveclass2-program (nveclass1-program nvf (nvaneris_pax_v1_p2a_base-program nvCmd nvdecision nvpropose nvmf)) (nvaneris_pax_v1_AcceptorState-program nvCmd nvdecision nvldrs_uid nvpropose nvmf))))

(defun nvaneris_pax_v1_Acceptor-program (nvCmd nvdecision nvldrs_uid nvpropose nvmf)
(nvparallel-class-program (nvaneris_pax_v1_AcceptorsP1a-program nvCmd nvdecision nvldrs_uid nvpropose nvmf) (nvaneris_pax_v1_AcceptorsP2a-program nvCmd nvdecision nvldrs_uid nvpropose nvmf)))

(defun nvaneris_pax_v1_main-program (nvCmd nvaccpts nvdecision nvldrs nvldrs_uid nvpropose nvreps nvmf)
(nvparallel-class-program (nvclass-at-program (nvaneris_pax_v1_Leader-program nvCmd nvaccpts nvdecision nvldrs nvldrs_uid nvpropose nvreps nvmf) nvldrs) (nvclass-at-program (nvaneris_pax_v1_Acceptor-program nvCmd nvdecision nvldrs_uid nvpropose nvmf) nvaccpts)))

(defun nvaneris_control_aneris_pax_v1_main-program (nvOp nvaccpts nvldrs nvldrs_uid nvreps nvmf)
(declare (ignore nvOp))
(nvaneris_pax_v1_main-program "UNION" nvaccpts (make-pair :fst "decision" :snd (make-axiom)) nvldrs nvldrs_uid (make-pair :fst "pv11_p1" :snd (make-pair :fst "propose" :snd (make-axiom))) nvreps nvmf))

(defun nvaneris_batch_init_slot_num ()
1)

(defun nvaneris_batch_init_active ()
(nvbfalse))

(defun nvaneris_batch_init_atimer ()
(nvbfalse))

(defun nvaneris_batch_init_proposals (nvOp)
(declare (ignore nvOp))
(make-axiom))

(defun nvaneris_batch_init_decisions ()
(make-pair :fst 0 :snd (make-axiom)))

(defun nvaneris_batch_init_todo (nvOp)
(declare (ignore nvOp))
(make-axiom))

(defun nvaneris_batch_init_protocol ()
(make-pair :fst "paxos" :snd (make-axiom)))

(defun nvaneris_batch_init_state (nvOp)
(make-pair :fst (nvaneris_batch_init_slot_num) :snd (make-pair :fst (nvaneris_batch_init_active) :snd (make-pair :fst (nvaneris_batch_init_atimer) :snd (make-pair :fst (nvaneris_batch_init_proposals nvOp) :snd (make-pair :fst (nvaneris_batch_init_decisions) :snd (make-pair :fst (nvaneris_batch_init_todo nvOp) :snd (nvaneris_batch_init_protocol))))))))

(defun nvaneris_batch_out_tr (nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtimer nvtt_propose nvmf)
(declare (ignore nvOp))
(declare (ignore nvbcast))
(declare (ignore nvdecision))
(declare (ignore nvpax_propose))
(declare (ignore nvresponse))
(declare (ignore nvswap))
(declare (ignore nvtimer))
(declare (ignore nvtt_propose))
(declare (ignore nvmf))
(lambda (nvtr)
(lambda (nvloc)
(lambda (nvx)
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nva (pair-fst pair))
(nvz (pair-snd pair)))
(declare (ignore nvz))
(funcall (funcall (funcall (funcall nvtr)
(lambda () (funcall nvloc)))
(lambda () (funcall nvx)))
(lambda () nva)))))))))

(defun nvaneris_batch_command_tag2cid (nvOp)
(declare (ignore nvOp))
(lambda (nvcmdt)
(let ((dec (funcall nvcmdt)))
(if (inl-p dec)
(let ((nvz (inl-val dec)))
(let ((pair nvz))
(let ((nvcid (pair-fst pair))
(nvx (pair-snd pair)))
(declare (ignore nvx))
nvcid)))
(if (inr-p dec)
(let ((nvz (inr-val dec)))
(let ((pair nvz))
(let ((nvcid (pair-fst pair))
(nvx (pair-snd pair)))
(declare (ignore nvx))
nvcid)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))

(defun nvaneris_batch_is_in_missing ()
(lambda (nvcid)
(lambda (nvmissing)
(nvreduce (lambda (nvh)
(lambda (nvr)
(if (inl-p (nvlt_int (funcall nvcid) (funcall nvh)))
(nvbfalse)
(if (inl-p (nveq_int (funcall nvcid) (funcall nvh)))
(nvbtrue)
(funcall nvr))))) (nvbfalse) (funcall nvmissing)))))

(defun nvaneris_batch_is_decision (nvOp)
(lambda (nvcmdt)
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvmax (pair-fst pair))
(nvmissing (pair-snd pair)))
(let ((nvcid (funcall (nvaneris_batch_command_tag2cid nvOp)
(lambda () (funcall nvcmdt)))))
(nvband (nvle_int nvcid nvmax) (nvbnot (funcall (funcall (nvaneris_batch_is_in_missing)
(lambda () nvcid))
(lambda () nvmissing))))))))))

(defun nvaneris_batch_protocol2num ()
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvcid (pair-fst pair))
(nvz (pair-snd pair)))
(declare (ignore nvz))
(+ (* 2 nvcid) 1)))))

(defun nvaneris_batch_command2num (nvOp)
(declare (ignore nvOp))
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvcid (pair-fst pair))
(nvz (pair-snd pair)))
(declare (ignore nvz))
(* 2 nvcid)))))

(defun nvaneris_batch_command_tag2num (nvOp)
(lambda (nvcmdt)
(let ((dec (funcall nvcmdt)))
(if (inl-p dec)
(let ((nvnp (inl-val dec)))
(funcall (nvaneris_batch_protocol2num)
(lambda () nvnp)))
(if (inr-p dec)
(let ((nvcmd (inr-val dec)))
(funcall (nvaneris_batch_command2num nvOp)
(lambda () nvcmd)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))

(defun nvoutl (nvx)
(let ((dec nvx))
(if (inl-p dec)
(let ((nvy (inl-val dec)))
nvy)
(if (inr-p dec)
(error "bottom")
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))

(defun nvoutr (nvx)
(let ((dec nvx))
(if (inl-p dec)
(error "bottom")
(if (inr-p dec)
(let ((nvz (inr-val dec)))
nvz)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))

(defun nvaneris_batch_is_todo (nvOp)
(lambda (nvcmdt)
(lambda (nvtodo)
(let ((nvn (funcall (nvaneris_batch_command_tag2num nvOp)
(lambda () (funcall nvcmdt)))))
(nvreduce (lambda (nvx)
(lambda (nvp)
(nvbor (let ((pair (funcall nvx)))
(let ((nvslt (pair-fst pair))
(nvcmdts (pair-snd pair)))
(declare (ignore nvslt))
(if (inl-p (nvisl nvcmdts))
(nveq_int nvn (funcall (nvaneris_batch_protocol2num)
(lambda () (nvoutl nvcmdts))))
(nvreduce (lambda (nvx)
(lambda (nvp)
(nvbor (nveq_int nvn (funcall (nvaneris_batch_command2num nvOp)
(lambda () (funcall nvx)))) (funcall nvp)))) (nvbfalse) (nvoutr nvcmdts))))) (funcall nvp)))) (nvbfalse) (funcall nvtodo))))))

(defun nvaneris_batch_add_proposal_if_not_in (nvOp)
(lambda (nvcmdt)
(lambda (nvproposals)
(nvinsert-combine (nvint-minus-comparison (nvaneris_batch_command_tag2num nvOp)) (lambda (nvprp1)
(declare (ignore nvprp1))
(lambda (nvprp2)
(funcall nvprp2))) (funcall nvcmdt) (funcall nvproposals)))))

(defun nvaneris_batch_timer__send (nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtimer nvtt_propose nvmf)
(declare (ignore nvOp))
(declare (ignore nvbcast))
(declare (ignore nvdecision))
(declare (ignore nvpax_propose))
(declare (ignore nvresponse))
(declare (ignore nvswap))
(declare (ignore nvtt_propose))
(declare (ignore nvmf))
(lambda (nvn)
(lambda (nvl)
(lambda (nvz)
(nvmake-msg-interface (funcall nvn) (funcall nvl) (nvmake-Msg nvtimer (funcall nvz)))))))

(defun nvaneris_batch_propose_inj (nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtimeout nvtimer nvtt_propose nvmf)
(lambda (nvloc)
(lambda (nvcmdt)
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nva (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvb (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvc (pair-fst pair))
(nvzz3 (pair-snd pair)))
(let ((pair nvzz3))
(let ((nvd (pair-fst pair))
(nvzz4 (pair-snd pair)))
(let ((pair nvzz4))
(let ((nve (pair-fst pair))
(nvzz5 (pair-snd pair)))
(let ((pair nvzz5))
(let ((nvf (pair-fst pair))
(nvg (pair-snd pair)))
(if (inl-p (funcall (funcall (nvaneris_batch_is_decision nvOp)
(lambda () (funcall nvcmdt)))
(lambda () nve)))
(make-pair :fst (make-pair :fst nva :snd (make-pair :fst nvb :snd (make-pair :fst nvc :snd (make-pair :fst nvd :snd (make-pair :fst nve :snd (make-pair :fst nvf :snd nvg)))))) :snd (make-axiom))
(if (inl-p (funcall (funcall (nvaneris_batch_is_todo nvOp)
(lambda () (funcall nvcmdt)))
(lambda () nvf)))
(make-pair :fst (make-pair :fst nva :snd (make-pair :fst nvb :snd (make-pair :fst nvc :snd (make-pair :fst nvd :snd (make-pair :fst nve :snd (make-pair :fst nvf :snd nvg)))))) :snd (make-axiom))
(let ((nvproposals_ (funcall (funcall (nvaneris_batch_add_proposal_if_not_in nvOp)
(lambda () (funcall nvcmdt)))
(lambda () nvd))))
(let ((pair (if (inl-p nvb)
(make-pair :fst (make-axiom) :snd nvc)
(if (inl-p nvc)
(make-pair :fst (make-axiom) :snd nvc)
(make-pair :fst (nvsingle-bag (funcall (funcall (funcall (nvaneris_batch_timer__send nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtimer nvtt_propose nvmf)
(lambda () nvtimeout))
(lambda () (funcall nvloc)))
(lambda () (make-axiom)))) :snd (nvbtrue))))))
(let ((nvmsgs (pair-fst pair))
(nvatimer_ (pair-snd pair)))
(make-pair :fst (make-pair :fst nva :snd (make-pair :fst nvb :snd (make-pair :fst nvatimer_ :snd (make-pair :fst nvproposals_ :snd (make-pair :fst nve :snd (make-pair :fst nvf :snd nvg)))))) :snd nvmsgs))))))))))))))))))))))

(defun nvaneris_batch_propose_inl (nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtimeout nvtimer nvtt_propose nvmf)
(lambda (nvloc)
(lambda (nvnp)
(lambda (nvstate)
(funcall (funcall (funcall (nvaneris_batch_propose_inj nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtimeout nvtimer nvtt_propose nvmf)
(lambda () (funcall nvloc)))
(lambda () (make-inl :val (funcall nvnp))))
(lambda () (funcall nvstate)))))))

(defun nvaneris_batch_swap_base-program (nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtimer nvtt_propose nvmf)
(declare (ignore nvOp))
(declare (ignore nvbcast))
(declare (ignore nvdecision))
(declare (ignore nvpax_propose))
(declare (ignore nvresponse))
(declare (ignore nvtimer))
(declare (ignore nvtt_propose))
(declare (ignore nvmf))
(nvbase-class-program nvswap))

(defun nvaneris_batch_propose_inr (nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtimeout nvtimer nvtt_propose nvmf)
(lambda (nvloc)
(lambda (nvcmd)
(lambda (nvstate)
(funcall (funcall (funcall (nvaneris_batch_propose_inj nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtimeout nvtimer nvtt_propose nvmf)
(lambda () (funcall nvloc)))
(lambda () (make-inr :val (funcall nvcmd))))
(lambda () (funcall nvstate)))))))

(defun nvaneris_batch_bcast_base-program (nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtimer nvtt_propose nvmf)
(declare (ignore nvOp))
(declare (ignore nvdecision))
(declare (ignore nvpax_propose))
(declare (ignore nvresponse))
(declare (ignore nvswap))
(declare (ignore nvtimer))
(declare (ignore nvtt_propose))
(declare (ignore nvmf))
(nvbase-class-program nvbcast))

(defun nvhd (nvl)
(nvpi1 nvl))

(defun nvaneris_batch_get_batch (nvOp)
(declare (ignore nvOp))
(lambda (nvproposals)
(let ((nvh (nvhd (funcall nvproposals))))
(if (inl-p (nvisl nvh))
(make-inl :val (nvoutl nvh))
(let ((nvcmds (funcall (fix "nvlist_ind" (lambda (nvlist_ind)
(lambda (nvL)
(let ((nvv (funcall nvL)))
(if (pair-p nvv)
(let ((pair nvv))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(if (inl-p (nvisl nvh))
(make-axiom)
(nvappend (funcall (funcall nvlist_ind)
(lambda () nvt)) (make-pair :fst (let ((dec nvh))
(if (inl-p dec)
(error "bottom")
(if (inr-p dec)
(let ((nvz (inr-val dec)))
nvz)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))) :snd (make-axiom))))))
(if (axiom-p nvv)
(make-axiom)
(error "bottom")))))))
(lambda () (funcall nvproposals)))))
(make-inr :val nvcmds))))))

(defun nvaneris_batch_pax_propose_broadcast (nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtimer nvtt_propose nvmf)
(declare (ignore nvOp))
(declare (ignore nvbcast))
(declare (ignore nvdecision))
(declare (ignore nvresponse))
(declare (ignore nvswap))
(declare (ignore nvtimer))
(declare (ignore nvtt_propose))
(declare (ignore nvmf))
(lambda (nvlocs)
(lambda (nvz)
(nvbag-map (lambda (nvl)
(nvmk-msg-interface (funcall nvl) (nvmake-Msg nvpax_propose (funcall nvz)))) (funcall nvlocs)))))

(defun nvaneris_batch_tt_propose_broadcast (nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtimer nvtt_propose nvmf)
(declare (ignore nvOp))
(declare (ignore nvbcast))
(declare (ignore nvdecision))
(declare (ignore nvpax_propose))
(declare (ignore nvresponse))
(declare (ignore nvswap))
(declare (ignore nvtimer))
(declare (ignore nvmf))
(lambda (nvlocs)
(lambda (nvz)
(nvbag-map (lambda (nvl)
(nvmk-msg-interface (funcall nvl) (nvmake-Msg nvtt_propose (funcall nvz)))) (funcall nvlocs)))))

(defun nvaneris_batch_propose (nvOp nvbcast nvdecision nvpax_procs nvpax_propose nvresponse nvswap nvtimer nvtt_procs nvtt_propose nvmf)
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nva (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvb (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvc (pair-fst pair))
(nvzz3 (pair-snd pair)))
(let ((pair nvzz3))
(let ((nvd (pair-fst pair))
(nvzz4 (pair-snd pair)))
(let ((pair nvzz4))
(let ((nve (pair-fst pair))
(nvzz5 (pair-snd pair)))
(let ((pair nvzz5))
(let ((nvf (pair-fst pair))
(nvg (pair-snd pair)))
(if (inl-p (nvnull nvd))
(make-pair :fst (make-pair :fst nva :snd (make-pair :fst nvb :snd (make-pair :fst nvc :snd (make-pair :fst nvd :snd (make-pair :fst nve :snd (make-pair :fst nvf :snd nvg)))))) :snd (make-axiom))
(let ((nvmsgs (if (inl-p nvb)
(make-axiom)
(if (inl-p (funcall (funcall (nvlist-deq (nvatom-deq))
(lambda () nvg))
(lambda () (make-pair :fst "paxos" :snd (make-axiom)))))
(let ((nvbatch (funcall (nvaneris_batch_get_batch nvOp)
(lambda () nvd))))
(funcall (funcall (nvaneris_batch_pax_propose_broadcast nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtimer nvtt_propose nvmf)
(lambda () nvpax_procs))
(lambda () (make-pair :fst nva :snd nvbatch))))
(if (inl-p (funcall (funcall (nvlist-deq (nvatom-deq))
(lambda () nvg))
(lambda () (make-pair :fst "2/3" :snd (make-axiom)))))
(let ((nvbatch (funcall (nvaneris_batch_get_batch nvOp)
(lambda () nvd))))
(funcall (funcall (nvaneris_batch_tt_propose_broadcast nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtimer nvtt_propose nvmf)
(lambda () nvtt_procs))
(lambda () (make-pair :fst nva :snd nvbatch))))
(make-axiom))))))
(make-pair :fst (make-pair :fst nva :snd (make-pair :fst (nvbtrue) :snd (make-pair :fst nvc :snd (make-pair :fst nvd :snd (make-pair :fst nve :snd (make-pair :fst nvf :snd nvg)))))) :snd nvmsgs)))))))))))))))))

(defun nvaneris_batch_propose_bat (nvOp nvbcast nvdecision nvpax_procs nvpax_propose nvresponse nvswap nvtimer nvtt_procs nvtt_propose nvmf)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvzzd)
(declare (ignore nvzzd))
(lambda (nvstate)
(let ((pair (funcall (nvaneris_batch_propose nvOp nvbcast nvdecision nvpax_procs nvpax_propose nvresponse nvswap nvtimer nvtt_procs nvtt_propose nvmf)
(lambda () (funcall nvstate)))))
(let ((nvz (pair-fst pair))
(nvmsgs (pair-snd pair)))
(let ((pair nvz))
(let ((nva (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvb (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvc (pair-fst pair))
(nvzz3 (pair-snd pair)))
(declare (ignore nvc))
(let ((pair nvzz3))
(let ((nvd (pair-fst pair))
(nvzz4 (pair-snd pair)))
(let ((pair nvzz4))
(let ((nve (pair-fst pair))
(nvzz5 (pair-snd pair)))
(let ((pair nvzz5))
(let ((nvf (pair-fst pair))
(nvg (pair-snd pair)))
(make-pair :fst (make-pair :fst nva :snd (make-pair :fst nvb :snd (make-pair :fst (nvbfalse) :snd (make-pair :fst nvd :snd (make-pair :fst nve :snd (make-pair :fst nvf :snd nvg)))))) :snd nvmsgs)))))))))))))))))))

(defun nvaneris_batch_timer_base-program (nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtimer nvtt_propose nvmf)
(declare (ignore nvOp))
(declare (ignore nvbcast))
(declare (ignore nvdecision))
(declare (ignore nvpax_propose))
(declare (ignore nvresponse))
(declare (ignore nvswap))
(declare (ignore nvtt_propose))
(declare (ignore nvmf))
(nvbase-class-program nvtimer))

(defun nvaneris_batch_is_decided (nvOp)
(lambda (nvcmdts)
(lambda (nvdecisions)
(if (inl-p (nvisl (funcall nvcmdts)))
(funcall (funcall (nvaneris_batch_is_decision nvOp)
(lambda () (make-inl :val (nvoutl (funcall nvcmdts)))))
(lambda () (funcall nvdecisions)))
(nvreduce (lambda (nvcmd)
(lambda (nvb)
(if (inl-p (funcall (funcall (nvaneris_batch_is_decision nvOp)
(lambda () (make-inr :val (funcall nvcmd))))
(lambda () (funcall nvdecisions))))
(funcall nvb)
(nvbfalse)))) (nvbtrue) (nvoutr (funcall nvcmdts)))))))

(defun nvaneris_batch_dec2slt (nvOp)
(declare (ignore nvOp))
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvslt (pair-fst pair))
(nvz (pair-snd pair)))
(declare (ignore nvz))
nvslt))))

(defun nvint-minus-comparison-inc (nvf)
(lambda (nvx)
(lambda (nvy)
(- (funcall nvf
(lambda () (funcall nvy))) (funcall nvf
(lambda () (funcall nvx)))))))

(defun nvaneris_batch_add_todo (nvOp)
(lambda (nvslot_num)
(lambda (nvslt)
(lambda (nvcmdts)
(lambda (nvdecisions)
(lambda (nvtodo)
(if (inl-p (nvbor (nvlt_int (funcall nvslt) (funcall nvslot_num)) (funcall (funcall (nvaneris_batch_is_decided nvOp)
(lambda () (funcall nvcmdts)))
(lambda () (funcall nvdecisions)))))
(funcall nvtodo)
(nvinsert-combine (nvint-minus-comparison-inc (nvaneris_batch_dec2slt nvOp)) (lambda (nvprps1)
(declare (ignore nvprps1))
(lambda (nvprps2)
(funcall nvprps2))) (make-pair :fst (funcall nvslt) :snd (funcall nvcmdts)) (funcall nvtodo)))))))))

(defun nvaneris_batch_filter_out_proposal (nvOp)
(lambda (nvcmdt)
(lambda (nvproposals)
(let ((nvcid (funcall (nvaneris_batch_command_tag2cid nvOp)
(lambda () (funcall nvcmdt)))))
(nvremove-combine (lambda (nvcmdt)
(- nvcid (funcall (nvaneris_batch_command_tag2cid nvOp)
(lambda () (funcall nvcmdt))))) (funcall nvproposals))))))

(defun nvaneris_batch_filter_out_proposals (nvOp)
(lambda (nvcmdts)
(lambda (nvproposals)
(if (inl-p (nvisl (funcall nvcmdts)))
(funcall (funcall (nvaneris_batch_filter_out_proposal nvOp)
(lambda () (make-inl :val (nvoutl (funcall nvcmdts)))))
(lambda () (funcall nvproposals)))
(nvreduce (lambda (nvcmd)
(lambda (nvproposals)
(funcall (funcall (nvaneris_batch_filter_out_proposal nvOp)
(lambda () (make-inr :val (funcall nvcmd))))
(lambda () (funcall nvproposals))))) (funcall nvproposals) (nvoutr (funcall nvcmdts)))))))

(defun nvaneris_batch_iterate_tr (nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtimer nvtt_propose nvmf)
(declare (ignore nvOp))
(declare (ignore nvbcast))
(declare (ignore nvdecision))
(declare (ignore nvpax_propose))
(declare (ignore nvresponse))
(declare (ignore nvswap))
(declare (ignore nvtimer))
(declare (ignore nvtt_propose))
(declare (ignore nvmf))
(lambda (nvtr)
(lambda (nvinit)
(lambda (nvops)
(funcall (funcall (fix "nvlist_accum" (lambda (nvlist_accum)
(lambda (nvy)
(lambda (nvL)
(let ((nvv (funcall nvL)))
(if (pair-p nvv)
(let ((pair nvv))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(funcall (funcall (funcall nvlist_accum)
(lambda () (funcall (let ((pair (funcall nvy)))
(let ((nva (pair-fst pair))
(nvb (pair-snd pair)))
(lambda (nvx)
(let ((pair (funcall (funcall (funcall nvtr)
(lambda () (funcall nvx)))
(lambda () nva))))
(let ((nvs_ (pair-fst pair))
(nvb_ (pair-snd pair)))
(make-pair :fst nvs_ :snd (nvbag-append nvb nvb_)))))))
(lambda () nvh))))
(lambda () nvt))))
(if (axiom-p nvv)
(funcall nvy)
(error "bottom"))))))))
(lambda () (make-pair :fst (funcall nvinit) :snd (make-axiom))))
(lambda () (funcall nvops)))))))

(defun nvaneris_batch_filter_out_todo (nvOp)
(lambda (nvslt)
(lambda (nvtodo)
(nvremove-combine (lambda (nvx)
(- (funcall (nvaneris_batch_dec2slt nvOp)
(lambda () (funcall nvx))) (funcall nvslt))) (funcall nvtodo)))))

(defun nvaneris_batch_response_broadcast (nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtimer nvtt_propose nvmf)
(declare (ignore nvOp))
(declare (ignore nvbcast))
(declare (ignore nvdecision))
(declare (ignore nvpax_propose))
(declare (ignore nvswap))
(declare (ignore nvtimer))
(declare (ignore nvtt_propose))
(declare (ignore nvmf))
(lambda (nvlocs)
(lambda (nvz)
(nvbag-map (lambda (nvl)
(nvmk-msg-interface (funcall nvl) (nvmake-Msg nvresponse (funcall nvz)))) (funcall nvlocs)))))

(defun nvaneris_batch_perform (nvOp nvbcast nvclients nvdecision nvpax_propose nvresponse nvswap nvtimer nvtt_propose nvmf)
(lambda (nvcmdts)
(lambda (nvslot_num)
(lambda (nvprotocol)
(let ((nvprotocol_ (let ((dec (funcall nvcmdts)))
(if (inl-p dec)
(let ((nvz (inl-val dec)))
(let ((pair nvz))
(let ((nvcid (pair-fst pair))
(nvnew_protocol (pair-snd pair)))
(declare (ignore nvcid))
nvnew_protocol)))
(if (inr-p dec)
(funcall nvprotocol)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))
(make-pair :fst nvprotocol_ :snd (funcall (funcall (nvaneris_batch_response_broadcast nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtimer nvtt_propose nvmf)
(lambda () nvclients))
(lambda () (make-pair :fst (funcall nvslot_num) :snd (funcall nvcmdts))))))))))

(defun nvaneris_batch_remove_from_missing ()
(lambda (nvcid)
(lambda (nvmissing)
(nvremove-combine (lambda (nvn)
(- (funcall nvn) (funcall nvcid))) (funcall nvmissing)))))

(defun nvaneris_batch_add_decision (nvOp)
(lambda (nvslt)
(declare (ignore nvslt))
(lambda (nvcmdt)
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nvmax (pair-fst pair))
(nvmissing (pair-snd pair)))
(let ((nvcid (funcall (nvaneris_batch_command_tag2cid nvOp)
(lambda () (funcall nvcmdt)))))
(if (inl-p (nvlt_int nvmax nvcid))
(make-pair :fst nvcid :snd (nvappend nvmissing (nvfrom-upto (+ nvmax 1) nvcid)))
(if (inl-p (nveq_int nvcid nvmax))
(make-pair :fst nvmax :snd nvmissing)
(make-pair :fst nvmax :snd (funcall (funcall (nvaneris_batch_remove_from_missing)
(lambda () nvcid))
(lambda () nvmissing))))))))))))

(defun nvaneris_batch_add_decisions (nvOp)
(lambda (nvslt)
(lambda (nvcmdts)
(lambda (nvdecisions)
(if (inl-p (nvisl (funcall nvcmdts)))
(funcall (funcall (funcall (nvaneris_batch_add_decision nvOp)
(lambda () (funcall nvslt)))
(lambda () (make-inl :val (nvoutl (funcall nvcmdts)))))
(lambda () (funcall nvdecisions)))
(nvreduce (lambda (nvcmd)
(lambda (nvdecisions)
(funcall (funcall (funcall (nvaneris_batch_add_decision nvOp)
(lambda () (funcall nvslt)))
(lambda () (make-inr :val (funcall nvcmd))))
(lambda () (funcall nvdecisions))))) (funcall nvdecisions) (nvoutr (funcall nvcmdts))))))))

(defun nvaneris_batch_on_slot_num_cmd (nvOp nvbcast nvclients nvdecision nvpax_propose nvresponse nvswap nvtimer nvtt_propose nvmf)
(lambda (nvcmdts)
(lambda (nvz)
(let ((pair (funcall nvz)))
(let ((nva (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvb (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvc (pair-fst pair))
(nvzz3 (pair-snd pair)))
(let ((pair nvzz3))
(let ((nvd (pair-fst pair))
(nvzz4 (pair-snd pair)))
(let ((pair nvzz4))
(let ((nve (pair-fst pair))
(nvzz5 (pair-snd pair)))
(let ((pair nvzz5))
(let ((nvf (pair-fst pair))
(nvg (pair-snd pair)))
(let ((nvtodo_ (funcall (funcall (nvaneris_batch_filter_out_todo nvOp)
(lambda () nva))
(lambda () nvf))))
(if (inl-p (funcall (funcall (nvaneris_batch_is_decided nvOp)
(lambda () (funcall nvcmdts)))
(lambda () nve)))
(make-pair :fst (make-pair :fst nva :snd (make-pair :fst nvb :snd (make-pair :fst nvc :snd (make-pair :fst nvd :snd (make-pair :fst nve :snd (make-pair :fst nvtodo_ :snd nvg)))))) :snd (make-axiom))
(let ((pair (funcall (funcall (funcall (nvaneris_batch_perform nvOp nvbcast nvclients nvdecision nvpax_propose nvresponse nvswap nvtimer nvtt_propose nvmf)
(lambda () (funcall nvcmdts)))
(lambda () nva))
(lambda () nvg))))
(let ((nvprotocol_ (pair-fst pair))
(nvmsgs (pair-snd pair)))
(let ((nvdecisions_ (funcall (funcall (funcall (nvaneris_batch_add_decisions nvOp)
(lambda () nva))
(lambda () (funcall nvcmdts)))
(lambda () nve))))
(make-pair :fst (make-pair :fst (+ nva 1) :snd (make-pair :fst (nvbfalse) :snd (make-pair :fst nvc :snd (make-pair :fst nvd :snd (make-pair :fst nvdecisions_ :snd (make-pair :fst nvtodo_ :snd nvprotocol_)))))) :snd nvmsgs)))))))))))))))))))))

(defun nvaneris_batch_on_slot_num (nvOp nvbcast nvclients nvdecision nvpax_propose nvresponse nvswap nvtimer nvtt_propose nvmf)
(lambda (nvzze)
(lambda (nvz)
(let ((pair (funcall nvzze)))
(let ((nvslt (pair-fst pair))
(nvcmdts (pair-snd pair)))
(let ((pair (funcall nvz)))
(let ((nva (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvb (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvc (pair-fst pair))
(nvzz3 (pair-snd pair)))
(let ((pair nvzz3))
(let ((nvd (pair-fst pair))
(nvzz4 (pair-snd pair)))
(let ((pair nvzz4))
(let ((nve (pair-fst pair))
(nvzz5 (pair-snd pair)))
(let ((pair nvzz5))
(let ((nvf (pair-fst pair))
(nvg (pair-snd pair)))
(if (inl-p (nveq_int nvslt nva))
(funcall (funcall (nvaneris_batch_on_slot_num_cmd nvOp nvbcast nvclients nvdecision nvpax_propose nvresponse nvswap nvtimer nvtt_propose nvmf)
(lambda () nvcmdts))
(lambda () (make-pair :fst nva :snd (make-pair :fst nvb :snd (make-pair :fst nvc :snd (make-pair :fst nvd :snd (make-pair :fst nve :snd (make-pair :fst nvf :snd nvg))))))))
(make-pair :fst (make-pair :fst nva :snd (make-pair :fst nvb :snd (make-pair :fst nvc :snd (make-pair :fst nvd :snd (make-pair :fst nve :snd (make-pair :fst nvf :snd nvg)))))) :snd (make-axiom))))))))))))))))))))

(defun nvaneris_batch_on_decision (nvOp nvbcast nvclients nvdecision nvpax_procs nvpax_propose nvresponse nvswap nvtimer nvtt_procs nvtt_propose nvmf)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvzzg)
(lambda (nvzzf)
(let ((pair (funcall nvzzg)))
(let ((nvslt (pair-fst pair))
(nvcmdts (pair-snd pair)))
(let ((pair (funcall nvzzf)))
(let ((nva (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvb (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvc (pair-fst pair))
(nvzz3 (pair-snd pair)))
(let ((pair nvzz3))
(let ((nvd (pair-fst pair))
(nvzz4 (pair-snd pair)))
(let ((pair nvzz4))
(let ((nve (pair-fst pair))
(nvzz5 (pair-snd pair)))
(let ((pair nvzz5))
(let ((nvf (pair-fst pair))
(nvg (pair-snd pair)))
(let ((nvtodo_ (funcall (funcall (funcall (funcall (funcall (nvaneris_batch_add_todo nvOp)
(lambda () nva))
(lambda () nvslt))
(lambda () nvcmdts))
(lambda () nve))
(lambda () nvf))))
(let ((nvproposals_ (funcall (funcall (nvaneris_batch_filter_out_proposals nvOp)
(lambda () nvcmdts))
(lambda () nvd))))
(let ((pair (funcall (funcall (funcall (nvaneris_batch_iterate_tr nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtimer nvtt_propose nvmf)
(lambda () (nvaneris_batch_on_slot_num nvOp nvbcast nvclients nvdecision nvpax_propose nvresponse nvswap nvtimer nvtt_propose nvmf)))
(lambda () (make-pair :fst nva :snd (make-pair :fst nvb :snd (make-pair :fst nvc :snd (make-pair :fst nvproposals_ :snd (make-pair :fst nve :snd (make-pair :fst nvtodo_ :snd nvg))))))))
(lambda () nvtodo_))))
(let ((nvz (pair-fst pair))
(nvmsgs1 (pair-snd pair)))
(let ((pair nvz))
(let ((nva (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvb (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvc (pair-fst pair))
(nvzz3 (pair-snd pair)))
(let ((pair nvzz3))
(let ((nvd (pair-fst pair))
(nvzz4 (pair-snd pair)))
(let ((pair nvzz4))
(let ((nve (pair-fst pair))
(nvzz5 (pair-snd pair)))
(let ((pair nvzz5))
(let ((nvf (pair-fst pair))
(nvg (pair-snd pair)))
(let ((pair (funcall (nvaneris_batch_propose nvOp nvbcast nvdecision nvpax_procs nvpax_propose nvresponse nvswap nvtimer nvtt_procs nvtt_propose nvmf)
(lambda () (make-pair :fst nva :snd (make-pair :fst nvb :snd (make-pair :fst nvc :snd (make-pair :fst nvd :snd (make-pair :fst nve :snd (make-pair :fst nvf :snd nvg))))))))))
(let ((nvstate (pair-fst pair))
(nvmsgs2 (pair-snd pair)))
(make-pair :fst nvstate :snd (nvbag-append nvmsgs1 nvmsgs2))))))))))))))))))))))))))))))))))))))

(defun nvaneris_batch_decision_base-program (nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtimer nvtt_propose nvmf)
(declare (ignore nvOp))
(declare (ignore nvbcast))
(declare (ignore nvpax_propose))
(declare (ignore nvresponse))
(declare (ignore nvswap))
(declare (ignore nvtimer))
(declare (ignore nvtt_propose))
(declare (ignore nvmf))
(nvbase-class-program nvdecision))

(defun nvstate-class4-program (nvinit nvtr1 nvpr1 nvtr2 nvpr2 nvtr3 nvpr3 nvtr4 nvpr4)
(nvloop-class-state-program (nvparallel-class-program (nveclass1-program nvtr1 nvpr1) (nvparallel-class-program (nveclass1-program nvtr2 nvpr2) (nvparallel-class-program (nveclass1-program nvtr3 nvpr3) (nveclass1-program nvtr4 nvpr4)))) (lambda (nvloc)
(nvsingle-bag (funcall nvinit
(lambda () (funcall nvloc)))))))

(defun nvaneris_batch_ReplicaState-program (nvOp nvbcast nvclients nvdecision nvpax_procs nvpax_propose nvresponse nvswap nvtimeout nvtimer nvtt_procs nvtt_propose nvmf)
(nvstate-class4-program (lambda (nvz)
(declare (ignore nvz))
(make-pair :fst (nvaneris_batch_init_state nvOp) :snd (make-axiom))) (funcall (nvaneris_batch_out_tr nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtimer nvtt_propose nvmf)
(lambda () (nvaneris_batch_propose_inl nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtimeout nvtimer nvtt_propose nvmf))) (nvaneris_batch_swap_base-program nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtimer nvtt_propose nvmf) (funcall (nvaneris_batch_out_tr nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtimer nvtt_propose nvmf)
(lambda () (nvaneris_batch_propose_inr nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtimeout nvtimer nvtt_propose nvmf))) (nvaneris_batch_bcast_base-program nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtimer nvtt_propose nvmf) (funcall (nvaneris_batch_out_tr nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtimer nvtt_propose nvmf)
(lambda () (nvaneris_batch_propose_bat nvOp nvbcast nvdecision nvpax_procs nvpax_propose nvresponse nvswap nvtimer nvtt_procs nvtt_propose nvmf))) (nvaneris_batch_timer_base-program nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtimer nvtt_propose nvmf) (funcall (nvaneris_batch_out_tr nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtimer nvtt_propose nvmf)
(lambda () (nvaneris_batch_on_decision nvOp nvbcast nvclients nvdecision nvpax_procs nvpax_propose nvresponse nvswap nvtimer nvtt_procs nvtt_propose nvmf))) (nvaneris_batch_decision_base-program nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtimer nvtt_propose nvmf)))

(defun nvaneris_batch_Replica-program (nvOp nvbcast nvclients nvdecision nvpax_procs nvpax_propose nvresponse nvswap nvtimeout nvtimer nvtt_procs nvtt_propose nvmf)
(nveclass0-program (lambda (nvz)
(declare (ignore nvz))
(lambda (nvx)
(nvpi2 (funcall nvx)))) (nvaneris_batch_ReplicaState-program nvOp nvbcast nvclients nvdecision nvpax_procs nvpax_propose nvresponse nvswap nvtimeout nvtimer nvtt_procs nvtt_propose nvmf)))

(defun nvaneris_batch_main-program (nvOp nvbcast nvclients nvdecision nvpax_procs nvpax_propose nvreps nvresponse nvswap nvtimeout nvtimer nvtt_procs nvtt_propose nvmf)
(nvclass-at-program (nvaneris_batch_Replica-program nvOp nvbcast nvclients nvdecision nvpax_procs nvpax_propose nvresponse nvswap nvtimeout nvtimer nvtt_procs nvtt_propose nvmf) nvreps))

(defun nvaneris_control_aneris_batch_main-program (nvOp nvclients nvldrs nvlocs nvreps nvtimeout nvmf)
(nvaneris_batch_main-program nvOp (make-pair :fst "bcast" :snd (make-axiom)) nvclients (make-pair :fst "decision" :snd (make-axiom)) nvldrs (make-pair :fst "pv11_p1" :snd (make-pair :fst "propose" :snd (make-axiom))) nvreps (make-pair :fst "response" :snd (make-axiom)) (make-pair :fst "swap" :snd (make-axiom)) nvtimeout (make-pair :fst "timer" :snd (make-axiom)) nvlocs (make-pair :fst "rsc4" :snd (make-pair :fst "propose" :snd (make-axiom))) nvmf))

(defun main ()
(lambda (nvOp)
(lambda (nvaccpts)
(lambda (nvclients)
(lambda (nveq_Op)
(lambda (nvflrs)
(lambda (nvldrs)
(lambda (nvldrs_uid)
(lambda (nvlocs)
(lambda (nvmf)
(lambda (nvreps)
(lambda (nvtimeout)
(nvparallel-class-program (nvparallel-class-program (nvaneris_control_rsc4_main-program (funcall nvOp) (funcall nveq_Op) (funcall nvflrs) (funcall nvlocs) (funcall nvreps) (funcall nvmf)) (nvaneris_control_aneris_pax_v1_main-program (funcall nvOp) (funcall nvaccpts) (funcall nvldrs) (funcall nvldrs_uid) (funcall nvreps) (funcall nvmf))) (nvaneris_control_aneris_batch_main-program (funcall nvOp) (funcall nvclients) (funcall nvldrs) (funcall nvlocs) (funcall nvreps) (funcall nvtimeout) (funcall nvmf)))))))))))))))

