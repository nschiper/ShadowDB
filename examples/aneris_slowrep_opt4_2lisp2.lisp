(defun nvbtrue ()
(make-inl :val (make-axiom)))

(defun nvbor (nvp nvq)
(if (inl-p nvp)
(nvbtrue)
nvq))

(defun nvbfalse ()
(make-inr :val (make-axiom)))

(defun nvreduce (nvf nvk nvas)
(funcall (fix (lambda (nvlist_ind)
(lambda (nvL)
(if (pair-p nvL)
(let ((pair nvL))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(funcall (funcall nvf
nvh)
(funcall (funcall nvlist_ind)
nvt))))
(if (axiom-p nvL)
nvk
(error "bottom"))))))
nvas))

(defun nvdeq-member (nveq nvx nvL)
(nvreduce (lambda (nva)
(lambda (nvb)
(nvbor (funcall (funcall nveq
nva)
nvx) nvb))) (nvbfalse) nvL))

(defun nvisr (nvx)
(let ((dec nvx))
(if (inl-p dec)
(let ((nvy (inl-val dec)))
(declare (ignore nvy))
(nvbfalse))
(if (inr-p dec)
(let ((nvz (inr-val dec)))
(declare (ignore nvz))
(nvbtrue))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))

(defun nvhdf-halted (nvP)
(nvisr nvP))

(defun nvband (nvp nvq)
(if (inl-p nvp)
nvq
(nvbfalse)))

(defun nvhdf-halt ()
(make-inr :val (make-axiom)))

(defun nvhdf-ap (nvX nva)
(let ((dec nvX))
(if (inl-p dec)
(let ((nvP (inl-val dec)))
(funcall nvP
nva))
(if (inr-p dec)
(let ((nvz (inr-val dec)))
(declare (ignore nvz))
(make-pair :fst (make-inr :val (make-axiom)) :snd (make-axiom)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))

(defun nvappend (nvas nvbs)
(funcall (fix (lambda (nvlist_ind)
(lambda (nvL)
(if (pair-p nvL)
(let ((pair nvL))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(make-pair :fst nvh :snd (funcall (funcall nvlist_ind)
nvt))))
(if (axiom-p nvL)
nvbs
(error "bottom"))))))
nvas))

(defun nvbag-append (nvas nvbs)
(nvappend nvas nvbs))

(defun nvhdf-run (nvP)
(make-inl :val nvP))

(defun nvhdf-parallel (nvX nvY)
(funcall (fix (lambda (nvmk-hdf)
(lambda (nvs0)
(if (inl-p (let ((pair nvs0))
(let ((nvX (pair-fst pair))
(nvY (pair-snd pair)))
(nvband (nvhdf-halted nvX) (nvhdf-halted nvY)))))
(nvhdf-halt)
(nvhdf-run (lambda (nvm)
(let ((pair (let ((pair nvs0))
(let ((nvX (pair-fst pair))
(nvY (pair-snd pair)))
(let ((pair (nvhdf-ap nvX nvm)))
(let ((nvX_ (pair-fst pair))
(nvxs (pair-snd pair)))
(let ((pair (nvhdf-ap nvY nvm)))
(let ((nvY_ (pair-fst pair))
(nvys (pair-snd pair)))
(let ((nvout (nvbag-append nvxs nvys)))
(make-pair :fst (make-pair :fst nvX_ :snd nvY_) :snd nvout))))))))))
(let ((nvs1 (pair-fst pair))
(nvb (pair-snd pair)))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvs1) :snd nvb)))))))))
(make-pair :fst nvX :snd nvY)))

(defun nveq_atom (nvx nvy)
(if (string= nvx nvy)
(nvbtrue)
(nvbfalse)))

(defun nvatom-deq ()
(lambda (nva)
(lambda (nvb)
(nveq_atom nva nvb))))

(defun nvnull (nvas)
(funcall (fix (lambda (nvlist_ind)
(declare (ignore nvlist_ind))
(lambda (nvL)
(if (pair-p nvL)
(let ((pair nvL))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(declare (ignore nvh))
(declare (ignore nvt))
(nvbfalse)))
(if (axiom-p nvL)
(nvbtrue)
(error "bottom"))))))
nvas))

(defun nvlist-deq (nveq)
(lambda (nvas)
(lambda (nvbs)
(funcall (funcall (fix (lambda (nvlist_ind)
(lambda (nvL)
(if (pair-p nvL)
(let ((pair nvL))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(lambda (nvL)
(funcall (fix (lambda (nvlist_ind_)
(declare (ignore nvlist_ind_))
(lambda (nvL)
(if (pair-p nvL)
(let ((pair nvL))
(let ((nvh_ (pair-fst pair))
(nvt_ (pair-snd pair)))
(nvband (funcall (funcall nveq
nvh)
nvh_) (funcall (funcall (funcall nvlist_ind)
nvt)
nvt_))))
(if (axiom-p nvL)
(nvbfalse)
(error "bottom"))))))
nvL))))
(if (axiom-p nvL)
(lambda (nvL)
(nvnull nvL))
(error "bottom"))))))
nvas)
nvbs))))

(defun nvname-deq ()
(nvlist-deq (nvatom-deq)))

(defun nvname_eq (nvx nvy)
(funcall (funcall (nvname-deq)
nvx)
nvy))

(defun nvmap (nvf nvas)
(funcall (fix (lambda (nvlist_ind)
(lambda (nvL)
(if (pair-p nvL)
(let ((pair nvL))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(make-pair :fst (funcall nvf
nvh) :snd (funcall (funcall nvlist_ind)
nvt))))
(if (axiom-p nvL)
(make-axiom)
(error "bottom"))))))
nvas))

(defun nvbag-null (nvbs)
(nvnull nvbs))

(defun nvbag-map (nvf nvbs)
(nvmap nvf nvbs))

(defun nvconcat (nvll)
(nvreduce (lambda (nvl)
(lambda (nvl_)
(nvappend nvl nvl_))) (make-axiom) nvll))

(defun nvbag-union (nvbbs)
(nvconcat nvbbs))

(defun nvaneris_pax_v1_Ballot_Num ()
"UNION")

(defun nvId ()
"ATOM")

(defun nvaneris_v1_full_headers_fun (nvCid nvOp)
(declare (ignore nvCid))
(declare (ignore nvOp))
(lambda (nvhdr)
(if (inl-p (nvname_eq nvhdr (make-pair :fst "bcast" :snd (make-axiom))))
"PRODUCT"
(if (inl-p (nvname_eq nvhdr (make-pair :fst "swap" :snd (make-axiom))))
"PRODUCT"
(if (inl-p (nvname_eq nvhdr (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom))))))
"PRODUCT"
(if (inl-p (nvname_eq nvhdr (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom))))))
"PRODUCT"
(if (inl-p (nvname_eq nvhdr (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom)))))
"PRODUCT"
(if (inl-p (nvname_eq nvhdr (make-pair :fst "response" :snd (make-axiom))))
"PRODUCT"
(if (inl-p (nvname_eq nvhdr (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p1a" :snd (make-axiom)))))
"PRODUCT"
(if (inl-p (nvname_eq nvhdr (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p1b" :snd (make-axiom)))))
"PRODUCT"
(if (inl-p (nvname_eq nvhdr (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p2a" :snd (make-axiom)))))
"PRODUCT"
(if (inl-p (nvname_eq nvhdr (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p2b" :snd (make-axiom)))))
"PRODUCT"
(if (inl-p (nvname_eq nvhdr (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "preempted" :snd (make-axiom)))))
(nvaneris_pax_v1_Ballot_Num)
(if (inl-p (nvname_eq nvhdr (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "adopted" :snd (make-axiom)))))
"PRODUCT"
(if (inl-p (nvname_eq nvhdr (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "ping" :snd (make-axiom)))))
(nvId)
(if (inl-p (nvname_eq nvhdr (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "pong" :snd (make-axiom)))))
"EQUAL"
(if (inl-p (nvname_eq nvhdr (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "react" :snd (make-axiom)))))
"EQUAL"
(if (inl-p (nvname_eq nvhdr (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "start" :snd (make-axiom)))))
"EQUAL"
(if (inl-p (nvname_eq nvhdr (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "decided" :snd (make-axiom)))))
"INT"
(if (inl-p (nvname_eq nvhdr (make-pair :fst "aneris_23_v1" :snd (make-pair :fst "vote" :snd (make-axiom)))))
"PRODUCT"
(if (inl-p (nvname_eq nvhdr (make-pair :fst "aneris_23_v1" :snd (make-pair :fst "retry" :snd (make-axiom)))))
"PRODUCT"
(if (inl-p (nvname_eq nvhdr (make-pair :fst "aneris_23_v1" :snd (make-pair :fst "decided" :snd (make-axiom)))))
"PRODUCT"
"VOID"))))))))))))))))))))))

(defun nveq_int (nvi nvj)
(if (= nvi nvj)
(nvbtrue)
(nvbfalse)))

(defun nvint-deq ()
(lambda (nva)
(lambda (nvb)
(nveq_int nva nvb))))

(defun nvpi1 (nvt)
(let ((pair nvt))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(declare (ignore nvy))
nvx)))

(defun nvpi2 (nvt)
(let ((pair nvt))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(declare (ignore nvx))
nvy)))

(defun nvproddeq (nva nvb)
(lambda (nvp)
(lambda (nvq)
(nvband (funcall (funcall nva
(nvpi1 nvp))
(nvpi1 nvq)) (funcall (funcall nvb
(nvpi2 nvp))
(nvpi2 nvq))))))

(defun nvproduct-deq (nvAA nvBB nva nvb)
(declare (ignore nvAA))
(declare (ignore nvBB))
(nvproddeq nva nvb))

(defun nvunit-deq ()
(lambda (nva)
(declare (ignore nva))
(lambda (nvb)
(declare (ignore nvb))
(nvbtrue))))

(defun nvsumdeq (nva nvb)
(lambda (nvp)
(lambda (nvq)
(let ((dec nvp))
(if (inl-p dec)
(let ((nvpa (inl-val dec)))
(let ((dec nvq))
(if (inl-p dec)
(let ((nvqa (inl-val dec)))
(funcall (funcall nva
nvpa)
nvqa))
(if (inr-p dec)
(let ((nvqb (inr-val dec)))
(declare (ignore nvqb))
(nvbfalse))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(if (inr-p dec)
(let ((nvpb (inr-val dec)))
(let ((dec nvq))
(if (inl-p dec)
(let ((nvqa (inl-val dec)))
(declare (ignore nvqa))
(nvbfalse))
(if (inr-p dec)
(let ((nvqb (inr-val dec)))
(funcall (funcall nvb
nvpb)
nvqb))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))

(defun nvunion-deq (nvAA nvBB nva nvb)
(declare (ignore nvAA))
(declare (ignore nvBB))
(nvsumdeq nva nvb))

(defun nvaneris_pax_v1_eq_bnums ()
(lambda (nvbn1)
(lambda (nvbn2)
(funcall (funcall (nvunion-deq "PRODUCT" "EQUAL" (nvproduct-deq "INT" (nvId) (nvint-deq) (lambda (nva)
(lambda (nvb)
(if (string= nva nvb)
(make-inl :val (make-axiom))
(make-inr :val (make-axiom)))))) (nvunit-deq))
nvbn1)
nvbn2))))

(defun nvlength (nvas)
(funcall (fix (lambda (nvlength)
(lambda (nvas)
(funcall (fix (lambda (nvlist_ind)
(declare (ignore nvlist_ind))
(lambda (nvL)
(if (pair-p nvL)
(let ((pair nvL))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(declare (ignore nvh))
(+ (funcall (funcall nvlength)
nvt) 1)))
(if (axiom-p nvL)
0
(error "bottom"))))))
nvas))))
nvas))

(defun nvbag-size (nvbs)
(nvlength nvbs))

(defun nvaneris_pax_v1_threshold (nvaccpts)
(/ (+ (nvbag-size nvaccpts) 1) 2))

(defun nvlt_int (nvi nvj)
(if (< nvi nvj)
(nvbtrue)
(nvbfalse)))

(defun nvmake-Msg (nvhdr nvval)
(make-pair :fst nvhdr :snd nvval))

(defun nvmake-msg-interface (nvi nvl nvm)
(make-pair :fst nvi :snd (make-pair :fst nvl :snd nvm)))

(defun nvmk-msg-interface (nvl nvm)
(nvmake-msg-interface 0 nvl nvm))

(defun nvaneris_pax_v1_adopted_send (nvCmd nvdecision nvpropose nvzs)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvzs))
(lambda (nvl)
(lambda (nvz)
(nvmk-msg-interface nvl (nvmake-Msg (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "adopted" :snd (make-axiom))) nvz)))))

(defun nvsingle-bag (nvx)
(make-pair :fst nvx :snd (make-axiom)))

(defun nvaneris_pax_v1_preempted_send (nvCmd nvdecision nvpropose nvzs)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvzs))
(lambda (nvl)
(lambda (nvz)
(nvmk-msg-interface nvl (nvmake-Msg (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "preempted" :snd (make-axiom))) nvz)))))

(defun nvaneris_pax_v1_scout_output (nvCmd nvaccpts nvdecision nvpropose nvzs)
(lambda (nvbnum)
(lambda (nvldr)
(lambda (nvzl)
(let ((pair nvzl))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(declare (ignore nvw))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz (pair-snd pair)))
(declare (ignore nvz))
(lambda (nvz_)
(let ((pair nvz_))
(let ((nvwaitfor (pair-fst pair))
(nvpvalues (pair-snd pair)))
(if (inl-p (funcall (funcall (nvaneris_pax_v1_eq_bnums)
nvbnum)
nvx))
(if (inl-p (funcall (funcall (nvaneris_pax_v1_eq_bnums)
nvbnum)
nvy))
(if (inl-p (nvlt_int (nvbag-size nvwaitfor) (nvaneris_pax_v1_threshold nvaccpts)))
(nvsingle-bag (funcall (funcall (nvaneris_pax_v1_adopted_send nvCmd nvdecision nvpropose nvzs)
nvldr)
(make-pair :fst nvbnum :snd nvpvalues)))
(make-axiom))
(nvsingle-bag (funcall (funcall (nvaneris_pax_v1_preempted_send nvCmd nvdecision nvpropose nvzs)
nvldr)
nvy)))
(make-axiom)))))))))))))))

(defun nvaneris_pax_v1_mk_bnum ()
(lambda (nvn)
(lambda (nvloc)
(make-inl :val (make-pair :fst nvn :snd nvloc)))))

(defun nvaneris_pax_v1_prp2slt (nvCmd)
(declare (ignore nvCmd))
(lambda (nvproposal)
(nvpi1 nvproposal)))

(defun nvaneris_pax_v1_pv2prp (nvCmd)
(declare (ignore nvCmd))
(lambda (nvpvalue)
(nvpi2 nvpvalue)))

(defun nvint-minus-comparison (nvf)
(lambda (nvx)
(lambda (nvy)
(- (funcall nvf
nvx) (funcall nvf
nvy)))))

(defun nvbnot (nvb)
(if (inl-p nvb)
(nvbfalse)
(nvbtrue)))

(defun nvle_int (nvi nvj)
(nvbnot (nvlt_int nvj nvi)))

(defun nvaneris_pax_v1_leq_bnum_ (nvldrs_uid)
(lambda (nvza)
(let ((pair nvza))
(let ((nvi1 (pair-fst pair))
(nvl1 (pair-snd pair)))
(lambda (nvz)
(let ((pair nvz))
(let ((nvi2 (pair-fst pair))
(nvl2 (pair-snd pair)))
(nvbor (nvlt_int nvi1 nvi2) (nvband (nveq_int nvi1 nvi2) (nvle_int (funcall nvldrs_uid
nvl1) (funcall nvldrs_uid
nvl2)))))))))))

(defun nvaneris_pax_v1_leq_bnum (nvldrs_uid)
(lambda (nvbn1)
(lambda (nvbn2)
(let ((dec nvbn1))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(let ((dec nvbn2))
(if (inl-p dec)
(let ((nvx2 (inl-val dec)))
(funcall (funcall (nvaneris_pax_v1_leq_bnum_ nvldrs_uid)
nvx1)
nvx2))
(if (inr-p dec)
(let ((nvz (inr-val dec)))
(declare (ignore nvz))
(nvbfalse))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(if (inr-p dec)
(let ((nvz (inr-val dec)))
(declare (ignore nvz))
(nvbtrue))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))

(defun nvaneris_pax_v1_pv2bn (nvCmd)
(declare (ignore nvCmd))
(lambda (nvpvalue)
(nvpi1 nvpvalue)))

(defun nvinsert-combine (nvcmp nvf nvx nvl)
(funcall (fix (lambda (nvlist_ind)
(lambda (nvL)
(if (pair-p nvL)
(let ((pair nvL))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(let ((nvtst (funcall (funcall nvcmp
nvx)
nvh)))
(if (inl-p (nveq_int nvtst 0))
(make-pair :fst (funcall (funcall nvf
nvx)
nvh) :snd nvt)
(if (inl-p (nvlt_int 0 nvtst))
(make-pair :fst nvx :snd (make-pair :fst nvh :snd nvt))
(make-pair :fst nvh :snd (funcall (funcall nvlist_ind)
nvt)))))))
(if (axiom-p nvL)
(make-pair :fst nvx :snd (make-axiom))
(error "bottom"))))))
nvl))

(defun nvaneris_pax_v1_add_pvalue (nvCmd nvldrs_uid)
(lambda (nvpvalues)
(lambda (nvpvalue)
(nvinsert-combine (nvint-minus-comparison (lambda (nvpv)
(funcall (nvaneris_pax_v1_prp2slt nvCmd)
(funcall (nvaneris_pax_v1_pv2prp nvCmd)
nvpv)))) (lambda (nvpv1)
(lambda (nvpv2)
(if (inl-p (funcall (funcall (nvaneris_pax_v1_leq_bnum nvldrs_uid)
(funcall (nvaneris_pax_v1_pv2bn nvCmd)
nvpv1))
(funcall (nvaneris_pax_v1_pv2bn nvCmd)
nvpv2)))
nvpv2
nvpv1))) nvpvalue nvpvalues))))

(defun nvaneris_pax_v1_add_new_pvalues (nvCmd nvldrs_uid)
(lambda (nvpvals1)
(lambda (nvpvals2)
(nvreduce (lambda (nvpv)
(lambda (nvr)
(funcall (funcall (nvaneris_pax_v1_add_pvalue nvCmd nvldrs_uid)
nvr)
nvpv))) nvpvals2 nvpvals1))))

(defun nvfilter (nvP nvl)
(nvreduce (lambda (nva)
(lambda (nvv)
(if (inl-p (funcall nvP
nva))
(make-pair :fst nva :snd nvv)
nvv))) (make-axiom) nvl))

(defun nvbag-remove (nveq nvbs nvx)
(nvfilter (lambda (nvx_)
(nvbnot (funcall (funcall nveq
nvx)
nvx_))) nvbs))

(defun nvaneris_pax_v1_on_p1b (nvCmd nvldrs_uid)
(lambda (nvbnum)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvzj)
(let ((pair nvzj))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz (pair-snd pair)))
(lambda (nvz_)
(let ((pair nvz_))
(let ((nvwaitfor (pair-fst pair))
(nvpvalues (pair-snd pair)))
(if (inl-p (nvband (funcall (funcall (nvaneris_pax_v1_eq_bnums)
nvbnum)
nvx) (funcall (funcall (nvaneris_pax_v1_eq_bnums)
nvbnum)
nvy)))
(funcall (lambda (nvx)
(funcall (lambda (nvx_)
(make-pair :fst nvx :snd nvx_))
(funcall (funcall (nvaneris_pax_v1_add_new_pvalues nvCmd nvldrs_uid)
nvpvalues)
nvz)))
(nvbag-remove (lambda (nva)
(lambda (nvb)
(if (string= nva nvb)
(make-inl :val (make-axiom))
(make-inr :val (make-axiom))))) nvwaitfor nvw))
(make-pair :fst nvwaitfor :snd nvpvalues)))))))))))))))

(defun nvaneris_pax_v1_p1a_broadcast (nvCmd nvdecision nvpropose nvzs)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvzs))
(lambda (nvlocs)
(lambda (nvz)
(nvbag-map (lambda (nvl)
(nvmk-msg-interface nvl (nvmake-Msg (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p1a" :snd (make-axiom))) nvz))) nvlocs))))

(defun nvaneris_pax_v1_init_pvalues (nvCmd)
(declare (ignore nvCmd))
(make-axiom))

(defun nvaneris_pax_v1_init_scout (nvCmd nvaccpts)
(make-pair :fst nvaccpts :snd (nvaneris_pax_v1_init_pvalues nvCmd)))

(defun nvbind-nxt (nvY nvp nva)
(let ((pair nvp))
(let ((nvX (pair-fst pair))
(nvys (pair-snd pair)))
(let ((pair (nvhdf-ap nvX nva)))
(let ((nvX_ (pair-fst pair))
(nvb (pair-snd pair)))
(let ((nvybs (nvbag-map (lambda (nvP)
(nvhdf-ap nvP nva)) (nvbag-append nvys (nvbag-map nvY nvb)))))
(let ((nvys_ (nvfilter (lambda (nvx)
(nvbnot (nvhdf-halted nvx))) (nvbag-map (lambda (nvyb)
(nvpi1 nvyb)) nvybs))))
(let ((nvout (nvbag-union (nvbag-map (lambda (nvx)
(nvpi2 nvx)) nvybs))))
(make-pair :fst (make-pair :fst nvX_ :snd nvys_) :snd nvout)))))))))

(defun nvhdf-bind (nvX nvY)
(funcall (fix (lambda (nvmk-hdf)
(lambda (nvs0)
(if (inl-p (let ((pair nvs0))
(let ((nvX (pair-fst pair))
(nvys (pair-snd pair)))
(nvband (nvhdf-halted nvX) (nvbag-null nvys)))))
(nvhdf-halt)
(nvhdf-run (lambda (nvm)
(let ((pair (nvbind-nxt nvY nvs0 nvm)))
(let ((nvs1 (pair-fst pair))
(nvb (pair-snd pair)))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvs1) :snd nvb)))))))))
(make-pair :fst nvX :snd (make-axiom))))

(defun nvhdf-once (nvX)
(funcall (fix (lambda (nvmk-hdf)
(lambda (nvs0)
(if (inl-p (nvhdf-halted nvs0))
(nvhdf-halt)
(nvhdf-run (lambda (nvm)
(let ((pair (let ((pair (nvhdf-ap nvs0 nvm)))
(let ((nvX_ (pair-fst pair))
(nvb (pair-snd pair)))
(make-pair :fst (if (inl-p (nvbag-null nvb))
nvX_
(nvhdf-halt)) :snd nvb)))))
(let ((nvs1 (pair-fst pair))
(nvb (pair-snd pair)))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvs1) :snd nvb)))))))))
nvX))

(defun nvaneris_pax_v1_dest_prp (nvCmd)
(declare (ignore nvCmd))
(lambda (nvproposal)
nvproposal))

(defun nvaneris_pax_v1_is_in_missing ()
(lambda (nvslt)
(lambda (nvmissing)
(nvreduce (lambda (nvh)
(lambda (nvr)
(if (inl-p (nvlt_int nvslt nvh))
(nvbfalse)
(if (inl-p (nveq_int nvslt nvh))
(nvbtrue)
nvr)))) (nvbfalse) nvmissing))))

(defun nvaneris_pax_v1_is_decided ()
(lambda (nvslt)
(lambda (nvz)
(let ((pair nvz))
(let ((nvmax (pair-fst pair))
(nvmissing (pair-snd pair)))
(nvband (nvle_int nvslt nvmax) (nvbnot (funcall (funcall (nvaneris_pax_v1_is_in_missing)
nvslt)
nvmissing))))))))

(defun nvaneris_pax_v1_mk_prp (nvCmd)
(declare (ignore nvCmd))
(lambda (nvslt)
(lambda (nvcmd)
(make-pair :fst nvslt :snd nvcmd))))

(defun nvaneris_pax_v1_add_proposal_if_not_in (nvCCmd)
(lambda (nvproposals)
(lambda (nvslt)
(lambda (nvcmd)
(nvinsert-combine (nvint-minus-comparison (nvaneris_pax_v1_prp2slt nvCCmd)) (lambda (nvprp1)
(declare (ignore nvprp1))
(lambda (nvprp2)
nvprp2)) (funcall (funcall (nvaneris_pax_v1_mk_prp nvCCmd)
nvslt)
nvcmd) nvproposals)))))

(defun nvaneris_pax_v1_on_propose (nvCmd)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvproposal)
(lambda (nvz)
(let ((pair nvz))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz_ (pair-snd pair)))
(let ((pair (funcall (nvaneris_pax_v1_dest_prp nvCmd)
nvproposal)))
(let ((nvslt (pair-fst pair))
(nvcmd (pair-snd pair)))
(funcall (lambda (nvx_)
(make-pair :fst nvw :snd (make-pair :fst nvx :snd (make-pair :fst nvx_ :snd nvz_))))
(if (inl-p (funcall (funcall (nvaneris_pax_v1_is_decided)
nvslt)
nvz_))
nvy
(funcall (funcall (funcall (nvaneris_pax_v1_add_proposal_if_not_in nvCmd)
nvy)
nvslt)
nvcmd)))))))))))))))

(defun nvaneris_pax_v1_in_proposals (nvCmd)
(lambda (nvslt)
(lambda (nvproposals)
(nvreduce (lambda (nvprp)
(lambda (nvr)
(let ((pair (funcall (nvaneris_pax_v1_dest_prp nvCmd)
nvprp)))
(let ((nvslt_ (pair-fst pair))
(nvcmd (pair-snd pair)))
(declare (ignore nvcmd))
(if (inl-p (nvlt_int nvslt_ nvslt))
(nvbfalse)
(if (inl-p (nveq_int nvslt nvslt_))
(nvbtrue)
nvr)))))) (nvbfalse) nvproposals))))

(defun nvaneris_pax_v1_mk_pv (nvCmd)
(declare (ignore nvCmd))
(lambda (nvbn)
(lambda (nvprp)
(make-pair :fst nvbn :snd nvprp))))

(defun nvaneris_pax_v1_leader_propose (nvCmd)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvproposal)
(lambda (nvz)
(let ((pair nvz))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz_ (pair-snd pair)))
(funcall (lambda (nvx_)
(if (inl-p (nvband nvx (nvband (nvbnot (funcall (funcall (nvaneris_pax_v1_in_proposals nvCmd)
nvx_)
nvy)) (nvbnot (funcall (funcall (nvaneris_pax_v1_is_decided)
nvx_)
nvz_)))))
(nvsingle-bag (funcall (funcall (nvaneris_pax_v1_mk_pv nvCmd)
nvw)
nvproposal))
(make-axiom)))
(funcall (nvaneris_pax_v1_prp2slt nvCmd)
nvproposal))))))))))))

(defun nvcons-bag (nvx nvb)
(make-pair :fst nvx :snd nvb))

(defun nvaneris_pax_v1_dest_pv (nvCmd)
(lambda (nvpvalue)
(let ((pair nvpvalue))
(let ((nvbn (pair-fst pair))
(nvprp (pair-snd pair)))
(make-pair :fst nvbn :snd (funcall (nvaneris_pax_v1_dest_prp nvCmd)
nvprp))))))

(defun nvaneris_pax_v1_add_proposal (nvCCmd)
(lambda (nvproposals)
(lambda (nvslt)
(lambda (nvcmd)
(nvinsert-combine (nvint-minus-comparison (nvaneris_pax_v1_prp2slt nvCCmd)) (lambda (nvprp1)
(lambda (nvprp2)
(declare (ignore nvprp2))
nvprp1)) (funcall (funcall (nvaneris_pax_v1_mk_prp nvCCmd)
nvslt)
nvcmd) nvproposals)))))

(defun nvaneris_pax_v1_update_proposals (nvCmd)
(lambda (nvproposals)
(lambda (nvdecided)
(lambda (nvpvals)
(funcall (funcall (fix (lambda (nvlist_accum)
(lambda (nvy)
(lambda (nvL)
(if (pair-p nvL)
(let ((pair nvL))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(funcall (funcall (funcall nvlist_accum)
(let ((pair (funcall (nvaneris_pax_v1_dest_pv nvCmd)
nvh)))
(let ((nvx (pair-fst pair))
(nvzz (pair-snd pair)))
(declare (ignore nvx))
(let ((pair nvzz))
(let ((nvy_ (pair-fst pair))
(nvz (pair-snd pair)))
(if (inl-p (funcall (funcall (nvaneris_pax_v1_is_decided)
nvy_)
nvdecided))
nvy
(funcall (funcall (funcall (nvaneris_pax_v1_add_proposal nvCmd)
nvy)
nvy_)
nvz)))))))
nvt)))
(if (axiom-p nvL)
nvy
(error "bottom")))))))
nvproposals)
nvpvals)))))

(defun nvaneris_pax_v1_leader_adopted (nvCmd)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvzp)
(let ((pair nvzp))
(let ((nvbnum (pair-fst pair))
(nvpvals (pair-snd pair)))
(lambda (nvz)
(let ((pair nvz))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(declare (ignore nvx))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz_ (pair-snd pair)))
(if (inl-p (funcall (funcall (nvaneris_pax_v1_eq_bnums)
nvbnum)
nvw))
(funcall (funcall (fix (lambda (nvlist_accum)
(lambda (nvy_)
(lambda (nvL)
(if (pair-p nvL)
(let ((pair nvL))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(funcall (funcall (funcall nvlist_accum)
(nvcons-bag (funcall (funcall (nvaneris_pax_v1_mk_pv nvCmd)
nvbnum)
nvh) nvy_))
nvt)))
(if (axiom-p nvL)
nvy_
(error "bottom")))))))
(make-axiom))
(funcall (funcall (funcall (nvaneris_pax_v1_update_proposals nvCmd)
nvy)
nvz_)
nvpvals))
(make-axiom))))))))))))))

(defun nvaneris_pax_v1_when_adopted (nvCmd)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvzm)
(let ((pair nvzm))
(let ((nvbnum (pair-fst pair))
(nvpvals (pair-snd pair)))
(lambda (nvz)
(let ((pair nvz))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz_ (pair-snd pair)))
(if (inl-p (funcall (funcall (nvaneris_pax_v1_eq_bnums)
nvbnum)
nvw))
(funcall (lambda (nvx)
(make-pair :fst nvw :snd (make-pair :fst (nvbtrue) :snd (make-pair :fst nvx :snd nvz_))))
(funcall (funcall (funcall (nvaneris_pax_v1_update_proposals nvCmd)
nvy)
nvz_)
nvpvals))
(make-pair :fst nvw :snd (make-pair :fst nvx :snd (make-pair :fst nvy :snd nvz_))))))))))))))))

(defun nvisl (nvx)
(let ((dec nvx))
(if (inl-p dec)
(let ((nvy (inl-val dec)))
(declare (ignore nvy))
(nvbtrue))
(if (inr-p dec)
(let ((nvz (inr-val dec)))
(declare (ignore nvz))
(nvbfalse))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))

(defun nvaneris_pax_v1_is_bnum ()
(lambda (nvbnum)
(nvisl nvbnum)))

(defun nvaneris_pax_v1_lt_bnum_ (nvldrs_uid)
(lambda (nvzb)
(let ((pair nvzb))
(let ((nvi1 (pair-fst pair))
(nvl1 (pair-snd pair)))
(lambda (nvz)
(let ((pair nvz))
(let ((nvi2 (pair-fst pair))
(nvl2 (pair-snd pair)))
(nvbor (nvlt_int nvi1 nvi2) (nvband (nveq_int nvi1 nvi2) (nvlt_int (funcall nvldrs_uid
nvl1) (funcall nvldrs_uid
nvl2)))))))))))

(defun nvaneris_pax_v1_lt_bnum (nvldrs_uid)
(lambda (nvbn1)
(lambda (nvbn2)
(let ((dec nvbn1))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(let ((dec nvbn2))
(if (inl-p dec)
(let ((nvx2 (inl-val dec)))
(funcall (funcall (nvaneris_pax_v1_lt_bnum_ nvldrs_uid)
nvx1)
nvx2))
(if (inr-p dec)
(let ((nvz (inr-val dec)))
(declare (ignore nvz))
(nvbfalse))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(if (inr-p dec)
(let ((nvz (inr-val dec)))
(declare (ignore nvz))
(nvisl nvbn2))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))

(defun nvaneris_pax_v1_upd_bnum ()
(lambda (nvbnum)
(lambda (nvloc)
(let ((dec nvbnum))
(if (inl-p dec)
(let ((nvz (inl-val dec)))
(let ((pair nvz))
(let ((nvr (pair-fst pair))
(nvl (pair-snd pair)))
(declare (ignore nvl))
(funcall (funcall (nvaneris_pax_v1_mk_bnum)
(+ nvr 1))
nvloc))))
(if (inr-p dec)
(let ((nvz (inr-val dec)))
(declare (ignore nvz))
nvbnum)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))

(defun nvaneris_pax_v1_when_preempted (nvCmd nvldrs_uid)
(declare (ignore nvCmd))
(lambda (nvldr)
(lambda (nvbnum)
(lambda (nvz)
(let ((pair nvz))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz_ (pair-snd pair)))
(if (inl-p (nvband (funcall (nvaneris_pax_v1_is_bnum)
nvbnum) (funcall (funcall (nvaneris_pax_v1_lt_bnum nvldrs_uid)
nvw)
nvbnum)))
(make-pair :fst (funcall (funcall (nvaneris_pax_v1_upd_bnum)
nvbnum)
nvldr) :snd (make-pair :fst (nvbfalse) :snd (make-pair :fst nvy :snd nvz_)))
(make-pair :fst nvw :snd (make-pair :fst nvx :snd (make-pair :fst nvy :snd nvz_))))))))))))))

(defun nvfrom-upto (nvn nvm)
(funcall (fix (lambda (nvfrom-upto)
(lambda (nvn)
(if (inl-p (nvlt_int nvn nvm))
(make-pair :fst nvn :snd (let ((nvn_ (+ nvn 1)))
(funcall (funcall nvfrom-upto)
nvn_)))
(make-axiom)))))
nvn))

(defun nvremove-combine (nvcmp nvl)
(funcall (fix (lambda (nvlist_ind)
(lambda (nvL)
(if (pair-p nvL)
(let ((pair nvL))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(let ((nvtst (funcall nvcmp
nvh)))
(if (inl-p (nveq_int nvtst 0))
nvt
(if (inl-p (nvlt_int 0 nvtst))
(make-pair :fst nvh :snd nvt)
(make-pair :fst nvh :snd (funcall (funcall nvlist_ind)
nvt)))))))
(if (axiom-p nvL)
(make-axiom)
(error "bottom"))))))
nvl))

(defun nvaneris_pax_v1_remove_from_missing ()
(lambda (nvslt)
(lambda (nvmissing)
(nvremove-combine (lambda (nvn)
(- nvn nvslt)) nvmissing))))

(defun nvaneris_pax_v1_add_slot_to_decided ()
(lambda (nvslt)
(lambda (nvz)
(let ((pair nvz))
(let ((nvmax (pair-fst pair))
(nvmissing (pair-snd pair)))
(if (inl-p (nvlt_int nvmax nvslt))
(make-pair :fst nvslt :snd (nvappend nvmissing (nvfrom-upto (+ nvmax 1) nvslt)))
(if (inl-p (nveq_int nvslt nvmax))
(make-pair :fst nvmax :snd nvmissing)
(make-pair :fst nvmax :snd (funcall (funcall (nvaneris_pax_v1_remove_from_missing)
nvslt)
nvmissing)))))))))

(defun nvaneris_pax_v1_filter_out_proposals (nvCmd)
(lambda (nvslt)
(lambda (nvproposals)
(nvremove-combine (lambda (nvprp)
(- nvslt (funcall (nvaneris_pax_v1_prp2slt nvCmd)
nvprp))) nvproposals))))

(defun nvaneris_pax_v1_when_decided (nvCmd)
(lambda (nvldr)
(declare (ignore nvldr))
(lambda (nvslt)
(lambda (nvz)
(let ((pair nvz))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz_ (pair-snd pair)))
(funcall (lambda (nvx_)
(funcall (lambda (nvx__)
(make-pair :fst nvw :snd (make-pair :fst nvx :snd (make-pair :fst nvx_ :snd nvx__))))
(funcall (funcall (nvaneris_pax_v1_add_slot_to_decided)
nvslt)
nvz_)))
(funcall (funcall (nvaneris_pax_v1_filter_out_proposals nvCmd)
nvslt)
nvy))))))))))))

(defun nvaneris_pax_v1_p2a_broadcast (nvCmd nvdecision nvpropose nvzs)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvzs))
(lambda (nvlocs)
(lambda (nvz)
(nvbag-map (lambda (nvl)
(nvmk-msg-interface nvl (nvmake-Msg (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p2a" :snd (make-axiom))) nvz))) nvlocs))))

(defun nvaneris_pax_v1_decision_broadcast (nvCmd nvdecision nvpropose nvzs)
(declare (ignore nvCmd))
(declare (ignore nvpropose))
(declare (ignore nvzs))
(lambda (nvlocs)
(lambda (nvz)
(nvbag-map (lambda (nvl)
(nvmk-msg-interface nvl (nvmake-Msg nvdecision nvz))) nvlocs))))

(defun nvaneris_pax_v1_decided_broadcast (nvCmd nvdecision nvpropose nvzs)
(declare (ignore nvCmd))
(declare (ignore nvdecision))
(declare (ignore nvpropose))
(declare (ignore nvzs))
(lambda (nvlocs)
(lambda (nvz)
(nvbag-map (lambda (nvl)
(nvmk-msg-interface nvl (nvmake-Msg (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "decided" :snd (make-axiom))) nvz))) nvlocs))))

(defun nvaneris_pax_v1_commander_output (nvCmd nvaccpts nvdecision nvldrs nvpropose nvreps nvzs)
(lambda (nvpvalue)
(lambda (nvldr)
(lambda (nvz)
(let ((pair nvz))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(declare (ignore nvw))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz_ (pair-snd pair)))
(lambda (nvwaitfor)
(let ((pair (funcall (nvaneris_pax_v1_dest_pv nvCmd)
nvpvalue)))
(let ((nvx_ (pair-fst pair))
(nvzz (pair-snd pair)))
(let ((pair nvzz))
(let ((nvy_ (pair-fst pair))
(nvz (pair-snd pair)))
(if (inl-p (nvband (funcall (funcall (nvaneris_pax_v1_eq_bnums)
nvx_)
nvx) (nveq_int nvy_ nvy)))
(if (inl-p (funcall (funcall (nvaneris_pax_v1_eq_bnums)
nvx_)
nvz_))
(if (inl-p (nvlt_int (nvbag-size nvwaitfor) (nvaneris_pax_v1_threshold nvaccpts)))
(nvbag-append (funcall (funcall (nvaneris_pax_v1_decision_broadcast nvCmd nvdecision nvpropose nvzs)
nvreps)
(funcall (funcall (nvaneris_pax_v1_mk_prp nvCmd)
nvy_)
nvz)) (funcall (funcall (nvaneris_pax_v1_decided_broadcast nvCmd nvdecision nvpropose nvzs)
nvldrs)
nvy_))
(make-axiom))
(nvsingle-bag (funcall (funcall (nvaneris_pax_v1_preempted_send nvCmd nvdecision nvpropose nvzs)
nvldr)
nvz_)))
(make-axiom)))))))))))))))))

(defun nvaneris_pax_v1_on_p2b ()
(lambda (nvbnum)
(lambda (nvslt)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvz)
(let ((pair nvz))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz_ (pair-snd pair)))
(lambda (nvwaitfor)
(if (inl-p (nvband (funcall (funcall (nvaneris_pax_v1_eq_bnums)
nvbnum)
nvx) (nvband (nveq_int nvslt nvy) (funcall (funcall (nvaneris_pax_v1_eq_bnums)
nvbnum)
nvz_))))
(nvbag-remove (lambda (nva)
(lambda (nvb)
(if (string= nva nvb)
(make-inl :val (make-axiom))
(make-inr :val (make-axiom))))) nvwaitfor nvw)
nvwaitfor)))))))))))))

(defun nvaneris_pax_v1_leader_preempted (nvCmd nvldrs_uid)
(declare (ignore nvCmd))
(lambda (nvldr)
(lambda (nvbnum)
(lambda (nvz)
(let ((pair nvz))
(let ((nvw (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvx (pair-fst pair))
(nvzz2 (pair-snd pair)))
(declare (ignore nvx))
(let ((pair nvzz2))
(let ((nvy (pair-fst pair))
(nvz_ (pair-snd pair)))
(declare (ignore nvy))
(declare (ignore nvz_))
(if (inl-p (nvband (funcall (nvaneris_pax_v1_is_bnum)
nvbnum) (funcall (funcall (nvaneris_pax_v1_lt_bnum nvldrs_uid)
nvw)
nvbnum)))
(nvsingle-bag (funcall (funcall (nvaneris_pax_v1_upd_bnum)
nvbnum)
nvldr))
(make-axiom))))))))))))

(defun nvaneris_pax_v1_max_bnum (nvldrs_uid)
(lambda (nvbn1)
(lambda (nvbn2)
(if (inl-p (funcall (funcall (nvaneris_pax_v1_leq_bnum nvldrs_uid)
nvbn1)
nvbn2))
nvbn2
nvbn1))))

(defun nvaneris_pax_v1_on_p1a (nvCmd nvldrs_uid)
(declare (ignore nvCmd))
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvze)
(let ((pair nvze))
(let ((nvloc (pair-fst pair))
(nvbnum (pair-snd pair)))
(declare (ignore nvloc))
(lambda (nvz)
(let ((pair nvz))
(let ((nvballot_num (pair-fst pair))
(nvaccepted (pair-snd pair)))
(make-pair :fst (funcall (funcall (nvaneris_pax_v1_max_bnum nvldrs_uid)
nvbnum)
nvballot_num) :snd nvaccepted)))))))))

(defun nvaneris_pax_v1_on_p2a (nvCmd nvldrs_uid)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvzf)
(let ((pair nvzf))
(let ((nvloc (pair-fst pair))
(nvpvalue (pair-snd pair)))
(declare (ignore nvloc))
(lambda (nvz)
(let ((pair nvz))
(let ((nvballot_num (pair-fst pair))
(nvaccepted (pair-snd pair)))
(funcall (lambda (nvx)
(funcall (lambda (nvx_)
(funcall (lambda (nvx__)
(make-pair :fst nvx_ :snd nvx__))
(if (inl-p (funcall (funcall (nvaneris_pax_v1_leq_bnum nvldrs_uid)
nvballot_num)
nvx))
(funcall (funcall (nvaneris_pax_v1_add_pvalue nvCmd nvldrs_uid)
nvaccepted)
nvpvalue)
nvaccepted)))
(funcall (funcall (nvaneris_pax_v1_max_bnum nvldrs_uid)
nvx)
nvballot_num)))
(funcall (nvaneris_pax_v1_pv2bn nvCmd)
nvpvalue))))))))))

(defun nvaneris_23_v1_when_new_proposal (nvCmd)
(declare (ignore nvCmd))
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvzk)
(let ((pair nvzk))
(let ((nvn (pair-fst pair))
(nvc (pair-snd pair)))
(lambda (nvz)
(let ((pair nvz))
(let ((nvmax (pair-fst pair))
(nvmissing (pair-snd pair)))
(if (inl-p (nvbor (nvlt_int nvmax nvn) (nvdeq-member (nvint-deq) nvn nvmissing)))
(nvsingle-bag (make-pair :fst nvn :snd nvc))
(make-axiom))))))))))

(defun nvaneris_23_v1_vote2prop (nvCmd)
(declare (ignore nvCmd))
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvz)
(let ((pair nvz))
(let ((nvz (pair-fst pair))
(nvloc_ (pair-snd pair)))
(declare (ignore nvloc_))
(let ((pair nvz))
(let ((nvz (pair-fst pair))
(nvc (pair-snd pair)))
(let ((pair nvz))
(let ((nvn (pair-fst pair))
(nvi (pair-snd pair)))
(declare (ignore nvi))
(nvsingle-bag (make-pair :fst nvn :snd nvc)))))))))))

(defun nvhdf-compose1 (nvf nvX)
(funcall (fix (lambda (nvmk-hdf)
(lambda (nvs0)
(if (inl-p (nvhdf-halted nvs0))
(nvhdf-halt)
(nvhdf-run (lambda (nvm)
(let ((pair (let ((pair (nvhdf-ap nvs0 nvm)))
(let ((nvX_ (pair-fst pair))
(nvbs (pair-snd pair)))
(let ((nvout (nvbag-map nvf nvbs)))
(make-pair :fst nvX_ :snd nvout))))))
(let ((nvs1 (pair-fst pair))
(nvb (pair-snd pair)))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvs1) :snd nvb)))))))))
nvX))

(defun nvlist-diff (nveq nvas nvbs)
(nvfilter (lambda (nva)
(nvbnot (nvdeq-member nveq nva nvbs))) nvas))

(defun nvaneris_23_v1_onnewpropose (nvCmd)
(declare (ignore nvCmd))
(lambda (nvzi)
(let ((pair nvzi))
(let ((nvn (pair-fst pair))
(nvc (pair-snd pair)))
(declare (ignore nvc))
(lambda (nvz)
(let ((pair nvz))
(let ((nvmax (pair-fst pair))
(nvmissing (pair-snd pair)))
(if (inl-p (nvlt_int nvmax nvn))
(make-pair :fst nvn :snd (nvappend nvmissing (nvfrom-upto (+ nvmax 1) nvn)))
(make-pair :fst nvmax :snd (nvlist-diff (nvint-deq) nvmissing (make-pair :fst nvn :snd (make-axiom))))))))))))

(defun nvaneris_23_v1_update_replica (nvCmd)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvzj)
(let ((pair nvzj))
(let ((nvn (pair-fst pair))
(nvc (pair-snd pair)))
(lambda (nvz)
(let ((pair nvz))
(let ((nvmax (pair-fst pair))
(nvmissing (pair-snd pair)))
(if (inl-p (nvbor (nvlt_int nvmax nvn) (nvdeq-member (nvint-deq) nvn nvmissing)))
(funcall (funcall (nvaneris_23_v1_onnewpropose nvCmd)
(make-pair :fst nvn :snd nvc))
(make-pair :fst nvmax :snd nvmissing))
(make-pair :fst nvmax :snd nvmissing))))))))))

(defun nvhdf-memory (nvX nvbs)
(funcall (fix (lambda (nvmk-hdf)
(lambda (nvs0)
(if (inl-p (nvbfalse))
(nvhdf-halt)
(nvhdf-run (lambda (nvm)
(let ((pair (let ((pair nvs0))
(let ((nvX (pair-fst pair))
(nvs (pair-snd pair)))
(let ((pair (nvhdf-ap nvX nvm)))
(let ((nvX_ (pair-fst pair))
(nvfs (pair-snd pair)))
(let ((nvb (nvbag-union (nvbag-map (lambda (nvx)
(nvbag-map nvx nvs)) nvfs))))
(let ((nvs_ (if (inl-p (nvbag-null nvb))
nvs
nvb)))
(make-pair :fst (make-pair :fst nvX_ :snd nvs_) :snd nvs)))))))))
(let ((nvs1 (pair-fst pair))
(nvb (pair-snd pair)))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvs1) :snd nvb)))))))))
(make-pair :fst nvX :snd nvbs)))

(defun nvhdf-compose2 (nvX nvY)
(funcall (fix (lambda (nvmk-hdf)
(lambda (nvs0)
(if (inl-p (let ((pair nvs0))
(let ((nvX (pair-fst pair))
(nvY (pair-snd pair)))
(nvbor (nvhdf-halted nvX) (nvhdf-halted nvY)))))
(nvhdf-halt)
(nvhdf-run (lambda (nvm)
(let ((pair (let ((pair nvs0))
(let ((nvX (pair-fst pair))
(nvY (pair-snd pair)))
(let ((pair (nvhdf-ap nvX nvm)))
(let ((nvX_ (pair-fst pair))
(nvfs (pair-snd pair)))
(let ((pair (nvhdf-ap nvY nvm)))
(let ((nvY_ (pair-fst pair))
(nvbs (pair-snd pair)))
(let ((nvout (nvbag-union (nvbag-map (lambda (nvx)
(nvbag-union (nvbag-map (lambda (nvx_)
(funcall nvx
nvx_)) nvbs))) nvfs))))
(make-pair :fst (make-pair :fst nvX_ :snd nvY_) :snd nvout))))))))))
(let ((nvs1 (pair-fst pair))
(nvb (pair-snd pair)))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvs1) :snd nvb)))))))))
(make-pair :fst nvX :snd nvY)))

(defun nvaneris_23_v1_newvote (nvCmd)
(declare (ignore nvCmd))
(lambda (nvni)
(lambda (nvzd)
(let ((pair nvzd))
(let ((nvze (pair-fst pair))
(nvsender (pair-snd pair)))
(let ((pair nvze))
(let ((nvni_ (pair-fst pair))
(nvc (pair-snd pair)))
(declare (ignore nvc))
(lambda (nvz)
(let ((pair nvz))
(let ((nvcmds (pair-fst pair))
(nvz (pair-snd pair)))
(declare (ignore nvcmds))
(nvband (funcall (funcall (nvproduct-deq "INT" "INT" (nvint-deq) (nvint-deq))
nvni)
nvni_) (nvbnot (nvdeq-member (lambda (nva)
(lambda (nvb)
(if (string= nva nvb)
(make-inl :val (make-axiom))
(make-inr :val (make-axiom))))) nvsender nvz)))))))))))))

(defun nvaneris_23_v1_addvote (nvCmd)
(declare (ignore nvCmd))
(lambda (nvzf)
(let ((pair nvzf))
(let ((nvzg (pair-fst pair))
(nvsender (pair-snd pair)))
(let ((pair nvzg))
(let ((nvni (pair-fst pair))
(nvc (pair-snd pair)))
(declare (ignore nvni))
(lambda (nvz)
(let ((pair nvz))
(let ((nvcmds (pair-fst pair))
(nvz (pair-snd pair)))
(make-pair :fst (make-pair :fst nvc :snd nvcmds) :snd (make-pair :fst nvsender :snd nvz)))))))))))

(defun nvaneris_23_v1_add_to_quorum (nvCmd)
(lambda (nvni)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvvt)
(lambda (nvstate)
(if (inl-p (funcall (funcall (funcall (nvaneris_23_v1_newvote nvCmd)
nvni)
nvvt)
nvstate))
(funcall (funcall (nvaneris_23_v1_addvote nvCmd)
nvvt)
nvstate)
nvstate))))))

(defun nvlist (nvT)
(declare (ignore nvT))
"REC")

(defun nvaneris_cmd_deq (nvCid nvOp nveq_Cid nveq_Op)
(nvunion-deq "PRODUCT" "PRODUCT" (nvproduct-deq nvCid (nvlist "ATOM") nveq_Cid (nvlist-deq (nvatom-deq))) (nvproduct-deq nvCid nvOp nveq_Cid nveq_Op)))

(defun nvposs-maj (nveq nvL nvx)
(funcall (funcall (fix (lambda (nvlist_accum)
(lambda (nvy)
(lambda (nvL)
(if (pair-p nvL)
(let ((pair nvL))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(funcall (funcall (funcall nvlist_accum)
(let ((pair nvy))
(let ((nvn (pair-fst pair))
(nvx (pair-snd pair)))
(if (inl-p (funcall (funcall nveq
nvh)
nvx))
(make-pair :fst (+ nvn 1) :snd nvx)
(if (inl-p (nveq_int nvn 0))
(make-pair :fst 1 :snd nvh)
(make-pair :fst (- nvn 1) :snd nvx))))))
nvt)))
(if (axiom-p nvL)
nvy
(error "bottom")))))))
(make-pair :fst 0 :snd nvx))
nvL))

(defun nvaneris_23_v1_decided_send (nvCmd nvnotify nvpropose nvf)
(declare (ignore nvCmd))
(declare (ignore nvnotify))
(declare (ignore nvpropose))
(declare (ignore nvf))
(lambda (nvl)
(lambda (nvz)
(nvmk-msg-interface nvl (nvmake-Msg (make-pair :fst "aneris_23_v1" :snd (make-pair :fst "decided" :snd (make-axiom))) nvz)))))

(defun nvaneris_23_v1_retry_send (nvCmd nvnotify nvpropose nvf)
(declare (ignore nvCmd))
(declare (ignore nvnotify))
(declare (ignore nvpropose))
(declare (ignore nvf))
(lambda (nvl)
(lambda (nvz)
(nvmk-msg-interface nvl (nvmake-Msg (make-pair :fst "aneris_23_v1" :snd (make-pair :fst "retry" :snd (make-axiom))) nvz)))))

(defun nvaneris_23_v1_roundout (nvCmd nvcmdeq nvcoeff nvflrs nvnotify nvpropose nvf)
(lambda (nvloc)
(lambda (nvza)
(let ((pair nvza))
(let ((nvzb (pair-fst pair))
(nvsender (pair-snd pair)))
(declare (ignore nvsender))
(let ((pair nvzb))
(let ((nvzc (pair-fst pair))
(nvc (pair-snd pair)))
(let ((pair nvzc))
(let ((nvn (pair-fst pair))
(nvi (pair-snd pair)))
(lambda (nvz)
(let ((pair nvz))
(let ((nvcmds (pair-fst pair))
(nvz (pair-snd pair)))
(declare (ignore nvz))
(if (inl-p (nveq_int (nvlength nvcmds) (* nvcoeff nvflrs)))
(let ((pair (nvposs-maj nvcmdeq (make-pair :fst nvc :snd nvcmds) nvc)))
(let ((nvk (pair-fst pair))
(nvx (pair-snd pair)))
(if (inl-p (nveq_int nvk (+ (* nvcoeff nvflrs) 1)))
(nvsingle-bag (funcall (funcall (nvaneris_23_v1_decided_send nvCmd nvnotify nvpropose nvf)
nvloc)
(make-pair :fst nvn :snd nvx)))
(nvsingle-bag (funcall (funcall (nvaneris_23_v1_retry_send nvCmd nvnotify nvpropose nvf)
nvloc)
(make-pair :fst (make-pair :fst nvn :snd (+ nvi 1)) :snd nvx))))))
(make-axiom))))))))))))))

(defun nvaneris_23_v1_when_quorum (nvCmd nvcmdeq nvcoeff nvflrs nvnotify nvpropose nvf)
(lambda (nvni)
(lambda (nvloc)
(lambda (nvvt)
(lambda (nvstate)
(if (inl-p (funcall (funcall (funcall (nvaneris_23_v1_newvote nvCmd)
nvni)
nvvt)
nvstate))
(funcall (funcall (funcall (nvaneris_23_v1_roundout nvCmd nvcmdeq nvcoeff nvflrs nvnotify nvpropose nvf)
nvloc)
nvvt)
nvstate)
(make-axiom)))))))

(defun nvaneris_23_v1_vote_broadcast (nvCmd nvnotify nvpropose nvf)
(declare (ignore nvCmd))
(declare (ignore nvnotify))
(declare (ignore nvpropose))
(declare (ignore nvf))
(lambda (nvlocs)
(lambda (nvz)
(nvbag-map (lambda (nvl)
(nvmk-msg-interface nvl (nvmake-Msg (make-pair :fst "aneris_23_v1" :snd (make-pair :fst "vote" :snd (make-axiom))) nvz))) nvlocs))))

(defun nvaneris_23_v1_notify_broadcast (nvCmd nvnotify nvpropose nvf)
(declare (ignore nvCmd))
(declare (ignore nvpropose))
(declare (ignore nvf))
(lambda (nvlocs)
(lambda (nvz)
(nvbag-map (lambda (nvl)
(nvmk-msg-interface nvl (nvmake-Msg nvnotify nvz))) nvlocs))))

(defun nvaneris_23_v1_decision (nvCmd nvclients nvnotify nvpropose nvf)
(lambda (nvn)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvz)
(let ((pair nvz))
(let ((nvm (pair-fst pair))
(nvc (pair-snd pair)))
(if (inl-p (nveq_int nvm nvn))
(funcall (funcall (nvaneris_23_v1_notify_broadcast nvCmd nvnotify nvpropose nvf)
nvclients)
(make-pair :fst nvm :snd nvc))
(make-axiom))))))))

(defun nvaneris_23_v1_when_new_round (nvCmd)
(declare (ignore nvCmd))
(lambda (nvn)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvz)
(let ((pair nvz))
(let ((nvz (pair-fst pair))
(nvc (pair-snd pair)))
(let ((pair nvz))
(let ((nvm (pair-fst pair))
(nvi (pair-snd pair)))
(lambda (nvround)
(if (inl-p (nvband (nveq_int nvn nvm) (nvlt_int nvround nvi)))
(nvsingle-bag (make-pair :fst (make-pair :fst nvm :snd nvi) :snd nvc))
(make-axiom)))))))))))

(defun nvaneris_23_v1_vote2retry (nvCmd)
(declare (ignore nvCmd))
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvz)
(let ((pair nvz))
(let ((nvz (pair-fst pair))
(nvsender (pair-snd pair)))
(declare (ignore nvsender))
(let ((pair nvz))
(let ((nvni (pair-fst pair))
(nvc (pair-snd pair)))
(nvsingle-bag (make-pair :fst nvni :snd nvc)))))))))

(defun nvaneris_23_v1_update_round (nvCmd)
(declare (ignore nvCmd))
(lambda (nvn)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvz)
(let ((pair nvz))
(let ((nvz (pair-fst pair))
(nvc (pair-snd pair)))
(declare (ignore nvc))
(let ((pair nvz))
(let ((nvm (pair-fst pair))
(nvi (pair-snd pair)))
(lambda (nvround)
(if (inl-p (nvband (nveq_int nvn nvm) (nvlt_int nvround nvi)))
nvi
nvround))))))))))

(defun nvaneris_v1_out_tr (nvCid nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtt_propose nvf)
(declare (ignore nvCid))
(declare (ignore nvOp))
(declare (ignore nvbcast))
(declare (ignore nvdecision))
(declare (ignore nvpax_propose))
(declare (ignore nvresponse))
(declare (ignore nvswap))
(declare (ignore nvtt_propose))
(declare (ignore nvf))
(lambda (nvtr)
(lambda (nvloc)
(declare (ignore nvloc))
(lambda (nvx)
(lambda (nvz)
(let ((pair nvz))
(let ((nva (pair-fst pair))
(nvz (pair-snd pair)))
(declare (ignore nvz))
(funcall (funcall nvtr
nvx)
nva))))))))

(defun nvaneris_v1_same_command (nvCid nvOp nveq_Cid)
(declare (ignore nvCid))
(declare (ignore nvOp))
(lambda (nvza)
(let ((pair nvza))
(let ((nvcid1 (pair-fst pair))
(nvop1 (pair-snd pair)))
(declare (ignore nvop1))
(lambda (nvz)
(let ((pair nvz))
(let ((nvcid2 (pair-fst pair))
(nvop2 (pair-snd pair)))
(declare (ignore nvop2))
(funcall (funcall nveq_Cid
nvcid1)
nvcid2))))))))

(defun nvaneris_v1_same_command_tag (nvCid nvOp nveq_Cid)
(lambda (nvcmdt1)
(lambda (nvcmdt2)
(let ((dec nvcmdt1))
(if (inl-p dec)
(let ((nvnp1 (inl-val dec)))
(let ((dec nvcmdt2))
(if (inl-p dec)
(let ((nvnp2 (inl-val dec)))
(funcall (funcall (nvproduct-deq nvCid (nvlist "ATOM") nveq_Cid (nvlist-deq (nvatom-deq)))
nvnp1)
nvnp2))
(if (inr-p dec)
(let ((nvcmd2 (inr-val dec)))
(declare (ignore nvcmd2))
(nvbfalse))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(if (inr-p dec)
(let ((nvcmd1 (inr-val dec)))
(let ((dec nvcmdt2))
(if (inl-p dec)
(let ((nvnp2 (inl-val dec)))
(declare (ignore nvnp2))
(nvbfalse))
(if (inr-p dec)
(let ((nvcmd2 (inr-val dec)))
(funcall (funcall (nvaneris_v1_same_command nvCid nvOp nveq_Cid)
nvcmd1)
nvcmd2))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))

(defun nvaneris_v1_pax_propose_broadcast (nvCid nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtt_propose nvf)
(declare (ignore nvCid))
(declare (ignore nvOp))
(declare (ignore nvbcast))
(declare (ignore nvdecision))
(declare (ignore nvresponse))
(declare (ignore nvswap))
(declare (ignore nvtt_propose))
(declare (ignore nvf))
(lambda (nvlocs)
(lambda (nvz)
(nvbag-map (lambda (nvl)
(nvmk-msg-interface nvl (nvmake-Msg nvpax_propose nvz))) nvlocs))))

(defun nvaneris_v1_tt_propose_broadcast (nvCid nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtt_propose nvf)
(declare (ignore nvCid))
(declare (ignore nvOp))
(declare (ignore nvbcast))
(declare (ignore nvdecision))
(declare (ignore nvpax_propose))
(declare (ignore nvresponse))
(declare (ignore nvswap))
(declare (ignore nvf))
(lambda (nvlocs)
(lambda (nvz)
(nvbag-map (lambda (nvl)
(nvmk-msg-interface nvl (nvmake-Msg nvtt_propose nvz))) nvlocs))))

(defun nvaneris_v1_propose (nvCid nvOp nvbcast nvdecision nveq_Cid nvpax_procs nvpax_propose nvresponse nvswap nvtt_procs nvtt_propose nvf)
(lambda (nvcmdt)
(lambda (nvz)
(let ((pair nvz))
(let ((nva (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvb (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvc (pair-fst pair))
(nvzz3 (pair-snd pair)))
(let ((pair nvzz3))
(let ((nvd (pair-fst pair))
(nve (pair-snd pair)))
(funcall (lambda (nvx)
(funcall (lambda (nvx_)
(make-pair :fst (make-pair :fst nva :snd (make-pair :fst (nvbtrue) :snd (make-pair :fst nvx :snd (make-pair :fst nvd :snd nve)))) :snd nvx_))
(if (inl-p (nvbor nvb (nvreduce (lambda (nvx)
(lambda (nvp)
(nvbor (funcall (funcall (nvaneris_v1_same_command_tag nvCid nvOp nveq_Cid)
nvcmdt)
nvx) nvp))) (nvbfalse) (nvmap (lambda (nvx_)
(nvpi2 nvx_)) nvd))))
(make-axiom)
(if (inl-p (funcall (funcall (nvlist-deq (nvatom-deq))
nve)
(make-pair :fst "paxos" :snd (make-axiom))))
(funcall (funcall (nvaneris_v1_pax_propose_broadcast nvCid nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtt_propose nvf)
nvpax_procs)
(make-pair :fst nva :snd nvcmdt))
(if (inl-p (funcall (funcall (nvlist-deq (nvatom-deq))
nve)
(make-pair :fst "2/3" :snd (make-axiom))))
(funcall (funcall (nvaneris_v1_tt_propose_broadcast nvCid nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtt_propose nvf)
nvtt_procs)
(make-pair :fst nva :snd nvcmdt))
(make-axiom))))))
(if (inl-p (nvreduce (lambda (nvx)
(lambda (nvp)
(nvbor (funcall (funcall (nvaneris_v1_same_command_tag nvCid nvOp nveq_Cid)
nvcmdt)
nvx) nvp))) (nvbfalse) (nvappend (nvmap (lambda (nvx)
(nvpi2 nvx)) nvd) nvc)))
nvc
(nvappend nvc (make-pair :fst nvcmdt :snd (make-axiom))))))))))))))))

(defun nvaneris_v1_propose_inl (nvCid nvOp nvbcast nvdecision nveq_Cid nvpax_procs nvpax_propose nvresponse nvswap nvtt_procs nvtt_propose nvf)
(lambda (nvnp)
(lambda (nvstate)
(funcall (funcall (nvaneris_v1_propose nvCid nvOp nvbcast nvdecision nveq_Cid nvpax_procs nvpax_propose nvresponse nvswap nvtt_procs nvtt_propose nvf)
(make-inl :val nvnp))
nvstate))))

(defun nvaneris_v1_propose_inr (nvCid nvOp nvbcast nvdecision nveq_Cid nvpax_procs nvpax_propose nvresponse nvswap nvtt_procs nvtt_propose nvf)
(lambda (nvcmd)
(lambda (nvstate)
(funcall (funcall (nvaneris_v1_propose nvCid nvOp nvbcast nvdecision nveq_Cid nvpax_procs nvpax_propose nvresponse nvswap nvtt_procs nvtt_propose nvf)
(make-inr :val nvcmd))
nvstate))))

(defun nvaneris_v1_iterate_tr (nvCid nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtt_propose nvf)
(declare (ignore nvCid))
(declare (ignore nvOp))
(declare (ignore nvbcast))
(declare (ignore nvdecision))
(declare (ignore nvpax_propose))
(declare (ignore nvresponse))
(declare (ignore nvswap))
(declare (ignore nvtt_propose))
(declare (ignore nvf))
(lambda (nvtr)
(lambda (nvinit)
(lambda (nvops)
(funcall (funcall (fix (lambda (nvlist_accum)
(lambda (nvy)
(lambda (nvL)
(if (pair-p nvL)
(let ((pair nvL))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(funcall (funcall (funcall nvlist_accum)
(funcall (let ((pair nvy))
(let ((nva (pair-fst pair))
(nvb (pair-snd pair)))
(lambda (nvx)
(let ((pair (funcall (funcall nvtr
nvx)
nva)))
(let ((nvs_ (pair-fst pair))
(nvb_ (pair-snd pair)))
(make-pair :fst nvs_ :snd (nvbag-append nvb nvb_)))))))
nvh))
nvt)))
(if (axiom-p nvL)
nvy
(error "bottom")))))))
(make-pair :fst nvinit :snd (make-axiom)))
nvops)))))

(defun nvaneris_v1_response_broadcast (nvCid nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtt_propose nvf)
(declare (ignore nvCid))
(declare (ignore nvOp))
(declare (ignore nvbcast))
(declare (ignore nvdecision))
(declare (ignore nvpax_propose))
(declare (ignore nvswap))
(declare (ignore nvtt_propose))
(declare (ignore nvf))
(lambda (nvlocs)
(lambda (nvz)
(nvbag-map (lambda (nvl)
(nvmk-msg-interface nvl (nvmake-Msg nvresponse nvz))) nvlocs))))

(defun nvaneris_v1_perform (nvCid nvOp nvbcast nvclients nvdecision nvpax_propose nvresponse nvswap nvtt_propose nvf)
(lambda (nvcmdt)
(lambda (nvslot_num)
(lambda (nvprotocol)
(funcall (lambda (nvx)
(make-pair :fst (+ nvslot_num 1) :snd (make-pair :fst nvx :snd (funcall (funcall (nvaneris_v1_response_broadcast nvCid nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtt_propose nvf)
nvclients)
(make-pair :fst nvslot_num :snd nvcmdt)))))
(let ((dec nvcmdt))
(if (inl-p dec)
(let ((nvz (inl-val dec)))
(let ((pair nvz))
(let ((nvcid (pair-fst pair))
(nvnew_protocol (pair-snd pair)))
(declare (ignore nvcid))
nvnew_protocol)))
(if (inr-p dec)
(let ((nvz (inr-val dec)))
(let ((pair nvz))
(let ((nvcid (pair-fst pair))
(nvopr (pair-snd pair)))
(declare (ignore nvcid))
(declare (ignore nvopr))
nvprotocol)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))))

(defun nvaneris_v1_on_slot_num_cmd (nvCid nvOp nvbcast nvclients nvdecision nvpax_propose nvresponse nvswap nvtt_propose nvf)
(lambda (nvcmdt)
(lambda (nvz)
(let ((pair nvz))
(let ((nva (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvb (pair-fst pair))
(nvzz2 (pair-snd pair)))
(declare (ignore nvb))
(let ((pair nvzz2))
(let ((nvc (pair-fst pair))
(nvzz3 (pair-snd pair)))
(let ((pair nvzz3))
(let ((nvd (pair-fst pair))
(nve (pair-snd pair)))
(let ((pair (funcall (funcall (funcall (nvaneris_v1_perform nvCid nvOp nvbcast nvclients nvdecision nvpax_propose nvresponse nvswap nvtt_propose nvf)
nvcmdt)
nva)
nve)))
(let ((nvx (pair-fst pair))
(nvzz (pair-snd pair)))
(let ((pair nvzz))
(let ((nvy (pair-fst pair))
(nvz (pair-snd pair)))
(make-pair :fst (make-pair :fst nvx :snd (make-pair :fst (nvbfalse) :snd (make-pair :fst nvc :snd (make-pair :fst nvd :snd nvy)))) :snd nvz))))))))))))))))

(defun nvmapfilter (nvf nvP nvL)
(nvmap nvf (nvfilter nvP nvL)))

(defun nvaneris_v1_on_slot_num (nvCid nvOp nvbcast nvclients nvdecision nvpax_propose nvresponse nvswap nvtt_propose nvf)
(lambda (nvs)
(lambda (nvzc)
(let ((pair nvzc))
(let ((nva (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvb (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvc (pair-fst pair))
(nvzz3 (pair-snd pair)))
(let ((pair nvzz3))
(let ((nvd (pair-fst pair))
(nve (pair-snd pair)))
(if (inl-p (nveq_int nvs nva))
(funcall (lambda (nvx)
(funcall (funcall (funcall (nvaneris_v1_iterate_tr nvCid nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtt_propose nvf)
(nvaneris_v1_on_slot_num_cmd nvCid nvOp nvbcast nvclients nvdecision nvpax_propose nvresponse nvswap nvtt_propose nvf))
(make-pair :fst nva :snd (make-pair :fst nvb :snd (make-pair :fst nvc :snd (make-pair :fst nvd :snd nve)))))
nvx))
(nvmapfilter (lambda (nvx)
(nvpi2 nvx)) (lambda (nvz)
(let ((pair nvz))
(let ((nvs (pair-fst pair))
(nvz (pair-snd pair)))
(declare (ignore nvz))
(nveq_int nvs nva)))) nvd))
(make-pair :fst (make-pair :fst nva :snd (make-pair :fst nvb :snd (make-pair :fst nvc :snd (make-pair :fst nvd :snd nve)))) :snd (make-axiom))))))))))))))

(defun nvhd (nvl)
(funcall (fix (lambda (nvlist_ind)
(declare (ignore nvlist_ind))
(lambda (nvL)
(if (pair-p nvL)
(let ((pair nvL))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(declare (ignore nvt))
nvh))
(if (axiom-p nvL)
(make-axiom)
(error "bottom"))))))
nvl))

(defun nvquicksort (nvcmp nvL)
(funcall (fix (lambda (nvquicksort)
(lambda (nvL)
(if (inl-p (nvnull nvL))
nvL
(let ((nvx (nvhd nvL)))
(let ((nvL1 (nvfilter (lambda (nvz)
(nvlt_int 0 (funcall (funcall nvcmp
nvz)
nvx))) nvL)))
(let ((nvL2 (nvfilter (lambda (nvz)
(nvlt_int 0 (funcall (funcall nvcmp
nvx)
nvz))) nvL)))
(let ((nvL3 (nvfilter (lambda (nvz)
(nveq_int 0 (funcall (funcall nvcmp
nvx)
nvz))) nvL)))
(nvappend (funcall (funcall nvquicksort)
nvL1) (nvappend nvL3 (funcall (funcall nvquicksort)
nvL2)))))))))))
nvL))

(defun nvquicksort-int (nvL)
(nvquicksort (lambda (nvi)
(lambda (nvj)
(- nvj nvi))) nvL))

(defun nvaneris_v1_diff_command_tag (nvCid nvOp nveq_Cid)
(lambda (nvcmdt1)
(lambda (nvcmdt2)
(nvbnot (funcall (funcall (nvaneris_v1_same_command_tag nvCid nvOp nveq_Cid)
nvcmdt1)
nvcmdt2)))))

(defun nvaneris_v1_greater_eq_proposal (nvCid nvOp nveq_Cid)
(lambda (nvzb)
(let ((pair nvzb))
(let ((nvslt1 (pair-fst pair))
(nvcmdt1 (pair-snd pair)))
(lambda (nvz)
(let ((pair nvz))
(let ((nvslt2 (pair-fst pair))
(nvcmdt2 (pair-snd pair)))
(nvband (nvle_int nvslt2 nvslt1) (funcall (funcall (nvaneris_v1_same_command_tag nvCid nvOp nveq_Cid)
nvcmdt1)
nvcmdt2)))))))))

(defun nvaneris_v1_on_decision (nvCid nvOp nvbcast nvclients nvdecision nveq_Cid nvpax_procs nvpax_propose nvresponse nvswap nvtt_procs nvtt_propose nvf)
(lambda (nvze)
(let ((pair nvze))
(let ((nvs (pair-fst pair))
(nvcmdt (pair-snd pair)))
(lambda (nvzd)
(let ((pair nvzd))
(let ((nva (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvb (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvc (pair-fst pair))
(nvzz3 (pair-snd pair)))
(let ((pair nvzz3))
(let ((nvd (pair-fst pair))
(nve (pair-snd pair)))
(funcall (lambda (nvx)
(funcall (lambda (nvx_)
(funcall (lambda (nvx__)
(let ((pair (funcall (funcall (funcall (nvaneris_v1_iterate_tr nvCid nvOp nvbcast nvdecision nvpax_propose nvresponse nvswap nvtt_propose nvf)
(nvaneris_v1_on_slot_num nvCid nvOp nvbcast nvclients nvdecision nvpax_propose nvresponse nvswap nvtt_propose nvf))
(make-pair :fst nva :snd (make-pair :fst nvb :snd (make-pair :fst nvx_ :snd (make-pair :fst nvx :snd nve)))))
nvx__)))
(let ((nvz (pair-fst pair))
(nvmsgs1 (pair-snd pair)))
(let ((pair nvz))
(let ((nva (pair-fst pair))
(nvzz1 (pair-snd pair)))
(let ((pair nvzz1))
(let ((nvb (pair-fst pair))
(nvzz2 (pair-snd pair)))
(let ((pair nvzz2))
(let ((nvc (pair-fst pair))
(nvzz3 (pair-snd pair)))
(let ((pair nvzz3))
(let ((nvd (pair-fst pair))
(nve (pair-snd pair)))
(let ((pair (if (inl-p (nvbnot (nvnull nvc)))
(funcall (funcall (nvaneris_v1_propose nvCid nvOp nvbcast nvdecision nveq_Cid nvpax_procs nvpax_propose nvresponse nvswap nvtt_procs nvtt_propose nvf)
(nvhd nvc))
(make-pair :fst nva :snd (make-pair :fst nvb :snd (make-pair :fst nvc :snd (make-pair :fst nvd :snd nve)))))
(make-pair :fst (make-pair :fst nva :snd (make-pair :fst nvb :snd (make-pair :fst nvc :snd (make-pair :fst nvd :snd nve)))) :snd (make-axiom)))))
(let ((nvstate (pair-fst pair))
(nvmsgs2 (pair-snd pair)))
(make-pair :fst nvstate :snd (nvbag-append nvmsgs1 nvmsgs2)))))))))))))))
(nvquicksort-int (nvmap (lambda (nvx__)
(nvpi1 nvx__)) nvx))))
(nvfilter (funcall (nvaneris_v1_diff_command_tag nvCid nvOp nveq_Cid)
nvcmdt) nvc)))
(if (inl-p (nvreduce (lambda (nvx)
(lambda (nvp)
(nvbor (funcall (funcall (nvaneris_v1_greater_eq_proposal nvCid nvOp nveq_Cid)
(make-pair :fst nva :snd nvcmdt))
nvx) nvp))) (nvbfalse) nvd))
nvd
(make-pair :fst (make-pair :fst nvs :snd nvcmdt) :snd nvd))))))))))))))))

(defun main ()
(lambda (nvCid)
(lambda (nvOp)
(lambda (nveq_Cid)
(lambda (nveq_Op)
(lambda (nvaccpts)
(lambda (nvldrs)
(lambda (nvldrs_uid)
(lambda (nvlocs)
(lambda (nvreps)
(lambda (nvclients)
(lambda (nvflrs)
(lambda (nvi)
(nvhdf-parallel (nvhdf-parallel (let ((dec (nvdeq-member (lambda (nva)
(lambda (nvb)
(if (string= nva nvb)
(make-inl :val (make-axiom))
(make-inr :val (make-axiom))))) nvi nvldrs)))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
(nvhdf-parallel (nvhdf-parallel (nvhdf-parallel (nvhdf-parallel (nvhdf-bind (make-inl :val (lambda (nvm)
(declare (ignore nvm))
(make-pair :fst (make-inr :val (make-axiom)) :snd (make-pair :fst (funcall (lambda (nvloc)
(funcall (lambda (nvx)
(funcall (funcall (fix (lambda (nvlist_accum)
(lambda (nvy)
(lambda (nvL)
(if (pair-p nvL)
(let ((pair nvL))
(let ((nvh (pair-fst pair))
(nvt (pair-snd pair)))
(funcall (funcall (funcall nvlist_accum)
(funcall (lambda (nvx_)
(let ((dec (let ((dec (if (< nvx nvx_)
(make-inl :val (make-axiom))
(make-inr :val (make-axiom)))))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
(make-inr :val (make-axiom)))
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(make-inl :val (make-axiom)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
nvy)
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(let ((dec nvy))
(if (inl-p dec)
(let ((nvl (inl-val dec)))
(let ((dec (if (< nvx_ (funcall nvldrs_uid
nvl))
(make-inl :val (make-axiom))
(make-inr :val (make-axiom)))))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
(make-inl :val nvh))
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
nvy)
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(if (inr-p dec)
(let ((nvz (inr-val dec)))
(declare (ignore nvz))
(make-inl :val nvh))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(funcall nvldrs_uid
nvh)))
nvt)))
(if (axiom-p nvL)
nvy
(error "bottom")))))))
(make-inr :val (make-axiom)))
nvldrs))
(funcall nvldrs_uid
nvloc)))
nvi) :snd (make-axiom))))) (lambda (nvx)
(let ((dec nvx))
(if (inl-p dec)
(let ((nvl (inl-val dec)))
(nvhdf-parallel (nvhdf-parallel (make-inl :val (lambda (nvm)
(declare (ignore nvm))
(make-pair :fst (make-inr :val (make-axiom)) :snd (make-pair :fst (funcall (funcall (lambda (nvl)
(lambda (nvz)
(make-pair :fst 0 :snd (make-pair :fst nvl :snd (make-pair :fst (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "ping" :snd (make-axiom))) :snd nvz)))))
nvl)
nvi) :snd (make-axiom))))) (make-inl :val (lambda (nvm)
(declare (ignore nvm))
(make-pair :fst (make-inr :val (make-axiom)) :snd (make-pair :fst (funcall (funcall (funcall (lambda (nvn)
(lambda (nvl)
(lambda (nvz)
(make-pair :fst nvn :snd (make-pair :fst nvl :snd (make-pair :fst (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "react" :snd (make-axiom))) :snd nvz))))))
10)
nvi)
(make-axiom)) :snd (make-axiom)))))) (funcall (fix (lambda (nvmk-hdf)
(lambda (nvs)
(make-inl :val (lambda (nva)
(let ((pair nva))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(declare (ignore nvy))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "react" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv4 (nvmap (lambda (nvz)
(declare (ignore nvz))
(make-inr :val (make-axiom))) nvs)))
(let ((dec (nvbag-null nvv4)))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv5 nvs))
(let ((nvv6 (nvbag-union (nvbag-map (lambda (nvx)
(let ((dec nvx))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
(make-pair :fst (funcall (funcall (lambda (nvl)
(lambda (nvz)
(make-pair :fst 0 :snd (make-pair :fst nvl :snd (make-pair :fst (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "ping" :snd (make-axiom))) :snd nvz)))))
nvl)
nvi) :snd (make-pair :fst (funcall (funcall (funcall (lambda (nvn)
(lambda (nvl)
(lambda (nvz)
(make-pair :fst nvn :snd (make-pair :fst nvl :snd (make-pair :fst (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "react" :snd (make-axiom))) :snd nvz))))))
10)
nvi)
(make-axiom)) :snd (make-axiom))))
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(make-pair :fst (funcall (funcall (lambda (nvl)
(lambda (nvz)
(make-pair :fst 0 :snd (make-pair :fst nvl :snd (make-pair :fst (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "start" :snd (make-axiom))) :snd nvz)))))
nvi)
(make-axiom)) :snd (make-axiom)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))) nvs))))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv5) :snd nvv6))))
(if (inr-p dec)
(let ((nvy1 (inr-val dec)))
(declare (ignore nvy1))
(let ((nvv6 (nvbag-union (nvbag-map (lambda (nvx)
(let ((dec nvx))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
(make-pair :fst (funcall (funcall (lambda (nvl)
(lambda (nvz)
(make-pair :fst 0 :snd (make-pair :fst nvl :snd (make-pair :fst (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "ping" :snd (make-axiom))) :snd nvz)))))
nvl)
nvi) :snd (make-pair :fst (funcall (funcall (funcall (lambda (nvn)
(lambda (nvl)
(lambda (nvz)
(make-pair :fst nvn :snd (make-pair :fst nvl :snd (make-pair :fst (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "react" :snd (make-axiom))) :snd nvz))))))
10)
nvi)
(make-axiom)) :snd (make-axiom))))
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(make-pair :fst (funcall (funcall (lambda (nvl)
(lambda (nvz)
(make-pair :fst 0 :snd (make-pair :fst nvl :snd (make-pair :fst (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "start" :snd (make-axiom))) :snd nvz)))))
nvi)
(make-axiom)) :snd (make-axiom)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))) nvs))))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv4) :snd nvv6)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))
(if (inr-p dec)
(let ((nvy1 (inr-val dec)))
(declare (ignore nvy1))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "pong" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv4 (nvmap (lambda (nvz)
(declare (ignore nvz))
(make-inl :val (make-axiom))) nvs)))
(let ((dec (nvbag-null nvv4)))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv5 nvs))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv5) :snd (make-axiom))))
(if (inr-p dec)
(let ((nvy1 (inr-val dec)))
(declare (ignore nvy1))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv4) :snd (make-axiom)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))
(if (inr-p dec)
(let ((nvy1@0 (inr-val dec)))
(declare (ignore nvy1@0))
(let ((nvv5 nvs))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv5) :snd (make-axiom))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))))))
(make-pair :fst (make-inr :val (make-axiom)) :snd (make-axiom)))))
(if (inr-p dec)
(let ((nvz (inr-val dec)))
(declare (ignore nvz))
(funcall (fix (lambda (nvmk-hdf)
(lambda (nvs)
(make-inl :val (lambda (nvv)
(let ((pair nvs))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((pair nvv))
(let ((nvx1 (pair-fst pair))
(nvy1 (pair-snd pair)))
(let ((dec (nvname_eq nvx1 (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p1b" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nvx2 (inl-val dec)))
(declare (ignore nvx2))
(let ((nvv1 (funcall (funcall (funcall (nvaneris_pax_v1_scout_output "UNION" nvaccpts (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (nvaneris_v1_full_headers_fun nvCid nvOp))
(funcall (funcall (nvaneris_pax_v1_mk_bnum)
0)
nvi))
nvi)
nvy1)))
(let ((nvv2 (funcall (funcall (funcall (funcall (nvaneris_pax_v1_on_p1b "UNION" nvldrs_uid)
(funcall (funcall (nvaneris_pax_v1_mk_bnum)
0)
nvi))
nvi)
nvy1)
nvy)))
(let ((nvv3 (nvappend (funcall nvv1
nvv2) (make-axiom))))
(let ((dec nvx))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv4 (nvappend (funcall (funcall (nvaneris_pax_v1_p1a_broadcast "UNION" (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (nvaneris_v1_full_headers_fun nvCid nvOp))
nvaccpts)
(make-pair :fst nvi :snd (funcall (funcall (nvaneris_pax_v1_mk_bnum)
0)
nvi))) nvv3)))
(make-pair :fst (let ((dec (nvnull nvv3)))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
(funcall (funcall nvmk-hdf)
(make-pair :fst (make-inr :val (make-axiom)) :snd nvv2)))
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(make-inr :val (make-axiom)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))) :snd nvv4)))
(if (inr-p dec)
(let ((nvx1 (inr-val dec)))
(declare (ignore nvx1))
(make-pair :fst (let ((dec (nvnull nvv3)))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
(funcall (funcall nvmk-hdf)
(make-pair :fst (make-inr :val (make-axiom)) :snd nvv2)))
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(make-inr :val (make-axiom)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))) :snd nvv3))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))))
(if (inr-p dec)
(let ((nvy2 (inr-val dec)))
(declare (ignore nvy2))
(let ((nvv2 nvy))
(let ((dec nvx))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv4 (nvappend (funcall (funcall (nvaneris_pax_v1_p1a_broadcast "UNION" (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (nvaneris_v1_full_headers_fun nvCid nvOp))
nvaccpts)
(make-pair :fst nvi :snd (funcall (funcall (nvaneris_pax_v1_mk_bnum)
0)
nvi))) (make-axiom))))
(make-pair :fst (funcall (funcall nvmk-hdf)
(make-pair :fst (make-inr :val (make-axiom)) :snd nvv2)) :snd nvv4)))
(if (inr-p dec)
(let ((nvx1 (inr-val dec)))
(declare (ignore nvx1))
(make-pair :fst (funcall (funcall nvmk-hdf)
(make-pair :fst (make-inr :val (make-axiom)) :snd nvv2)) :snd (make-axiom)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))))))))
(make-pair :fst (make-inl :val (make-axiom)) :snd (nvaneris_pax_v1_init_scout "UNION" nvaccpts))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))) (nvhdf-bind (nvhdf-once (fix (lambda (nvmk-hdf)
(make-inl :val (lambda (nva)
(make-pair :fst (funcall nvmk-hdf) :snd (let ((pair nva))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "start" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
(make-pair :fst nvy :snd (make-axiom)))
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))))))) (lambda (nvx)
(declare (ignore nvx))
(funcall (fix (lambda (nvmk-hdf)
(lambda (nvs)
(make-inl :val (lambda (nvv)
(let ((pair nvs))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((pair nvv))
(let ((nvx1 (pair-fst pair))
(nvy1 (pair-snd pair)))
(let ((dec (nvname_eq nvx1 (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p1b" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nvx2 (inl-val dec)))
(declare (ignore nvx2))
(let ((nvv1 (funcall (funcall (funcall (nvaneris_pax_v1_scout_output "UNION" nvaccpts (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (nvaneris_v1_full_headers_fun nvCid nvOp))
(funcall (funcall (nvaneris_pax_v1_mk_bnum)
0)
nvi))
nvi)
nvy1)))
(let ((nvv2 (funcall (funcall (funcall (funcall (nvaneris_pax_v1_on_p1b "UNION" nvldrs_uid)
(funcall (funcall (nvaneris_pax_v1_mk_bnum)
0)
nvi))
nvi)
nvy1)
nvy)))
(let ((nvv3 (nvappend (funcall nvv1
nvv2) (make-axiom))))
(let ((dec nvx))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv4 (nvappend (funcall (funcall (nvaneris_pax_v1_p1a_broadcast "UNION" (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (nvaneris_v1_full_headers_fun nvCid nvOp))
nvaccpts)
(make-pair :fst nvi :snd (funcall (funcall (nvaneris_pax_v1_mk_bnum)
0)
nvi))) nvv3)))
(make-pair :fst (let ((dec (nvnull nvv3)))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
(funcall (funcall nvmk-hdf)
(make-pair :fst (make-inr :val (make-axiom)) :snd nvv2)))
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(make-inr :val (make-axiom)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))) :snd nvv4)))
(if (inr-p dec)
(let ((nvx1 (inr-val dec)))
(declare (ignore nvx1))
(make-pair :fst (let ((dec (nvnull nvv3)))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
(funcall (funcall nvmk-hdf)
(make-pair :fst (make-inr :val (make-axiom)) :snd nvv2)))
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(make-inr :val (make-axiom)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))) :snd nvv3))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))))
(if (inr-p dec)
(let ((nvy2 (inr-val dec)))
(declare (ignore nvy2))
(let ((nvv2 nvy))
(let ((dec nvx))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv4 (nvappend (funcall (funcall (nvaneris_pax_v1_p1a_broadcast "UNION" (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (nvaneris_v1_full_headers_fun nvCid nvOp))
nvaccpts)
(make-pair :fst nvi :snd (funcall (funcall (nvaneris_pax_v1_mk_bnum)
0)
nvi))) (make-axiom))))
(make-pair :fst (funcall (funcall nvmk-hdf)
(make-pair :fst (make-inr :val (make-axiom)) :snd nvv2)) :snd nvv4)))
(if (inr-p dec)
(let ((nvx1 (inr-val dec)))
(declare (ignore nvx1))
(make-pair :fst (funcall (funcall nvmk-hdf)
(make-pair :fst (make-inr :val (make-axiom)) :snd nvv2)) :snd (make-axiom)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))))))))
(make-pair :fst (make-inl :val (make-axiom)) :snd (nvaneris_pax_v1_init_scout "UNION" nvaccpts)))))) (nvhdf-bind (funcall (fix (lambda (nvmk-hdf)
(lambda (nvs)
(make-inl :val (lambda (nva)
(let ((pair nva))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))))))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv10 (nvmap (funcall (funcall (nvaneris_pax_v1_on_propose "UNION")
nvi)
nvy) nvs)))
(let ((dec (nvbag-null nvv10)))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv11 nvs))
(let ((nvv12 (nvbag-union (nvbag-map (lambda (nvx)
(funcall (funcall (funcall (nvaneris_pax_v1_leader_propose "UNION")
nvi)
nvy)
nvx)) nvs))))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv11) :snd nvv12))))
(if (inr-p dec)
(let ((nvy1 (inr-val dec)))
(declare (ignore nvy1))
(let ((nvv12 (nvbag-union (nvbag-map (lambda (nvx)
(funcall (funcall (funcall (nvaneris_pax_v1_leader_propose "UNION")
nvi)
nvy)
nvx)) nvs))))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv10) :snd nvv12)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))
(if (inr-p dec)
(let ((nvy1 (inr-val dec)))
(declare (ignore nvy1))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "adopted" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv1 (funcall (funcall (nvaneris_pax_v1_leader_adopted "UNION")
nvi)
nvy)))
(let ((nvv4 (funcall (funcall (nvaneris_pax_v1_when_adopted "UNION")
nvi)
nvy)))
(let ((nvv10 (nvmap nvv4 nvs)))
(let ((dec (nvbag-null nvv10)))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv11 nvs))
(let ((nvv12 (nvbag-union (nvbag-map (lambda (nvx)
(funcall nvv1
nvx)) nvs))))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv11) :snd nvv12))))
(if (inr-p dec)
(let ((nvy1 (inr-val dec)))
(declare (ignore nvy1))
(let ((nvv12 (nvbag-union (nvbag-map (lambda (nvx)
(funcall nvv1
nvx)) nvs))))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv10) :snd nvv12)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))))
(if (inr-p dec)
(let ((nvy1@0 (inr-val dec)))
(declare (ignore nvy1@0))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "preempted" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv10 (nvmap (funcall (funcall (nvaneris_pax_v1_when_preempted "UNION" nvldrs_uid)
nvi)
nvy) nvs)))
(let ((dec (nvbag-null nvv10)))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv11 nvs))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv11) :snd (make-axiom))))
(if (inr-p dec)
(let ((nvy1 (inr-val dec)))
(declare (ignore nvy1))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv10) :snd (make-axiom)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))
(if (inr-p dec)
(let ((nvy1 (inr-val dec)))
(declare (ignore nvy1))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "decided" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv10 (nvmap (funcall (funcall (nvaneris_pax_v1_when_decided "UNION")
nvi)
nvy) nvs)))
(let ((dec (nvbag-null nvv10)))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv11 nvs))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv11) :snd (make-axiom))))
(if (inr-p dec)
(let ((nvy1 (inr-val dec)))
(declare (ignore nvy1))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv10) :snd (make-axiom)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))
(if (inr-p dec)
(let ((nvy1 (inr-val dec)))
(declare (ignore nvy1))
(let ((nvv11 nvs))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv11) :snd (make-axiom))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))))))
(make-pair :fst (funcall (lambda (nvloc)
(make-pair :fst (funcall (lambda (nvloc)
(funcall (funcall (lambda (nvn)
(lambda (nvloc)
(make-inl :val (make-pair :fst nvn :snd nvloc))))
0)
nvloc))
nvloc) :snd (make-pair :fst (make-inr :val (make-axiom)) :snd (make-pair :fst (make-axiom) :snd (make-pair :fst 0 :snd (make-axiom))))))
nvi) :snd (make-axiom))) (lambda (nvx)
(nvhdf-parallel (make-inl :val (lambda (nvm)
(declare (ignore nvm))
(make-pair :fst (make-inr :val (make-axiom)) :snd (funcall (funcall (nvaneris_pax_v1_p2a_broadcast "UNION" (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (nvaneris_v1_full_headers_fun nvCid nvOp))
nvaccpts)
(make-pair :fst nvi :snd nvx))))) (let ((pair (funcall (nvaneris_pax_v1_dest_pv "UNION")
nvx)))
(let ((nvbnum (pair-fst pair))
(nvzz (pair-snd pair)))
(let ((pair nvzz))
(let ((nvslt (pair-fst pair))
(nvcmd (pair-snd pair)))
(declare (ignore nvcmd))
(funcall (fix (lambda (nvmk-hdf)
(lambda (nvs)
(make-inl :val (lambda (nvv)
(let ((pair nvv))
(let ((nvx1 (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx1 (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p2b" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nvx2 (inl-val dec)))
(declare (ignore nvx2))
(let ((nvv1 (funcall (funcall (funcall (nvaneris_pax_v1_commander_output "UNION" nvaccpts (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) nvldrs (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) nvreps (nvaneris_v1_full_headers_fun nvCid nvOp))
nvx)
nvi)
nvy)))
(let ((nvv2 (funcall (funcall (funcall (funcall (funcall (nvaneris_pax_v1_on_p2b)
nvbnum)
nvslt)
nvi)
nvy)
nvs)))
(let ((nvv3 (nvappend (funcall nvv1
nvv2) (make-axiom))))
(make-pair :fst (let ((dec (nvnull nvv3)))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
(funcall (funcall nvmk-hdf)
nvv2))
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(make-inr :val (make-axiom)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))) :snd nvv3)))))
(if (inr-p dec)
(let ((nvy1 (inr-val dec)))
(declare (ignore nvy1))
(let ((nvv2 nvs))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv2) :snd (make-axiom))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))))))
nvaccpts))))))))) (nvhdf-bind (funcall (fix (lambda (nvmk-hdf)
(lambda (nvs)
(make-inl :val (lambda (nva)
(let ((pair nva))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "preempted" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv8 (nvmap (funcall (funcall (nvaneris_pax_v1_when_preempted "UNION" nvldrs_uid)
nvi)
nvy) nvs)))
(let ((dec (nvbag-null nvv8)))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv9 nvs))
(let ((nvv10 (nvbag-union (nvbag-map (lambda (nvx)
(funcall (funcall (funcall (nvaneris_pax_v1_leader_preempted "UNION" nvldrs_uid)
nvi)
nvy)
nvx)) nvs))))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv9) :snd nvv10))))
(if (inr-p dec)
(let ((nvy1 (inr-val dec)))
(declare (ignore nvy1))
(let ((nvv10 (nvbag-union (nvbag-map (lambda (nvx)
(funcall (funcall (funcall (nvaneris_pax_v1_leader_preempted "UNION" nvldrs_uid)
nvi)
nvy)
nvx)) nvs))))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv8) :snd nvv10)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))
(if (inr-p dec)
(let ((nvy1 (inr-val dec)))
(declare (ignore nvy1))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))))))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv8 (nvmap (funcall (funcall (nvaneris_pax_v1_on_propose "UNION")
nvi)
nvy) nvs)))
(let ((dec (nvbag-null nvv8)))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv9 nvs))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv9) :snd (make-axiom))))
(if (inr-p dec)
(let ((nvy1 (inr-val dec)))
(declare (ignore nvy1))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv8) :snd (make-axiom)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))
(if (inr-p dec)
(let ((nvy1@0 (inr-val dec)))
(declare (ignore nvy1@0))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "adopted" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv2 (funcall (funcall (nvaneris_pax_v1_when_adopted "UNION")
nvi)
nvy)))
(let ((nvv8 (nvmap nvv2 nvs)))
(let ((dec (nvbag-null nvv8)))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv9 nvs))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv9) :snd (make-axiom))))
(if (inr-p dec)
(let ((nvy1 (inr-val dec)))
(declare (ignore nvy1))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv8) :snd (make-axiom)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))
(if (inr-p dec)
(let ((nvy1@0 (inr-val dec)))
(declare (ignore nvy1@0))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "decided" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv8 (nvmap (funcall (funcall (nvaneris_pax_v1_when_decided "UNION")
nvi)
nvy) nvs)))
(let ((dec (nvbag-null nvv8)))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv9 nvs))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv9) :snd (make-axiom))))
(if (inr-p dec)
(let ((nvy1 (inr-val dec)))
(declare (ignore nvy1))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv8) :snd (make-axiom)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))
(if (inr-p dec)
(let ((nvy1 (inr-val dec)))
(declare (ignore nvy1))
(let ((nvv9 nvs))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv9) :snd (make-axiom))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))))))
(make-pair :fst (funcall (lambda (nvloc)
(make-pair :fst (funcall (lambda (nvloc)
(funcall (funcall (lambda (nvn)
(lambda (nvloc)
(make-inl :val (make-pair :fst nvn :snd nvloc))))
0)
nvloc))
nvloc) :snd (make-pair :fst (make-inr :val (make-axiom)) :snd (make-pair :fst (make-axiom) :snd (make-pair :fst 0 :snd (make-axiom))))))
nvi) :snd (make-axiom))) (lambda (nvx)
(funcall (fix (lambda (nvmk-hdf)
(lambda (nvs)
(make-inl :val (lambda (nvv)
(let ((pair nvs))
(let ((nvx1 (pair-fst pair))
(nvy (pair-snd pair)))
(let ((pair nvv))
(let ((nvx2 (pair-fst pair))
(nvy1 (pair-snd pair)))
(let ((dec (nvname_eq nvx2 (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p1b" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nvx3 (inl-val dec)))
(declare (ignore nvx3))
(let ((nvv1 (funcall (funcall (funcall (nvaneris_pax_v1_scout_output "UNION" nvaccpts (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (nvaneris_v1_full_headers_fun nvCid nvOp))
nvx)
nvi)
nvy1)))
(let ((nvv2 (funcall (funcall (funcall (funcall (nvaneris_pax_v1_on_p1b "UNION" nvldrs_uid)
nvx)
nvi)
nvy1)
nvy)))
(let ((nvv3 (nvappend (funcall nvv1
nvv2) (make-axiom))))
(let ((dec nvx1))
(if (inl-p dec)
(let ((nvx2 (inl-val dec)))
(declare (ignore nvx2))
(let ((nvv4 (nvappend (funcall (funcall (nvaneris_pax_v1_p1a_broadcast "UNION" (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (nvaneris_v1_full_headers_fun nvCid nvOp))
nvaccpts)
(make-pair :fst nvi :snd nvx)) nvv3)))
(make-pair :fst (let ((dec (nvnull nvv3)))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
(funcall (funcall nvmk-hdf)
(make-pair :fst (make-inr :val (make-axiom)) :snd nvv2)))
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(make-inr :val (make-axiom)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))) :snd nvv4)))
(if (inr-p dec)
(let ((nvx2 (inr-val dec)))
(declare (ignore nvx2))
(make-pair :fst (let ((dec (nvnull nvv3)))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
(funcall (funcall nvmk-hdf)
(make-pair :fst (make-inr :val (make-axiom)) :snd nvv2)))
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(make-inr :val (make-axiom)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))) :snd nvv3))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))))
(if (inr-p dec)
(let ((nvy2 (inr-val dec)))
(declare (ignore nvy2))
(let ((nvv2 nvy))
(let ((dec nvx1))
(if (inl-p dec)
(let ((nvx2 (inl-val dec)))
(declare (ignore nvx2))
(let ((nvv4 (nvappend (funcall (funcall (nvaneris_pax_v1_p1a_broadcast "UNION" (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (nvaneris_v1_full_headers_fun nvCid nvOp))
nvaccpts)
(make-pair :fst nvi :snd nvx)) (make-axiom))))
(make-pair :fst (funcall (funcall nvmk-hdf)
(make-pair :fst (make-inr :val (make-axiom)) :snd nvv2)) :snd nvv4)))
(if (inr-p dec)
(let ((nvx2 (inr-val dec)))
(declare (ignore nvx2))
(make-pair :fst (funcall (funcall nvmk-hdf)
(make-pair :fst (make-inr :val (make-axiom)) :snd nvv2)) :snd (make-axiom)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))))))))
(make-pair :fst (make-inl :val (make-axiom)) :snd (nvaneris_pax_v1_init_scout "UNION" nvaccpts)))))) (fix (lambda (nvmk-hdf)
(make-inl :val (lambda (nva)
(let ((nvv (nvbag-union (nvbag-map (lambda (nvx)
(make-pair :fst (funcall (funcall (lambda (nvl)
(lambda (nvz)
(make-pair :fst 0 :snd (make-pair :fst nvl :snd (make-pair :fst (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "pong" :snd (make-axiom))) :snd nvz)))))
nvx)
(make-axiom)) :snd (make-axiom))) (let ((pair nva))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "ping" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
(make-pair :fst nvy :snd (make-axiom)))
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))))))
(make-pair :fst (funcall nvmk-hdf) :snd nvv))))))))
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(nvhdf-halt))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))) (let ((dec (nvdeq-member (lambda (nva)
(lambda (nvb)
(if (string= nva nvb)
(make-inl :val (make-axiom))
(make-inr :val (make-axiom))))) nvi nvaccpts)))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
(funcall (fix (lambda (nvmk-hdf)
(lambda (nvs)
(make-inl :val (lambda (nva)
(let ((pair nva))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p1a" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((pair nvy))
(let ((nvldr (pair-fst pair))
(nvbn (pair-snd pair)))
(let ((nvv6 (nvmap (funcall (funcall (nvaneris_pax_v1_on_p1a "UNION" nvldrs_uid)
nvi)
(make-pair :fst nvldr :snd nvbn)) nvs)))
(let ((dec (nvbag-null nvv6)))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv7 nvs))
(let ((nvv8 (nvbag-union (nvbag-map (lambda (nvx)
(let ((pair nvx))
(let ((nvbnum (pair-fst pair))
(nvpvals (pair-snd pair)))
(make-pair :fst (funcall (funcall (lambda (nvl)
(lambda (nvz)
(make-pair :fst 0 :snd (make-pair :fst nvl :snd (make-pair :fst (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p1b" :snd (make-axiom))) :snd nvz)))))
nvldr)
(make-pair :fst nvi :snd (make-pair :fst nvbn :snd (make-pair :fst nvbnum :snd nvpvals)))) :snd (make-axiom))))) nvv7))))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv7) :snd nvv8))))
(if (inr-p dec)
(let ((nvy1 (inr-val dec)))
(declare (ignore nvy1))
(let ((nvv8 (nvbag-union (nvbag-map (lambda (nvx)
(let ((pair nvx))
(let ((nvbnum (pair-fst pair))
(nvpvals (pair-snd pair)))
(make-pair :fst (funcall (funcall (lambda (nvl)
(lambda (nvz)
(make-pair :fst 0 :snd (make-pair :fst nvl :snd (make-pair :fst (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p1b" :snd (make-axiom))) :snd nvz)))))
nvldr)
(make-pair :fst nvi :snd (make-pair :fst nvbn :snd (make-pair :fst nvbnum :snd nvpvals)))) :snd (make-axiom))))) nvv6))))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv6) :snd nvv8)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))))
(if (inr-p dec)
(let ((nvy1 (inr-val dec)))
(declare (ignore nvy1))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p2a" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((pair nvy))
(let ((nvldr (pair-fst pair))
(nvpvalue (pair-snd pair)))
(let ((nvv6 (nvmap (funcall (funcall (nvaneris_pax_v1_on_p2a "UNION" nvldrs_uid)
nvi)
(make-pair :fst nvldr :snd nvpvalue)) nvs)))
(let ((dec (nvbag-null nvv6)))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv7 nvs))
(let ((nvv8 (nvbag-union (nvbag-map (lambda (nvx)
(let ((pair nvx))
(let ((nvbnum (pair-fst pair))
(nvz (pair-snd pair)))
(declare (ignore nvz))
(let ((pair (funcall (nvaneris_pax_v1_dest_pv "UNION")
nvpvalue)))
(let ((nvbn (pair-fst pair))
(nvzz (pair-snd pair)))
(let ((pair nvzz))
(let ((nvslt (pair-fst pair))
(nvcmd (pair-snd pair)))
(declare (ignore nvcmd))
(make-pair :fst (funcall (funcall (lambda (nvl)
(lambda (nvz)
(make-pair :fst 0 :snd (make-pair :fst nvl :snd (make-pair :fst (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p2b" :snd (make-axiom))) :snd nvz)))))
nvldr)
(make-pair :fst nvi :snd (make-pair :fst nvbn :snd (make-pair :fst nvslt :snd nvbnum)))) :snd (make-axiom))))))))) nvv7))))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv7) :snd nvv8))))
(if (inr-p dec)
(let ((nvy1 (inr-val dec)))
(declare (ignore nvy1))
(let ((nvv8 (nvbag-union (nvbag-map (lambda (nvx)
(let ((pair nvx))
(let ((nvbnum (pair-fst pair))
(nvz (pair-snd pair)))
(declare (ignore nvz))
(let ((pair (funcall (nvaneris_pax_v1_dest_pv "UNION")
nvpvalue)))
(let ((nvbn (pair-fst pair))
(nvzz (pair-snd pair)))
(let ((pair nvzz))
(let ((nvslt (pair-fst pair))
(nvcmd (pair-snd pair)))
(declare (ignore nvcmd))
(make-pair :fst (funcall (funcall (lambda (nvl)
(lambda (nvz)
(make-pair :fst 0 :snd (make-pair :fst nvl :snd (make-pair :fst (make-pair :fst "aneris_pax_v1" :snd (make-pair :fst "p2b" :snd (make-axiom))) :snd nvz)))))
nvldr)
(make-pair :fst nvi :snd (make-pair :fst nvbn :snd (make-pair :fst nvslt :snd nvbnum)))) :snd (make-axiom))))))))) nvv6))))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv6) :snd nvv8)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))))
(if (inr-p dec)
(let ((nvy1@0 (inr-val dec)))
(declare (ignore nvy1@0))
(let ((nvv7 nvs))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv7) :snd (make-axiom))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))))))
(make-pair :fst (make-pair :fst (make-inr :val (make-axiom)) :snd (make-axiom)) :snd (make-axiom))))
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(nvhdf-halt))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))) (nvhdf-parallel (let ((dec (nvdeq-member (lambda (nva)
(lambda (nvb)
(if (string= nva nvb)
(make-inl :val (make-axiom))
(make-inr :val (make-axiom))))) nvi nvlocs)))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
(nvhdf-bind (nvhdf-compose2 (nvhdf-compose1 (funcall (nvaneris_23_v1_when_new_proposal "UNION")
nvi) (nvhdf-parallel (fix (lambda (nvmk-hdf)
(make-inl :val (lambda (nva)
(make-pair :fst (funcall nvmk-hdf) :snd (let ((pair nva))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom)))))))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
(make-pair :fst nvy :snd (make-axiom)))
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))))))) (fix (lambda (nvmk-hdf)
(make-inl :val (lambda (nva)
(let ((nvv (nvbag-union (nvbag-map (lambda (nvx)
(funcall (funcall (nvaneris_23_v1_vote2prop "UNION")
nvi)
nvx)) (let ((pair nva))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_23_v1" :snd (make-pair :fst "vote" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
(make-pair :fst nvy :snd (make-axiom)))
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))))))
(make-pair :fst (funcall nvmk-hdf) :snd nvv)))))))) (nvhdf-memory (nvhdf-compose1 (funcall (nvaneris_23_v1_update_replica "UNION")
nvi) (nvhdf-parallel (fix (lambda (nvmk-hdf)
(make-inl :val (lambda (nva)
(make-pair :fst (funcall nvmk-hdf) :snd (let ((pair nva))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom)))))))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
(make-pair :fst nvy :snd (make-axiom)))
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))))))) (fix (lambda (nvmk-hdf)
(make-inl :val (lambda (nva)
(let ((nvv (nvbag-union (nvbag-map (lambda (nvx)
(funcall (funcall (nvaneris_23_v1_vote2prop "UNION")
nvi)
nvx)) (let ((pair nva))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_23_v1" :snd (make-pair :fst "vote" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
(make-pair :fst nvy :snd (make-axiom)))
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))))))
(make-pair :fst (funcall nvmk-hdf) :snd nvv)))))))) (make-pair :fst (make-pair :fst 0 :snd (make-axiom)) :snd (make-axiom)))) (lambda (nvx)
(let ((pair nvx))
(let ((nvn (pair-fst pair))
(nvc (pair-snd pair)))
(nvhdf-parallel (nvhdf-parallel (funcall (fix (lambda (nvmk-hdf)
(lambda (nvs)
(make-inl :val (lambda (nvv)
(let ((pair nvs))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((pair nvv))
(let ((nvx1 (pair-fst pair))
(nvy1 (pair-snd pair)))
(let ((dec (nvname_eq nvx1 (make-pair :fst "aneris_23_v1" :snd (make-pair :fst "vote" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nvx2 (inl-val dec)))
(declare (ignore nvx2))
(let ((nvv2 (funcall (funcall (funcall (funcall (nvaneris_23_v1_add_to_quorum "UNION")
(make-pair :fst nvn :snd 0))
nvi)
nvy1)
nvy)))
(let ((nvv3 (nvappend (funcall (funcall (funcall (funcall (nvaneris_23_v1_when_quorum "UNION" (nvaneris_cmd_deq nvCid nvOp nveq_Cid nveq_Op) 2 nvflrs (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom)))) (nvaneris_v1_full_headers_fun nvCid nvOp))
(make-pair :fst nvn :snd 0))
nvi)
nvy1)
nvy) (make-axiom))))
(let ((dec nvx))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv4 (nvappend (funcall (funcall (nvaneris_23_v1_vote_broadcast "UNION" (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom)))) (nvaneris_v1_full_headers_fun nvCid nvOp))
nvlocs)
(make-pair :fst (make-pair :fst (make-pair :fst nvn :snd 0) :snd nvc) :snd nvi)) nvv3)))
(make-pair :fst (let ((dec (nvnull nvv3)))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
(funcall (funcall nvmk-hdf)
(make-pair :fst (make-inr :val (make-axiom)) :snd nvv2)))
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(make-inr :val (make-axiom)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))) :snd nvv4)))
(if (inr-p dec)
(let ((nvx1 (inr-val dec)))
(declare (ignore nvx1))
(make-pair :fst (let ((dec (nvnull nvv3)))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
(funcall (funcall nvmk-hdf)
(make-pair :fst (make-inr :val (make-axiom)) :snd nvv2)))
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(make-inr :val (make-axiom)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))) :snd nvv3))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))
(if (inr-p dec)
(let ((nvy2 (inr-val dec)))
(declare (ignore nvy2))
(let ((nvv2 nvy))
(let ((dec nvx))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv4 (nvappend (funcall (funcall (nvaneris_23_v1_vote_broadcast "UNION" (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom)))) (nvaneris_v1_full_headers_fun nvCid nvOp))
nvlocs)
(make-pair :fst (make-pair :fst (make-pair :fst nvn :snd 0) :snd nvc) :snd nvi)) (make-axiom))))
(make-pair :fst (funcall (funcall nvmk-hdf)
(make-pair :fst (make-inr :val (make-axiom)) :snd nvv2)) :snd nvv4)))
(if (inr-p dec)
(let ((nvx1 (inr-val dec)))
(declare (ignore nvx1))
(make-pair :fst (funcall (funcall nvmk-hdf)
(make-pair :fst (make-inr :val (make-axiom)) :snd nvv2)) :snd (make-axiom)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))))))))
(make-pair :fst (make-inl :val (make-axiom)) :snd (make-pair :fst (make-axiom) :snd (make-axiom)))) (nvhdf-once (fix (lambda (nvmk-hdf)
(make-inl :val (lambda (nva)
(let ((nvv (nvbag-union (nvbag-map (lambda (nvx)
(funcall (funcall (funcall (nvaneris_23_v1_decision "UNION" nvreps (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom)))) (nvaneris_v1_full_headers_fun nvCid nvOp))
nvn)
nvi)
nvx)) (let ((pair nva))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_23_v1" :snd (make-pair :fst "decided" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
(make-pair :fst nvy :snd (make-axiom)))
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))))))
(make-pair :fst (funcall nvmk-hdf) :snd nvv)))))))) (funcall (fix (lambda (nvmk-hdf)
(lambda (nvs0)
(let ((dec (nvhdf-halted (let ((pair nvs0))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(declare (ignore nvy))
nvx)))))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
(nvhdf-halt))
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(nvhdf-run (lambda (nva)
(let ((pair nvs0))
(let ((nvX (pair-fst pair))
(nvY (pair-snd pair)))
(let ((pair (nvhdf-ap nvX nva)))
(let ((nvX_ (pair-fst pair))
(nvb (pair-snd pair)))
(let ((pair (nvhdf-ap nvY nva)))
(let ((nvY_ (pair-fst pair))
(nvc (pair-snd pair)))
(make-pair :fst (funcall (funcall nvmk-hdf)
(make-pair :fst (let ((dec (nvbag-null nvc)))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
nvX_)
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(nvhdf-halt))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))) :snd nvY_)) :snd nvb))))))))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))
(make-pair :fst (nvhdf-bind (nvhdf-compose2 (nvhdf-compose1 (funcall (funcall (nvaneris_23_v1_when_new_round "UNION")
nvn)
nvi) (nvhdf-parallel (fix (lambda (nvmk-hdf)
(make-inl :val (lambda (nva)
(make-pair :fst (funcall nvmk-hdf) :snd (let ((pair nva))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_23_v1" :snd (make-pair :fst "retry" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
(make-pair :fst nvy :snd (make-axiom)))
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))))))) (fix (lambda (nvmk-hdf)
(make-inl :val (lambda (nva)
(let ((nvv (nvbag-union (nvbag-map (lambda (nvx)
(funcall (funcall (nvaneris_23_v1_vote2retry "UNION")
nvi)
nvx)) (let ((pair nva))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_23_v1" :snd (make-pair :fst "vote" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
(make-pair :fst nvy :snd (make-axiom)))
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))))))
(make-pair :fst (funcall nvmk-hdf) :snd nvv)))))))) (nvhdf-memory (nvhdf-compose1 (funcall (funcall (nvaneris_23_v1_update_round "UNION")
nvn)
nvi) (nvhdf-parallel (fix (lambda (nvmk-hdf)
(make-inl :val (lambda (nva)
(make-pair :fst (funcall nvmk-hdf) :snd (let ((pair nva))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_23_v1" :snd (make-pair :fst "retry" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
(make-pair :fst nvy :snd (make-axiom)))
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))))))) (fix (lambda (nvmk-hdf)
(make-inl :val (lambda (nva)
(let ((nvv (nvbag-union (nvbag-map (lambda (nvx)
(funcall (funcall (nvaneris_23_v1_vote2retry "UNION")
nvi)
nvx)) (let ((pair nva))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_23_v1" :snd (make-pair :fst "vote" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
(make-pair :fst nvy :snd (make-axiom)))
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))))))
(make-pair :fst (funcall nvmk-hdf) :snd nvv)))))))) (make-pair :fst 0 :snd (make-axiom)))) (lambda (nvx)
(let ((pair nvx))
(let ((nvni (pair-fst pair))
(nvc (pair-snd pair)))
(funcall (fix (lambda (nvmk-hdf)
(lambda (nvs)
(make-inl :val (lambda (nvv)
(let ((pair nvs))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((pair nvv))
(let ((nvx1 (pair-fst pair))
(nvy1 (pair-snd pair)))
(let ((dec (nvname_eq nvx1 (make-pair :fst "aneris_23_v1" :snd (make-pair :fst "vote" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nvx2 (inl-val dec)))
(declare (ignore nvx2))
(let ((nvv2 (funcall (funcall (funcall (funcall (nvaneris_23_v1_add_to_quorum "UNION")
nvni)
nvi)
nvy1)
nvy)))
(let ((nvv3 (nvappend (funcall (funcall (funcall (funcall (nvaneris_23_v1_when_quorum "UNION" (nvaneris_cmd_deq nvCid nvOp nveq_Cid nveq_Op) 2 nvflrs (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom)))) (nvaneris_v1_full_headers_fun nvCid nvOp))
nvni)
nvi)
nvy1)
nvy) (make-axiom))))
(let ((dec nvx))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv4 (nvappend (funcall (funcall (nvaneris_23_v1_vote_broadcast "UNION" (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom)))) (nvaneris_v1_full_headers_fun nvCid nvOp))
nvlocs)
(make-pair :fst (make-pair :fst nvni :snd nvc) :snd nvi)) nvv3)))
(make-pair :fst (let ((dec (nvnull nvv3)))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
(funcall (funcall nvmk-hdf)
(make-pair :fst (make-inr :val (make-axiom)) :snd nvv2)))
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(make-inr :val (make-axiom)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))) :snd nvv4)))
(if (inr-p dec)
(let ((nvx1 (inr-val dec)))
(declare (ignore nvx1))
(make-pair :fst (let ((dec (nvnull nvv3)))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
(funcall (funcall nvmk-hdf)
(make-pair :fst (make-inr :val (make-axiom)) :snd nvv2)))
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(make-inr :val (make-axiom)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))) :snd nvv3))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))
(if (inr-p dec)
(let ((nvy2 (inr-val dec)))
(declare (ignore nvy2))
(let ((nvv2 nvy))
(let ((dec nvx))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv4 (nvappend (funcall (funcall (nvaneris_23_v1_vote_broadcast "UNION" (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom)))) (nvaneris_v1_full_headers_fun nvCid nvOp))
nvlocs)
(make-pair :fst (make-pair :fst nvni :snd nvc) :snd nvi)) (make-axiom))))
(make-pair :fst (funcall (funcall nvmk-hdf)
(make-pair :fst (make-inr :val (make-axiom)) :snd nvv2)) :snd nvv4)))
(if (inr-p dec)
(let ((nvx1 (inr-val dec)))
(declare (ignore nvx1))
(make-pair :fst (funcall (funcall nvmk-hdf)
(make-pair :fst (make-inr :val (make-axiom)) :snd nvv2)) :snd (make-axiom)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))))))))
(make-pair :fst (make-inl :val (make-axiom)) :snd (make-pair :fst (make-axiom) :snd (make-axiom)))))))) :snd (nvhdf-once (fix (lambda (nvmk-hdf)
(make-inl :val (lambda (nva)
(let ((nvv (nvbag-union (nvbag-map (lambda (nvx)
(funcall (funcall (funcall (nvaneris_23_v1_decision "UNION" nvreps (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom)))) (nvaneris_v1_full_headers_fun nvCid nvOp))
nvn)
nvi)
nvx)) (let ((pair nva))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris_23_v1" :snd (make-pair :fst "decided" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
(make-pair :fst nvy :snd (make-axiom)))
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(make-axiom))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))))))
(make-pair :fst (funcall nvmk-hdf) :snd nvv)))))))))))))))
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(nvhdf-halt))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))) (let ((dec (nvdeq-member (lambda (nva)
(lambda (nvb)
(if (string= nva nvb)
(make-inl :val (make-axiom))
(make-inr :val (make-axiom))))) nvi nvreps)))
(if (inl-p dec)
(let ((nv (inl-val dec)))
(declare (ignore nv))
(funcall (fix (lambda (nvmk-hdf)
(lambda (nvs)
(make-inl :val (lambda (nva)
(let ((pair nva))
(let ((nvx (pair-fst pair))
(nvy (pair-snd pair)))
(let ((dec (nvname_eq nvx (make-pair :fst "swap" :snd (make-axiom)))))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv5 (nvmap (funcall (funcall (funcall (nvaneris_v1_out_tr nvCid nvOp (make-pair :fst "bcast" :snd (make-axiom)) (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (make-pair :fst "response" :snd (make-axiom)) (make-pair :fst "swap" :snd (make-axiom)) (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom)))) (nvaneris_v1_full_headers_fun nvCid nvOp))
(nvaneris_v1_propose_inl nvCid nvOp (make-pair :fst "bcast" :snd (make-axiom)) (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) nveq_Cid nvldrs (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (make-pair :fst "response" :snd (make-axiom)) (make-pair :fst "swap" :snd (make-axiom)) nvlocs (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom)))) (nvaneris_v1_full_headers_fun nvCid nvOp)))
nvi)
nvy) nvs)))
(let ((dec (nvbag-null nvv5)))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv6 nvs))
(let ((nvv7 (nvbag-union (nvbag-map (lambda (nvx)
(let ((pair nvx))
(let ((nvx_ (pair-fst pair))
(nvy (pair-snd pair)))
(declare (ignore nvx_))
nvy))) nvv6))))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv6) :snd nvv7))))
(if (inr-p dec)
(let ((nvy1 (inr-val dec)))
(declare (ignore nvy1))
(let ((nvv7 (nvbag-union (nvbag-map (lambda (nvx)
(let ((pair nvx))
(let ((nvx_ (pair-fst pair))
(nvy (pair-snd pair)))
(declare (ignore nvx_))
nvy))) nvv5))))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv5) :snd nvv7)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))
(if (inr-p dec)
(let ((nvy1 (inr-val dec)))
(declare (ignore nvy1))
(let ((dec (nvname_eq nvx (make-pair :fst "bcast" :snd (make-axiom)))))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv5 (nvmap (funcall (funcall (funcall (nvaneris_v1_out_tr nvCid nvOp (make-pair :fst "bcast" :snd (make-axiom)) (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (make-pair :fst "response" :snd (make-axiom)) (make-pair :fst "swap" :snd (make-axiom)) (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom)))) (nvaneris_v1_full_headers_fun nvCid nvOp))
(nvaneris_v1_propose_inr nvCid nvOp (make-pair :fst "bcast" :snd (make-axiom)) (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) nveq_Cid nvldrs (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (make-pair :fst "response" :snd (make-axiom)) (make-pair :fst "swap" :snd (make-axiom)) nvlocs (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom)))) (nvaneris_v1_full_headers_fun nvCid nvOp)))
nvi)
nvy) nvs)))
(let ((dec (nvbag-null nvv5)))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv6 nvs))
(let ((nvv7 (nvbag-union (nvbag-map (lambda (nvx)
(let ((pair nvx))
(let ((nvx_ (pair-fst pair))
(nvy (pair-snd pair)))
(declare (ignore nvx_))
nvy))) nvv6))))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv6) :snd nvv7))))
(if (inr-p dec)
(let ((nvy1 (inr-val dec)))
(declare (ignore nvy1))
(let ((nvv7 (nvbag-union (nvbag-map (lambda (nvx)
(let ((pair nvx))
(let ((nvx_ (pair-fst pair))
(nvy (pair-snd pair)))
(declare (ignore nvx_))
nvy))) nvv5))))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv5) :snd nvv7)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))
(if (inr-p dec)
(let ((nvy1 (inr-val dec)))
(declare (ignore nvy1))
(let ((dec (nvname_eq nvx (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))))))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv5 (nvmap (funcall (funcall (funcall (nvaneris_v1_out_tr nvCid nvOp (make-pair :fst "bcast" :snd (make-axiom)) (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (make-pair :fst "response" :snd (make-axiom)) (make-pair :fst "swap" :snd (make-axiom)) (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom)))) (nvaneris_v1_full_headers_fun nvCid nvOp))
(nvaneris_v1_on_decision nvCid nvOp (make-pair :fst "bcast" :snd (make-axiom)) nvclients (make-pair :fst "aneris" :snd (make-pair :fst "decision" :snd (make-axiom))) nveq_Cid nvldrs (make-pair :fst "aneris" :snd (make-pair :fst "pax" :snd (make-pair :fst "propose" :snd (make-axiom)))) (make-pair :fst "response" :snd (make-axiom)) (make-pair :fst "swap" :snd (make-axiom)) nvlocs (make-pair :fst "aneris" :snd (make-pair :fst "23" :snd (make-pair :fst "propose" :snd (make-axiom)))) (nvaneris_v1_full_headers_fun nvCid nvOp)))
nvi)
nvy) nvs)))
(let ((dec (nvbag-null nvv5)))
(if (inl-p dec)
(let ((nvx1 (inl-val dec)))
(declare (ignore nvx1))
(let ((nvv6 nvs))
(let ((nvv7 (nvbag-union (nvbag-map (lambda (nvx)
(let ((pair nvx))
(let ((nvx_ (pair-fst pair))
(nvy (pair-snd pair)))
(declare (ignore nvx_))
nvy))) nvv6))))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv6) :snd nvv7))))
(if (inr-p dec)
(let ((nvy1 (inr-val dec)))
(declare (ignore nvy1))
(let ((nvv7 (nvbag-union (nvbag-map (lambda (nvx)
(let ((pair nvx))
(let ((nvx_ (pair-fst pair))
(nvy (pair-snd pair)))
(declare (ignore nvx_))
nvy))) nvv5))))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv5) :snd nvv7)))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr"))))))
(if (inr-p dec)
(let ((nvy1 (inr-val dec)))
(declare (ignore nvy1))
(let ((nvv6 nvs))
(let ((nvv7 (nvbag-union (nvbag-map (lambda (nvx)
(let ((pair nvx))
(let ((nvx_ (pair-fst pair))
(nvy (pair-snd pair)))
(declare (ignore nvx_))
nvy))) nvv6))))
(make-pair :fst (funcall (funcall nvmk-hdf)
nvv6) :snd nvv7))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))))))
(make-pair :fst (make-pair :fst (make-pair :fst 1 :snd (make-pair :fst (make-inr :val (make-axiom)) :snd (make-pair :fst (make-axiom) :snd (make-pair :fst (make-axiom) :snd (make-pair :fst "2/3" :snd (make-axiom)))))) :snd (make-axiom)) :snd (make-axiom))))
(if (inr-p dec)
(let ((nv (inr-val dec)))
(declare (ignore nv))
(nvhdf-halt))
(error "decide:an_injection_should_be_a_list_with_header_inl_or_inr")))))))))))))))))))

