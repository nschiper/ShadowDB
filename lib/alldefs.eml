constant unit : Type ;;
constant rev_implies (A: Prop; B: Prop) : Prop ;;
constant squash (A: Prop) : Prop ;;
constant not (A: Prop) : Prop ;;
constant nequal ('A: Type; x: 'A; y: 'A) : Prop ;;
constant iff (A: Prop; B: Prop) : Prop ;;
constant sq_exists ('A: Type; B[a: 'A]: Prop) : Prop ;;
constant all ('A: Type; B[a: 'A]: Prop) : Prop ;;
constant le (i: Int; j: Int) : Prop ;;
constant ge (i: Int; j: Int) : Prop ;;
constant gt (i: Int; j: Int) : Prop ;;
constant infix_ap (f: ('A) -> ('B) -> 'C; x: 'A; y: 'B) : 'C ;;
constant 'T guard : Type ;;
constant cand (A: Prop; B: Prop) : Prop ;;
constant top : Type ;;
constant uall ('A: Type; B[x: 'A]: Prop) : Prop ;;
constant rev_uimplies (P: Prop; Q: Prop) : Prop ;;
constant uiff (P: Prop; Q: Prop) : Prop ;;
constant icomb : ('A) -> 'A ;;
constant kcomb : ('A) -> ('B) -> 'A ;;
constant scomb : (('A) -> ('B) -> 'C) -> (('A) -> 'B) -> ('A) -> 'C ;;
constant it : Unit ;;
constant decidable (A: Prop) : Prop ;;
constant stable (A: Prop) : Prop ;;
constant sq_stable (A: Prop) : Prop ;;
constant xmiddle : Prop ;;
constant sq_or (a: Prop; b: Prop) : Prop ;;
constant unique_set ('T: Type; P[x: 'T]: Prop) : Type ;;
constant uni_sat ('T: Type; a: 'T; Q[x: 'T]: Prop) : Prop ;;
constant 'T baseof : Type ;;
constant wellfounded ('A: Type; r[x: 'A; y: 'A]: Prop) : Prop ;;
constant uwellfounded ('A: Type; R[x: 'A; y: 'A]: Prop) : Prop ;;
constant pair-lex ('A: Type; Ra: ('A) -> ('A) -> Prop; Rb: ('B) -> ('B) -> Prop) : (('A) * ('B)) -> (('A) * ('B)) -> Prop ;;
constant rev_subtype_rel ('A: Type; 'B: Type) : Prop ;;
constant ext-eq ('A: Type; 'B: Type) : Prop ;;
constant bool : Type ;;
constant btrue : Bool ;;
constant bfalse : Bool ;;
constant ifthenelse (b: Bool; p: 'A; q: 'A) : 'A ;;
constant assert (b: Bool) : Prop ;;
constant lt_int (i: Int; j: Int) : Bool ;;
constant bnot (b: Bool) : Bool ;;
constant band (p: Bool; q: Bool) : Bool ;;
constant bor (p: Bool; q: Bool) : Bool ;;
constant le_int (i: Int; j: Int) : Bool ;;
constant b2i (b: Bool) : Int ;;
constant eq_bool (p: Bool; q: Bool) : Bool ;;
constant bxor (p: Bool; q: Bool) : Bool ;;
constant rev_bimplies (p: Bool; q: Bool) : Bool ;;
constant eq_int (i: Int; j: Int) : Bool ;;
constant eq_atom (x: Atom; y: Atom) : Bool ;;
constant ('A, 'B) b-union : Type ;;
constant ('T1, 'T2) isect2 : Type ;;
constant pair-blex (eq: ('A) -> ('A) -> Bool; Ra: ('A) -> ('A) -> Bool; Rb: ('B) -> ('B) -> Bool) : (('A) * ('B)) -> (('A) * ('B)) -> Bool ;;
constant isl (x: 'A + 'B) : Bool ;;
constant isr (x: 'A + 'B) : Bool ;;
constant outl (x: 'A + 'B) : 'A ;;
constant outr (x: 'A + 'B) : 'B ;;
constant eq_term (a: 'T; b: 'T) : Bool ;;
constant 'T value-type : Type ;;
constant 'T valueall-type : Type ;;
constant vatype : Type ;;
constant evalall (t: 'T) : 'T ;;
constant 'T id-fun : Type ;;
constant 'T sq-id-fun : Type ;;
constant lelt (x: Int; y: Int; z: Int) : Prop ;;
constant lele (x: Int; y: Int; z: Int) : Prop ;;
constant nat : Type ;;
constant nat_plus : Type ;;
constant int_nzero : Type ;;
constant identity : ('A) -> 'A ;;
constant tidentity ('A: Type) : ('A) -> 'A ;;
constant compose (f: ('B) -> 'C; g: ('A) -> 'B) : ('A) -> 'C ;;
constant inv_funs ('A: Type; 'B: Type; f: ('A) -> 'B; g: ('B) -> 'A) : Prop ;;
constant one_one_corr ('A: Type; 'B: Type) : Prop ;;
constant inject ('A: Type; 'B: Type; f: ('A) -> 'B) : Prop ;;
constant surject ('A: Type; 'B: Type; f: ('A) -> 'B) : Prop ;;
constant biject ('A: Type; 'B: Type; f: ('A) -> 'B) : Prop ;;
constant assoc ('T: Type; op: ('T) -> ('T) -> 'T) : Prop ;;
constant comm ('T: Type; op: ('T) -> ('T) -> 'T) : Prop ;;
constant inverse ('T: Type; op: ('T) -> ('T) -> 'T; id: 'T; inv: ('T) -> 'T) : Prop ;;
constant fincr : Type ;;
constant refl ('T: Type; E[x: 'T; y: 'T]: Prop) : Prop ;;
constant urefl ('T: Type; E[x: 'T; y: 'T]: Prop) : Prop ;;
constant sym ('T: Type; E[x: 'T; y: 'T]: Prop) : Prop ;;
constant usym ('T: Type; E[x: 'T; y: 'T]: Prop) : Prop ;;
constant trans ('T: Type; E[x: 'T; y: 'T]: Prop) : Prop ;;
constant utrans ('T: Type; E[x: 'T; y: 'T]: Prop) : Prop ;;
constant utrans ('T: Type; E[x: 'T; y: 'T]: Prop) : Prop ;;
constant equiv_rel ('T: Type; E[x: 'T; y: 'T]: Prop) : Prop ;;
constant uequiv_rel ('T: Type; E[x: 'T; y: 'T]: Prop) : Prop ;;
constant preorder ('T: Type; R[x: 'T; y: 'T]: Prop) : Prop ;;
constant upreorder ('T: Type; R[x: 'T; y: 'T]: Prop) : Prop ;;
constant symmetrize (R[x: 'T; y: 'T]: Prop; a: 'T; b: 'T) : Prop ;;
constant eqfun_p ('T: Type; eq: ('T) -> ('T) -> Bool) : Prop ;;
constant anti_sym ('T: Type; R[x: 'T; y: 'T]: Prop) : Prop ;;
constant uanti_sym ('T: Type; R[x: 'T; y: 'T]: Prop) : Prop ;;
constant st_anti_sym ('T: Type; R[x: 'T; y: 'T]: Prop) : Prop ;;
constant strict_part (R[x: 'T; y: 'T]: Prop; a: 'T; b: 'T) : Prop ;;
constant connex ('T: Type; R[x: 'T; y: 'T]: Prop) : Prop ;;
constant uconnex ('T: Type; R[x: 'T; y: 'T]: Prop) : Prop ;;
constant order ('T: Type; R[x: 'T; y: 'T]: Prop) : Prop ;;
constant uorder ('T: Type; R[x: 'T; y: 'T]: Prop) : Prop ;;
constant linorder ('T: Type; R[x: 'T; y: 'T]: Prop) : Prop ;;
constant ulinorder ('T: Type; R[x: 'T; y: 'T]: Prop) : Prop ;;
constant irrefl ('T: Type; E[x: 'T; y: 'T]: Prop) : Prop ;;
constant absval (x: Int) : Int ;;
constant pm_equal (a: Int; b: Int) : Prop ;;
constant imax (a: Int; b: Int) : Int ;;
constant imin (a: Int; b: Int) : Int ;;
constant ndiff (a: Int; b: Int) : Int ;;
constant modulus (a: Int; n: nat_plus) : Int ;;
constant div_floor (a: Int; n: nat_plus) : Int ;;
constant mu (f: (Int) -> Bool) : Int ;;
constant strong-subtype ('A: Type; 'B: Type) : Prop ;;
constant 'T list : Type ;;
constant cons (a: 'S; b: ('S)List) : ('S)List ;;
constant list_ind (L: ('A)List; x: 'B; F[h: 'A; t: ('A)List; r: 'B]: 'B) : 'B ;;
constant reduce (f: ('A) -> ('B) -> 'B; k: 'B; as: ('A)List) : 'B ;;
constant list_accum (f[x: 'T'; a: 'T]: 'T'; y: 'T'; l: ('T)List) : 'T' ;;
constant null (as: ('T)List) : Bool ;;
constant append (as: ('T)List; bs: ('T)List) : ('T)List ;;
constant length (l: ('A)List) : Int ;;
constant map (f: ('A) -> 'B; l: ('A)List) : ('B)List ;;
constant hd (l: ('A)List) : 'A ;;
constant tl (l: ('A)List) : ('A)List ;;
constant accum_list (f[a: 'A; x: 'T]: 'A; base[x: 'T]: 'A; L: ('T)List) : 'A ;;
constant nth_tl (i: Int; as: ('A)List) : ('A)List ;;
constant reverse (as: ('T)List) : ('T)List ;;
constant firstn (n: Int; as: ('A)List) : ('A)List ;;
constant segment (as: ('T)List; m: Int; n: Int) : ('T)List ;;
constant select (n: Int; l: ('A)List) : 'A ;;
constant reject (n: Int; l: ('A)List) : ('A)List ;;
constant for ('A: Type; f: ('B) -> ('C) -> 'C; k: 'C; as: ('A)List; g[x: 'A]: 'B) : 'C ;;
constant mapcons (f: ('A) -> (('A)List) -> 'B; l: ('A)List) : ('B)List ;;
constant filter (P: ('T) -> Bool; l: ('T)List) : ('T)List ;;
constant concat (ll: (('T)List)List) : ('T)List ;;
constant cbv-concat (ll: (('T)List)List) : ('T)List ;;
constant product-map (F: ('A) -> ('B) -> 'C; as: ('A)List; bs: ('B)List) : ('C)List ;;
constant for_hdtl ('A: Type; f: ('B) -> ('C) -> 'C; k: 'C; as: ('A)List; g[h: 'A; t: ('A)List]: 'B) : 'C ;;
constant mapc (f: ('A) -> 'B) : (('A)List) -> ('B)List ;;
constant l_member (x: 'T; l: ('T)List; 'T: Type) : Prop ;;
constant len (as: (top)List) : Int ;;
constant eval-list (L: (Int)List) : (Int)List ;;
constant count (P: ('A) -> Bool; L: ('A)List) : Int ;;
constant count (P: ('A) -> Bool; L: ('A)List) : Int ;;
constant last (L: ('T)List) : 'T ;;
constant sublist ('T: Type; L1: ('T)List; L2: ('T)List) : Prop ;;
constant l_before (x: 'T; y: 'T; l: ('T)List; 'T: Type) : Prop ;;
constant no_repeats ('T: Type; l: ('T)List) : Prop ;;
constant l_all (L: ('T)List; P[x: 'T]: Prop) : Prop ;;
constant l_exists (L: ('T)List; P[x: 'T]: Prop) : Prop ;;
constant mapfilter (f: ('T) -> 'T'; P: ('T) -> Bool; L: ('T)List) : ('T')List ;;
constant l_subset ('T: Type; as: ('T)List; bs: ('T)List) : Prop ;;
constant l_contains ('T: Type; A: ('T)List; B: ('T)List) : Prop ;;
constant l_disjoint ('T: Type; l: ('T)List; l': ('T)List) : Prop ;;
constant 'A listp : Type ;;
constant tlp (L: ('A)listp) : ('A)List ;;
constant hdp (L: ('a)listp) : 'a ;;
constant iseg ('T: Type; l1: ('T)List; l2: ('T)List) : Prop ;;
constant fseg ('T: Type; L1: ('T)List; L2: ('T)List) : Prop ;;
constant set-equal ('T: Type; x: ('T)List; y: ('T)List) : Prop ;;
constant combine-list (f[x: 'A; y: 'A]: 'A; L: ('A)List) : 'A ;;
constant imax-list (L: (Int)List) : Int ;;
constant sorted-by (R: ('T) -> ('T) -> Prop; L: ('T)List) : Prop ;;
constant pairwise (P[x: 'T; y: 'T]: Prop; L: ('T)List) : Prop ;;
constant 'T finite-type : Type ;;
constant bigger-int (n: Int; L: (Int)List) : Int ;;
constant from-upto (n: Int; m: Int) : (Int)List ;;
constant bl-all (L: ('T)List; P[x: 'T]: Bool) : Bool ;;
constant bl-exists (L: ('T)List; P[x: 'T]: Bool) : Bool ;;
constant permutation ('A: Type; L1: ('A)List; L2: ('A)List) : Prop ;;
constant orbit ('T: Type; f: ('T) -> 'T; L: ('T)List) : Prop ;;
constant eager-accum (f[x: 'T'; a: 'T]: 'T'; y: 'T'; l: ('T)List) : 'T' ;;
constant insert-by (eq: ('T) -> ('T) -> Bool; r: ('T) -> ('T) -> Bool; x: 'T; L: ('T)List) : ('T)List ;;
constant 'T comparison : Type ;;
constant int-minus-comparison (f: ('T) -> Int) : ('T)comparison ;;
constant int-minus-comparison-inc (f: ('T) -> Int) : ('T)comparison ;;
constant insert-combine (cmp: ('T)comparison; f: ('T) -> ('T) -> 'T; x: 'T; L: ('T)List) : ('T)List ;;
constant remove-combine (cmp: ('T) -> Int; l: ('T)List) : ('T)List ;;
constant insert-no-combine (cmp: ('T)comparison; x: 'T; L: ('T)List) : ('T)List ;;
constant remove-first (P: ('T) -> Bool; L: ('T)List) : ('T)List ;;
constant l_sum (L: (Int)List) : Int ;;
constant l_mul (L: (Int)List) : Int ;;
constant mapl (f: ('A) -> 'B; L: ('A)List) : ('B)List ;;
constant list_decomp_rev (l: ('T)List) : ('T) * (('T)List) ;;
constant list_ind_reverse (L: ('A)List; nilcase: 'B; F: ('B) -> (('A)List) -> ('A) -> 'B) : 'B ;;
constant single-valued-list (L: ('T)List; 'T: Type) : Prop ;;
constant proper-iseg ('T: Type; L1: ('T)List; L2: ('T)List) : Prop ;;
constant 'T deq : Type ;;
constant eqof (d: ('T)Deq) : ('T) -> ('T) -> Bool ;;
constant int-deq : (Int)Deq ;;
constant nat-deq : (Int)Deq ;;
constant unit-deq : (Unit)Deq ;;
constant atom-deq : (Atom)Deq ;;
constant bool-deq : (Bool)Deq ;;
constant proddeq (a: ('A)Deq; b: ('B)Deq) : (('A) * ('B)) -> (('A) * ('B)) -> Bool ;;
constant product-deq ('A: Type; 'B: Type; a: ('A)Deq; b: ('B)Deq) : (('A) * ('B))Deq ;;
constant sumdeq (a: ('A)Deq; b: ('B)Deq) : ('A + 'B) -> ('A + 'B) -> Bool ;;
constant union-deq ('A: Type; 'B: Type; a: ('A)Deq; b: ('B)Deq) : ('A + 'B)Deq ;;
constant list-deq (eq: ('A)Deq) : (('A)List)Deq ;;
constant deq-member (eq: ('A)Deq; x: 'A; L: ('A)List) : Bool ;;
constant possible-majority ('T: Type; eq: ('T)Deq; L: ('T)List; x: 'T) : Prop ;;
constant poss-maj (eq: ('T)Deq; L: ('T)List; x: 'T) : (Int) * ('T) ;;
constant apply-alist (eq: ('T)Deq; L: (('T) * ('V))List; x: 'T) : 'V + Unit ;;
constant update-alist (eq: ('T)Deq; L: (('T) * ('A))List; x: 'T; z: 'A; f[v: 'A]: 'A) : (('T) * ('A))List ;;
constant count-repeats (eq: ('T)Deq; L: ('T)List) : (('T) * (nat_plus))List ;;
constant strict-majority (eq: ('T)Deq; L: ('T)List) : 'T + Unit ;;
constant strict-majority-or-max (L: (Int)List) : Int ;;
constant deq-disjoint (eq: ('A)Deq; as: ('A)List; bs: ('A)List) : Bool ;;
constant deq-all-disjoint (eq: ('A)Deq; ass: (('A)List)List; bs: ('A)List) : Bool ;;
constant 'T fset : Type ;;
constant 'T fset : Type ;;
constant 'A discrete_struct : Type ;;
constant insert (eq: ('T)Deq; a: 'T; L: ('T)List) : ('T)List ;;
constant l-union (eq: ('T)Deq; as: ('T)List; bs: ('T)List) : ('T)List ;;
constant l-union-list (eq: ('T)Deq; ll: (('T)List)List) : ('T)List ;;
constant union-list2 (eq: ('T)Deq; ll: (('T)List)List) : ('T)List ;;
constant no_rel_repeats ('T: Type; R: ('T) -> ('T) -> Prop; l: ('T)List) : Prop ;;
constant bad-remove-repeats (eq: ('T1)Deq; L: ('T1)List) : ('T1)List ;;
constant remove-repeats (eq: ('T)Deq; L: ('T)List) : ('T)List ;;
constant values-for-distinct (eq: ('A)Deq; L: (('A) * ('V))List) : ('V)List ;;
constant list-diff (eq: ('T)Deq; as: ('T)List; bs: ('T)List) : ('T)List ;;
constant 'T ndlist : Type ;;
constant divides (a: Int; b: Int) : Prop ;;
constant assoced (a: Int; b: Int) : Prop ;;
constant gcd_p (a: Int; b: Int; y: Int) : Prop ;;
constant gcd (a: Int; b: Int) : Int ;;
constant coprime (a: Int; b: Int) : Prop ;;
constant reducible (a: Int) : Prop ;;
constant atomic (a: Int) : Prop ;;
constant prime (a: Int) : Prop ;;
constant eqmod (m: Int; a: Int; b: Int) : Prop ;;
constant hide (x: 'T) : 'T ;;
constant opt (b: Bool; x: 'T) : 'T + Unit ;;
constant Russell : Type ;;
constant decision : Type ;;
constant dec2bool (d: decision) : Bool ;;
constant ('E, 'T) tree_con : Type ;;
constant tree_leaf (x: 'E) : ('E,'T)tree_con ;;
constant tree_node (x: ('T) * ('T)) : ('E,'T)tree_con ;;
constant 'E tree : Type ;;
constant node (x: ('E)tree; y: ('E)tree) : ('E)tree ;;
constant t_iterate (l: ('E) -> 'A; n: ('A) -> ('A) -> 'A; t: ('E)tree) : 'A ;;
constant is_leaf (t: ('E)tree) : Bool ;;
constant is_node (t: ('E)tree) : Bool ;;
constant left_child (t: ('E)tree) : ('E)tree ;;
constant right_child (t: ('E)tree) : ('E)tree ;;
constant leaf_value (t: ('E)tree) : 'E ;;
constant finite ('T: Type) : Prop ;;
constant rel_implies ('T: Type; R1: ('T) -> ('T) -> Prop; R2: ('T) -> ('T) -> Prop) : Prop ;;
constant preserved_by ('T: Type; R: ('T) -> ('T) -> Prop; P: ('T) -> Prop) : Prop ;;
constant cond_rel_implies ('T: Type; P: ('T) -> Prop; R1: ('T) -> ('T) -> Prop; R2: ('T) -> ('T) -> Prop) : Prop ;;
constant rel_star ('T: Type; R: ('T) -> ('T) -> Prop) : ('T) -> ('T) -> Prop ;;
constant rel-connected ('T: Type; R: ('T) -> ('T) -> Prop; x: 'T; y: 'T) : Prop ;;
constant rel_inverse (R: ('T1) -> ('T2) -> Prop) : ('T2) -> ('T1) -> Prop ;;
constant rel_or (R1: ('T) -> ('T) -> Prop; R2: ('T) -> ('T) -> Prop) : ('T) -> ('T) -> Prop ;;
constant as_strong ('T: Type; Q: ('T) -> Prop; P: ('T) -> Prop) : Prop ;;
constant prop_and (P: ('T) -> Prop; Q: ('T) -> Prop) : ('T) -> Prop ;;
constant preserved_by2 ('T: Type; R: ('T) -> ('T) -> ('T) -> Prop; P: ('T) -> Prop) : Prop ;;
constant agree_on_common ('T: Type; as: ('T)List; bs: ('T)List) : Prop ;;
constant strong_before (x: 'T; y: 'T; L: ('T)List; 'T: Type) : Prop ;;
constant same_order (x1: 'T; y1: 'T; x2: 'T; y2: 'T; L: ('T)List; 'T: Type) : Prop ;;
constant l_succ (x: 'T; l: ('T)List; 'T: Type; P[y: 'T]: Prop) : Prop ;;
constant compat ('T: Type; l1: ('T)List; l2: ('T)List) : Prop ;;
constant zip (as: ('T1)List; bs: ('T2)List) : (('T1) * ('T2))List ;;
constant unzip (as: (('T1) * ('T2))List) : (('T1)List) * (('T2)List) ;;
constant find (P[a: 'T]: Bool; as: ('T)List; d: 'T) : 'T ;;
constant list_all (P[x: 'T]: Prop; l: ('T)List) : Prop ;;
constant append_rel ('T: Type; L1: ('T)List; L2: ('T)List; L: ('T)List) : Prop ;;
constant safety ('A: Type; P[x: ('A)List]: Prop) : Prop ;;
constant l_all2 (L: ('T)List; 'T: Type; P[x: 'T; y: 'T]: Prop) : Prop ;;
constant l_all_since (L: ('T)List; 'T: Type; a: 'T; P[x: 'T]: Prop) : Prop ;;
constant split_tail (f[x: 'A]: Bool; L: ('A)List) : (('A)List) * (('A)List) ;;
constant disjoint_sublists ('T: Type; L1: ('T)List; L2: ('T)List; L: ('T)List) : Prop ;;
constant interleaving ('T: Type; L1: ('T)List; L2: ('T)List; L: ('T)List) : Prop ;;
constant interleaved_family ('T: Type; 'I: Type; L: ('I) -> ('T)List; L2: ('T)List) : Prop ;;
constant count_pairs (L: ('T)List; P[x: 'T; y: 'T]: Bool) : Int ;;
constant first_index (L: ('T)List; P[x: 'T]: Bool) : Int ;;
constant agree_on ('T: Type; P[a: 'T]: Prop) : (('T)List) -> (('T)List) -> Prop ;;
constant strong_safety ('A: Type; P[x: ('A)List]: Prop) : Prop ;;
constant fu2 (a: Int; b: Int) : Int ;;
constant sna2 (a: Int; b: Int) : Int ;;
constant ('S, 'A) StateTrans : Type ;;
constant ('S, 'A) MutVar : Type ;;
constant returnST : ('a) -> ('s,'a)StateTrans ;;
constant runST ('A: Type) : Prop ;;
constant runST-isect : Type ;;
constant thenST : (('S,'A)StateTrans) -> (('A) -> ('S,'B)StateTrans) -> ('S,'B)StateTrans ;;
constant newVar-isect : Type ;;
constant ('S, 'A) newVarType : Type ;;
constant ('S, 'A) readVarType : Type ;;
constant readVar-isect : Type ;;
constant ('S, 'A) writeVarType : Type ;;
constant writeVar-isect : Type ;;
constant p_subset ('T: Type; A: ('T) -> Prop; B: ('T) -> Prop) : Prop ;;
constant p_equiv ('T: Type; A: ('T) -> Prop; B: ('T) -> Prop) : Prop ;;
constant detach ('T: Type; A: ('T) -> Prop) : Prop ;;
constant binrel_eqv ('T: Type; E: ('T) -> ('T) -> Prop; E': ('T) -> ('T) -> Prop) : Prop ;;
constant binrel_le ('T: Type; E: ('T) -> ('T) -> Prop; E': ('T) -> ('T) -> Prop) : Prop ;;
constant ab_binrel ('T: Type; E[x: 'T; y: 'T]: Prop) : ('T) -> ('T) -> Prop ;;
constant binrel_ap (r: ('T) -> ('T) -> Prop; a: 'T; b: 'T) : Prop ;;
constant dec_binrel ('T: Type; r: ('T) -> ('T) -> Prop) : Prop ;;
constant xxrefl ('T: Type; E: ('T) -> ('T) -> Prop) : Prop ;;
constant xxsym ('T: Type; E: ('T) -> ('T) -> Prop) : Prop ;;
constant xxtrans ('T: Type; E: ('T) -> ('T) -> Prop) : Prop ;;
constant xxsymmetrize (E: ('T) -> ('T) -> Prop) : ('T) -> ('T) -> Prop ;;
constant xxirrefl ('T: Type; R: ('T) -> ('T) -> Prop) : Prop ;;
constant xxanti_sym ('T: Type; R: ('T) -> ('T) -> Prop) : Prop ;;
constant xxst_anti_sym ('T: Type; R: ('T) -> ('T) -> Prop) : Prop ;;
constant xxconnex ('T: Type; R: ('T) -> ('T) -> Prop) : Prop ;;
constant xxorder ('T: Type; R: ('T) -> ('T) -> Prop) : Prop ;;
constant xxequiv_rel ('T: Type; R: ('T) -> ('T) -> Prop) : Prop ;;
constant xxlinorder ('T: Type; R: ('T) -> ('T) -> Prop) : Prop ;;
constant refl_cl ('T: Type; E: ('T) -> ('T) -> Prop) : ('T) -> ('T) -> Prop ;;
constant sym_cl (E: ('T) -> ('T) -> Prop) : ('T) -> ('T) -> Prop ;;
constant s_part (E: ('T) -> ('T) -> Prop) : ('T) -> ('T) -> Prop ;;
constant ident ('T: Type; op: ('T) -> ('T) -> 'T; id: 'T) : Prop ;;
constant bilinear ('T: Type; pl: ('T) -> ('T) -> 'T; tm: ('T) -> ('T) -> 'T) : Prop ;;
constant action_p ('A: Type; x: ('A) -> ('A) -> 'A; e: 'A; 'S: Type; f: ('A) -> ('S) -> 'S) : Prop ;;
constant dist_1op_2op_lr ('A: Type; f: ('A) -> 'A; x: ('A) -> ('A) -> 'A) : Prop ;;
constant fun_thru_1op ('A: Type; 'B: Type; opa: ('A) -> 'A; opb: ('B) -> 'B; f: ('A) -> 'B) : Prop ;;
constant fun_thru_2op ('A: Type; 'B: Type; opa: ('A) -> ('A) -> 'A; opb: ('B) -> ('B) -> 'B; f: ('A) -> 'B) : Prop ;;
constant cancel ('T: Type; 'S: Type; op: ('S) -> ('T) -> 'T) : Prop ;;
constant monot ('T: Type; R[x: 'T; y: 'T]: Prop; f: ('T) -> 'T) : Prop ;;
constant monotone ('T: Type; 'T': Type; R[x: 'T; y: 'T]: Prop; R'[x: 'T'; y: 'T']: Prop; f: ('T) -> 'T') : Prop ;;
constant rels_iso ('T: Type; 'T': Type; R[x: 'T; y: 'T]: Prop; R'[x: 'T'; y: 'T']: Prop; f: ('T) -> 'T') : Prop ;;
constant poset_sig : Type ;;
constant dset : Type ;;
constant mk_dset ('T: Type; eq: ('T) -> ('T) -> Bool) : dset ;;
constant qoset : Type ;;
constant poset : Type ;;
constant loset : Type ;;
constant mk_oset ('T: Type; eq: ('T) -> ('T) -> Bool; leq: ('T) -> ('T) -> Bool) : loset ;;
constant set_prod (s: dset; t: dset) : dset ;;
constant int_loset : loset ;;
constant atom_dset : dset ;;
constant monoid_p ('T: Type; op: ('T) -> ('T) -> 'T; id: 'T) : Prop ;;
constant group_p ('T: Type; op: ('T) -> ('T) -> 'T; id: 'T; inv: ('T) -> 'T) : Prop ;;
constant grp_sig : Type ;;
constant imon : Type ;;
constant mon : Type ;;
constant dmon : Type ;;
constant iabmonoid : Type ;;
constant abmonoid : Type ;;
constant abdmonoid : Type ;;
constant igrp : Type ;;
constant mk_igrp ('T: Type; op: ('T) -> ('T) -> 'T; id: 'T; inv: ('T) -> 'T) : igrp ;;
constant grp : Type ;;
constant iabgrp : Type ;;
constant abgrp : Type ;;
constant abdgrp : Type ;;
constant dset_of_mon (g: grp_sig) : poset_sig ;;
constant omon : Type ;;
constant ocmon : Type ;;
constant oset_of_ocmon (g: grp_sig) : poset_sig ;;
constant ocgrp : Type ;;
constant hgrp_of_ocgrp (g: ocgrp) : grp_sig ;;
constant comp_id_mon ('T: Type) : imon ;;
constant bor_mon : abmonoid ;;
constant band_mon : abmonoid ;;
constant int_add_grp : abgrp ;;
constant nat_add_mon : grp_sig ;;
constant int_mul_mon : abmonoid ;;
constant rng_sig : Type ;;
constant ring_p ('T: Type; pl: ('T) -> ('T) -> 'T; zero: 'T; neg: ('T) -> 'T; tm: ('T) -> ('T) -> 'T; one: 'T) : Prop ;;
constant rng : Type ;;
constant drng : Type ;;
constant crng : Type ;;
constant cdrng : Type ;;
constant mul_mon_of_rng (r: rng_sig) : grp_sig ;;
constant add_grp_of_rng (r: rng_sig) : grp_sig ;;
constant ring_non_triv (r: rng) : Prop ;;
constant integ_dom_p (r: crng) : Prop ;;
constant field_p (r: rng_sig) : Prop ;;
constant integ_dom : Type ;;
constant ring_hom (r: rng_sig; s: rng_sig) : Prop ;;
constant int_ring : integ_dom ;;
constant 'A algebra_sig : Type ;;
constant rng_of_alg (a: ('A)algebra_sig) : rng_sig ;;
constant grp_of_module (m: ('A)algebra_sig) : grp_sig ;;
constant 'T perm_sig : Type ;;
constant perm_f (p: ('T)perm_sig) : ('T) -> 'T ;;
constant perm_b (p: ('T)perm_sig) : ('T) -> 'T ;;
constant 'T perm : Type ;;
constant mk_perm (f: ('T) -> 'T; b: ('T) -> 'T) : ('T)perm_sig ;;
constant id_perm : ('T)perm ;;
constant inv_perm (p: ('T)perm) : ('T)perm ;;
constant comp_perm (p: ('T)perm; q: ('T)perm) : ('T)perm ;;
constant perm_igrp ('T: Type) : igrp ;;
constant permr ('T: Type; as: ('T)List; bs: ('T)List) : Prop ;;
constant permr_upto (R[x: 'T; y: 'T]: Prop; as: ('T)List; bs: ('T)List) : Prop ;;
constant lequiv (R[x: 'T; y: 'T]: Prop; as: ('T)List; bs: ('T)List) : Prop ;;
constant dset_list (s: dset) : dset ;;
constant mem_f ('T: Type; a: 'T; bs: ('T)List) : Prop ;;
constant ball ('A: Type; as: ('A)List; f[x: 'A]: Bool) : Bool ;;
constant lapp_imon ('T: Type) : imon ;;
constant lapp_mon (s: dset) : mon ;;
constant bexists ('A: Type; as: ('A)List; f[x: 'A]: Bool) : Bool ;;
constant uni_sat_upto ('T: Type; r: ('T) -> ('T) -> Prop; a: 'T; Q[x: 'T]: Prop) : Prop ;;
constant exists_uni_upto ('T: Type; r: ('T) -> ('T) -> Prop; Q[x: 'T]: Prop) : Prop ;;
constant is_ufm (g: imon) : Prop ;;
constant posint_mul_mon : abmonoid ;;
constant mset_mon (s: dset) : abmonoid ;;
constant mset_union_mon (s: dset) : abmonoid ;;
constant rng_abmon : Type ;;
constant mon_p (g: grp_sig) : Prop ;;
constant grp_p (g: grp_sig) : Prop ;;
constant rng_p (r: rng_sig) : Prop ;;
constant oalist (a: loset; b: abdmonoid) : dset ;;
constant oal_mon (a: loset; b: abdmonoid) : abdmonoid ;;
constant oal_grp (s: loset; g: abdgrp) : abdgrp ;;
constant oal_hgp (s: loset; g: ocgrp) : grp_sig ;;
constant omralist (g: ocmon; r: cdrng) : dset ;;
constant monad : Type ;;
constant M-map (Mnd: monad) : (Type) -> Type ;;
constant list-monad : monad ;;
constant mtype (Mn: monad) : (Type) -> Type ;;
constant ('A, 'B) equipollent : Type ;;
constant 'A singleton-type : Type ;;
constant 'T powerset : Type ;;
constant 'T bag : Type ;;
constant mk_bag (L: ('T)List) : ('T)Bag ;;
constant empty-bag : ('T)Bag ;;
constant single-bag (x: 'T) : ('T)Bag ;;
constant cons-bag (x: 'T; b: ('T)Bag) : ('T)Bag ;;
constant bag-upto (n: Int) : (Int)Bag ;;
constant bag-map (f: ('A) -> 'B; bs: ('A)Bag) : ('B)Bag ;;
constant bag-append (as: ('T)Bag; bs: ('T)Bag) : ('T)Bag ;;
constant bag-product (as: ('A)Bag; bs: ('B)Bag) : (('A) * ('B))Bag ;;
constant bag-product (as: ('A)Bag; bs: ('B)Bag) : (('A) * ('B))Bag ;;
constant bag-filter (bs: ('T)Bag; p[x: 'T]: Bool) : ('T)Bag ;;
constant bag-mapfilter (f: ('T) -> 'A; P: ('T) -> Bool; bs: ('T)Bag) : ('A)Bag ;;
constant bag-null (bs: ('T)Bag) : Bool ;;
constant bag-size (bs: ('C)Bag) : Int ;;
constant 'T bagp : Type ;;
constant bag-union (bbs: (('T)Bag)Bag) : ('T)Bag ;;
constant bag-combine (bs: ('A)Bag; f[x: 'A]: ('B)Bag) : ('B)Bag ;;
constant bag-monad : monad ;;
constant bag-sum (ba: ('A)Bag; f[x: 'A]: Int) : Int ;;
constant bag-accum (f[v: 'S; x: 'T]: 'S; init: 'S; bs: ('T)Bag) : 'S ;;
constant bag-maximals (b: ('T)Bag; R: ('T) -> ('T) -> Bool) : ('T)Bag ;;
constant imax-bag (bs: (Int)Bag) : Int ;;
constant bag-summation (zero: 'R; add: ('R) -> ('R) -> 'R; b: ('T)Bag; f[x: 'T]: 'R) : 'R ;;
constant bag-no-repeats ('T: Type; bs: ('T)Bag) : Prop ;;
constant bag-all (p[x: 'T]: Bool; bs: ('T)Bag) : Bool ;;
constant bag_all (b: ('T)Bag; f: ('T) -> Bool) : Bool ;;
constant bag-only (bs: ('T)Bag) : 'T ;;
constant bag-merge (as: ('A)Bag; bs: ('B)Bag) : ('A + 'B)Bag ;;
constant bag-separate (bs: ('A + 'B)Bag) : (('A)Bag) * (('B)Bag) ;;
constant sub-bag ('T: Type; as: ('T)Bag; bs: ('T)Bag) : Prop ;;
constant bag-member ('T: Type; x: 'T; bs: ('T)Bag) : Prop ;;
constant bag-inject ('A: Type; b: ('A)Bag; 'B: Type; f: ('A) -> 'B) : Prop ;;
constant similar-bags ('A: Type; as: ('A)Bag; bs: ('A)Bag) : Prop ;;
constant single-valued-bag (b: ('T)Bag; 'T: Type) : Prop ;;
constant sv-bag-only (b: ('T)Bag) : 'T ;;
constant bag-disjoint ('T: Type; as: ('T)Bag; bs: ('T)Bag) : Prop ;;
constant bag-combine-restrict (b: ('A)Bag; f[x: 'A]: ('B)Bag) : ('B)Bag ;;
constant bag-mapfilter-fast (f: ('A) -> 'B; P: ('A) -> Bool; bs: ('A)Bag) : ('B)Bag ;;
constant bag-max (f: ('A) -> Int; bs: ('A)Bag) : Int ;;
constant bag-splits (b: ('T)List) : ((('T)Bag) * (('T)Bag))List ;;
constant bag-decomp (bs: ('T)Bag) : (('T) * (('T)Bag))Bag ;;
constant lifting1 (f: ('A) -> 'B; b: ('A)Bag) : ('B)Bag ;;
constant lifting2 (f: ('A) -> ('B) -> 'C; abag: ('A)Bag; bbag: ('B)Bag) : ('C)Bag ;;
constant lifting-0 (b: 'B) : ('B)Bag ;;
constant lifting-1 (f: ('A) -> 'B) : (('A)Bag) -> ('B)Bag ;;
constant lifting-2 (f: ('A) -> ('B) -> 'C) : (('A)Bag) -> (('B)Bag) -> ('C)Bag ;;
constant lifting-3 (f: ('A) -> ('B) -> ('C) -> 'D) : (('A)Bag) -> (('B)Bag) -> (('C)Bag) -> ('D)Bag ;;
constant concat-lifting1 (f: ('A) -> ('B)Bag; b: ('A)Bag) : ('B)Bag ;;
constant concat-lifting2 (f: ('A) -> ('B) -> ('C)Bag; abag: ('A)Bag; bbag: ('B)Bag) : ('C)Bag ;;
constant concat-lifting-0 (f: ('B)Bag) : ('B)Bag ;;
constant concat-lifting-1 (f: ('A) -> ('B)Bag) : (('A)Bag) -> ('B)Bag ;;
constant concat-lifting-2 (f: ('A) -> ('B) -> ('C)Bag) : (('A)Bag) -> (('B)Bag) -> ('C)Bag ;;
constant concat-lifting-3 (f: ('A) -> ('B) -> ('C) -> ('D)Bag) : (('A)Bag) -> (('B)Bag) -> (('C)Bag) -> ('D)Bag ;;
constant bag-admissable ('T: Type; R[as: ('T)Bag; bs: ('T)Bag]: Prop) : Prop ;;
constant 'T bag-order : Type ;;
constant bag-incomparable ('T: Type; R: ('T) -> ('T) -> Prop; b: ('T)Bag) : Prop ;;
constant bag-covers ('T: Type; R: ('T) -> ('T) -> Prop; cvr: ('T)Bag; b: ('T)Bag) : Prop ;;
constant bag-cover ('T: Type; R: ('T) -> ('T) -> Prop; cvr: ('T)Bag; b: ('T)Bag) : Prop ;;
constant bag-bind (bs: ('A)Bag; f: ('A) -> ('B)Bag) : ('B)Bag ;;
constant proveable ('Sequent: Type; 'Rule: Type; effect: (('Sequent) * ('Rule)) -> ('Sequent)List + Unit; s: 'Sequent) : Prop ;;
constant double-negation-shift (A[i: Int]: Prop) : Prop ;;
constant generalized-markov-principle (A[i: Int]: Prop) : Prop ;;
constant church-true : ('T) -> (top) -> 'T ;;
constant church-false : (top) -> ('T) -> 'T ;;
constant church-ite : (('A) -> ('B) -> 'C) -> ('A) -> ('B) -> 'C ;;
constant church-pair : ('A) -> ('B) -> (('A) -> ('B) -> 'C) -> 'C ;;
constant church-fst : ((('T) -> (top) -> 'T) -> 'A) -> 'A ;;
constant church-snd : (((top) -> ('T) -> 'T) -> 'A) -> 'A ;;
constant church-nil : (top) -> ('T) -> (top) -> 'T ;;
constant church-null : (((top) -> (top) -> (top) -> ('T) -> 'T) -> 'A) -> 'A ;;
constant exists_uni ('T: Type; P[x: 'T]: Prop) : Prop ;;
constant typed (x: 'T; 'T: Type) : 'T ;;
constant type-mismatch (f: 'T; A: 'T1; x: 'T2; B: 'T3) : Unit ;;
constant longest-prefix (P: (('T)listp) -> Bool; L: ('T)List) : ('T)List ;;
constant invert-union (x: 'A + 'B) : 'B + 'A ;;
constant invertunion (x: 'A + 'B) : 'B + 'A ;;
constant order-preserving ('A: Type; 'B: Type; R1[a1: 'A; a2: 'A]: Prop; R2[b1: 'B; b2: 'B]: Prop; f: ('A) -> 'B) : Prop ;;
constant can-apply (f: ('A) -> top + top; x: 'A) : Bool ;;
constant do-apply (f: ('A) -> 'B + top; x: 'A) : 'B ;;
constant p-compose (f: ('B) -> 'C + top; g: ('A) -> 'B + top) : ('A) -> 'C + top ;;
constant p-compose' (f: ('A) -> ('B) -> 'C; g: ('A) -> 'B + top) : ('A) -> 'C + top ;;
constant p-id : ('T) -> 'T + top ;;
constant p-first (L: (('A) -> 'B + top)List) : ('A) -> 'B + top ;;
constant p-conditional (f: ('A) -> 'B + top; g: ('A) -> 'B + top) : ('A) -> 'B + top ;;
constant sublist-rec ('T: Type; l1: ('T)List; l2: ('T)List) : Prop ;;
constant lastn (n: Int; L: ('A)List) : ('A)List ;;
constant listid (L: ('A)List) : ('A)List ;;
constant adjacent ('T: Type; L: ('T)List; x: 'T; y: 'T) : Prop ;;
constant p-inject ('A: Type; 'B: Type; f: ('A) -> 'B + top) : Prop ;;
constant first-member ('T: Type; x: 'T; L: ('T)List; P: ('T) -> Bool) : Prop ;;
constant remove_leading (P[x: 'T]: Bool; L: ('T)List) : ('T)List ;;
constant p-disjoint ('A: Type; f: ('A) -> 'B + top; g: ('A) -> 'B + top) : Prop ;;
constant l-all (L: ('T)List; P[x: 'T]: Prop) : Prop ;;
constant l-all-and (L: ('T)List; P[x: 'T]: Prop; B: Prop) : Prop ;;
constant list_accum_pair (f[a: 'A; x: 'T]: 'A; g[b: 'B; x: 'T]: 'B; a0: 'A; b0: 'B; L: ('T)List) : ('A) * ('B) ;;
constant cps-accum (f[k: ('B) -> 'C; a: 'A]: ('B) -> 'C; b: 'B; L: ('A)List) : (('B) -> 'C) -> 'C ;;
constant convolution (f[a: 'A; b: 'B; c: 'C]: 'C; c0: 'C; L1: ('A)List; L2: ('B)List) : 'C ;;
constant rev-zip (L1: ('A)List; L2: ('B)List) : (('A) * ('B))List ;;
constant bl-rev-exists (L: ('T)List; P[x: 'T]: Bool) : Bool ;;
constant update (eq: ('A) -> ('A) -> Bool; f: ('A) -> 'B; x: 'A; v: 'B) : ('A) -> 'B ;;
constant list_update (l: ('T)List; i: Int; x: 'T) : ('T)List ;;
constant s-filter (P: ('T) -> Bool; as: ('T)List) : ('T)List ;;
constant priority-select (f: ('T) -> Bool; g: ('T) -> Bool; as: ('T)List) : Bool + Unit ;;
constant inv-rel ('A: Type; 'B: Type; f: ('A) -> 'B; finv: ('B) -> 'A + Unit) : Prop ;;
constant fast-mapfilter (p: ('A) -> Bool; f: ('A) -> 'B; L: ('A)List) : ('B)List ;;
constant un-zip (as: (('A) * ('B))List) : (('A)List) * (('B)List) ;;
constant next (k: Int; p[i: Int]: Bool) : Int ;;
constant mul-list (ns: (Int)List) : Int ;;
constant least-factor (n: Int) : Int ;;
constant 'T bar-base : Type ;;
constant diverge : ('T)bar-base ;;
constant in-bar (b: 'T) : ('T)bar-base ;;
constant bar-delay (x: ('T)bar-base) : ('T)bar-base ;;
constant bar-converges ('T: Type; x: ('T)bar-base; a: 'T) : Prop ;;
constant bar-diverges (x: ('T)bar-base) : Prop ;;
constant bar-equal ('T: Type; x: ('T)bar-base; y: ('T)bar-base) : Prop ;;
constant 'T corecbar : Type ;;
constant rel_equivalent ('T: Type; R1: ('T) -> ('T) -> Prop; R2: ('T) -> ('T) -> Prop) : Prop ;;
constant rel_rev_implies ('T: Type; R1: ('T) -> ('T) -> Prop; R2: ('T) -> ('T) -> Prop) : Prop ;;
constant isect-rel ('T: Type; R[i: 'T]: ('A) -> ('A) -> Prop) : ('A) -> ('A) -> Prop ;;
constant rel-monotone ('T: Type; F[R: ('T) -> ('T) -> Prop]: ('T) -> ('T) -> Prop) : Prop ;;
constant rel-continuous ('T: Type; F[R: ('T) -> ('T) -> Prop]: ('T) -> ('T) -> Prop) : Prop ;;
constant bigrel (F[R: ('T) -> ('T) -> Prop]: ('T) -> ('T) -> Prop) : ('T) -> ('T) -> Prop ;;
constant 'A stream : Type ;;
constant s-hd (s: ('A)stream) : 'A ;;
constant s-tl (s: ('A)stream) : ('A)stream ;;
constant s-cons (x: 'A; s: ('A)stream) : ('A)stream ;;
constant mk-stream (f: ('A) -> 'A; x: 'A) : ('A)stream ;;
constant const-stream (x: 'A) : ('A)stream ;;
constant stream-map (f: ('A) -> 'B; s: ('A)stream) : ('B)stream ;;
constant stream-zip (f: ('A) -> ('B) -> 'C; as: ('A)stream; bs: ('B)stream) : ('C)stream ;;
constant fibs : (Int)stream ;;
constant nats : (Int)stream ;;
constant better-fibs : (Int)stream ;;
constant stream-lex ('T: Type; R: ('T) -> ('T) -> Prop) : (('T)stream) -> (('T)stream) -> Prop ;;
constant stream-pointwise (R: ('T) -> ('T) -> Prop) : (('T)stream) -> (('T)stream) -> Prop ;;
constant ('T, 'V) spread-law : Type ;;
constant 'T simple-spread-law : Type ;;
constant satisfies-spread-law ('V: Type; G: ('T,'V)spread-law; s: ('T + 'V)stream) : Prop ;;
constant satisfies-simple-spread-law (G: ('T)simple-spread-law; s: ('T)stream) : Prop ;;
constant WFO : Type ;;
constant TRO : Type ;;
constant WFTRO : Type ;;
constant shuffle (ps: (('T) * ('T))List) : ('T)List ;;
constant unshuffle (L: ('T)List) : (('T) * ('T))List ;;
constant int-list-member (i: Int; xs: (Int)List) : Bool ;;
constant star-append ('T: Type; P: (('T)List) -> Prop; Q: (('T)List) -> Prop) : (('T)List) -> Prop ;;
constant cpsquicksort (cmp: ('T)comparison; L: ('T)List; k: (('T)List) -> 'A) : 'A ;;
constant quicksort-int (L: (Int)List) : (Int)List ;;
constant sub-mset ('T: Type; L1: ('T)List; L2: ('T)List) : Prop ;;
constant accum_filter_rel ('T: Type; 'A: Type; b: 'A; a: 'A; X: ('T)List; P[x: 'T]: Prop; f[z: 'A; x: 'T]: 'A) : Prop ;;
constant p-graph ('B: Type; f: ('A) -> 'B + top) : ('A) -> ('B) -> Prop ;;
constant rel-restriction (R: ('T) -> ('T) -> Prop; P: ('T) -> Prop) : ('T) -> ('T) -> Prop ;;
constant transitive-closure ('A: Type; R: ('A) -> ('A) -> Prop) : ('A) -> ('A) -> Prop ;;
constant rel_plus ('T: Type; R: ('T) -> ('T) -> Type) : ('T) -> ('T) -> Type ;;
constant rel_finite ('T: Type; R: ('T) -> ('T) -> Prop) : Prop ;;
constant rel-path (R: ('T) -> ('T) -> Prop; L: ('T)List) : Prop ;;
constant rel-path-between ('T: Type; R: ('T) -> ('T) -> Prop; x: 'T; y: 'T; L: ('T)List) : Prop ;;
constant acyclic-rel ('T: Type; R: ('T) -> ('T) -> Prop) : Prop ;;
constant one-one ('A: Type; 'B: Type; R: ('A) -> ('B) -> Prop) : Prop ;;
constant l-ordered ('T: Type; R[x: 'T; y: 'T]: Prop; L: ('T)List) : Prop ;;
constant isOdd (n: Int) : Bool ;;
constant isEven (n: Int) : Bool ;;
constant same-parity (n: Int; m: Int) : Bool ;;
constant better-gcd (x: Int; y: Int) : Int ;;
constant rel-immediate ('T: Type; R: ('T) -> ('T) -> Prop) : ('T) -> ('T) -> Prop ;;
constant sum_of_torder ('T: Type; R: ('T) -> ('T) -> Prop) : Prop ;;
constant predicate_or (P1: ('T) -> Prop; P2: ('T) -> Prop) : ('T) -> Prop ;;
constant predicate_implies ('T: Type; P1: ('T) -> Prop; P2: ('T) -> Prop) : Prop ;;
constant predicate_rev_implies ('T: Type; P1: ('T) -> Prop; P2: ('T) -> Prop) : Prop ;;
constant predicate_equivalent ('T: Type; P1: ('T) -> Prop; P2: ('T) -> Prop) : Prop ;;
constant fun-path ('T: Type; f: ('T) -> 'T; L: ('T)List; x: 'T; y: 'T) : Prop ;;
constant fun-connected ('T: Type; f: ('T) -> 'T; x: 'T; y: 'T) : Prop ;;
constant strict-fun-connected ('T: Type; f: ('T) -> 'T; x: 'T; y: 'T) : Prop ;;
constant retraction ('T: Type; f: ('T) -> 'T) : Prop ;;
constant predicate-shift (A: (('T)List) -> Prop; x: ('T)List) : (('T)List) -> Prop ;;
constant predicate-or-shift (A: (('T)List) -> Prop; x: 'T) : (('T)List) -> Prop ;;
constant 'T wfd-tree : Type ;;
constant tree-secures ('T: Type; A: (('T)List) -> Prop; p: ('T)wfd-tree) : Prop ;;
constant dec-predicate ('T: Type; X: ('T) -> Prop) : Prop ;;
constant R-closed ('T: Type; X[x: 'T]: Prop; R[a: 'T; b: 'T]: Prop) : Prop ;;
constant predicate-not (A: ('T) -> Type) : ('T) -> Prop ;;
constant predicate-and (A: ('T) -> Prop; B: ('S) -> Prop) : (('T) * ('S)) -> Prop ;;
constant predicate-or (A: ('T) -> Prop; B: ('S) -> Prop) : (('T) * ('S)) -> Prop ;;
constant tbar ('T: Type; X: (('T)List) -> Prop) : Prop ;;
constant jbar ('T: Type; 'S: Type; X: (('T)List) -> Prop; Y: (('S)List) -> Prop) : Prop ;;
constant ubar ('T: Type; X: (('T)List) -> Prop) : Prop ;;
constant dbar ('T: Type; X: (('T)List) -> Prop) : Prop ;;
constant dfan ('T: Type) : Prop ;;
constant bar-separation ('T: Type; 'S: Type) : Prop ;;
constant is-path (A: (('T)List) -> Prop; f: (Int) -> 'T) : Prop ;;
constant eff-unique-path ('T: Type; A: (('T)List) -> Prop) : Prop ;;
constant down-closed ('T: Type; X: (('T)List) -> Prop) : Prop ;;
constant upwd-closure ('T: Type; A: (('T)List) -> Prop) : (('T)List) -> Prop ;;
constant unbounded-list-predicate ('T: Type; A: (('T)List) -> Prop) : Prop ;;
constant tree-bars ('T: Type; A: (('T)List) -> Prop; p: ('T)wfd-tree) : Prop ;;
constant fan : Prop ;;
constant has-no-path (A: ((Bool)List) -> Prop) : Prop ;;
constant eff-unique (A: ((Bool)List) -> Prop) : Prop ;;
constant infinite-tree (A: ((Bool)List) -> Prop) : Prop ;;
constant PFan : Prop ;;
constant 'V csm : Type ;;
constant all-large (P[n: Int]: Prop) : Prop ;;
constant sq-all-large (P[n: Int]: Prop) : Prop ;;
constant decide2 (x: 'T1 + 'T2; y: 'T3 + 'T4; ll[a: 'T1; b: 'T3]: 'T5; lr[a: 'T1; b: 'T4]: 'T5; rl[a: 'T2; b: 'T3]: 'T5; rr[a: 'T2; b: 'T4]: 'T5) : 'T5 ;;
constant dontcare : top ;;
constant ('A, 'B) one_or_both : Type ;;
constant oobboth (bval: ('A) * ('B)) : ('A,'B)one_or_both ;;
constant oobleft (lval: 'A) : ('A,'B)one_or_both ;;
constant oobright (rval: 'B) : ('A,'B)one_or_both ;;
constant oobboth-bval (x: ('A,'B)one_or_both) : ('A) * ('B) ;;
constant oobleft-lval (x: ('A,'B)one_or_both) : 'A ;;
constant oobright-rval (x: ('A,'B)one_or_both) : 'B ;;
constant oob-hasleft (x: ('A,'B)one_or_both) : Bool ;;
constant oob-hasright (x: ('A,'B)one_or_both) : Bool ;;
constant transition-system : Type ;;
constant rel-preserving ('T1: Type; 'T2: Type; R1: ('T1) -> ('T1) -> Type; R2: ('T2) -> ('T2) -> Type; f[x: 'T2]: 'T1) : Prop ;;
constant C-comb : (('A) -> ('B) -> 'C) -> ('B) -> ('A) -> 'C ;;
constant type-recoding : Type ;;
constant tuple-recoding : Type ;;
constant recode-tuple (f: type-recoding) : tuple-recoding ;;
constant compose-tuple-recodings (r2: tuple-recoding; r1: tuple-recoding) : tuple-recoding ;;
constant is_list_splitting ('T: Type; L: ('T)List; LL: (('T)List)List; L2: ('T)List; f: (('T)List) -> Bool) : Prop ;;
constant list_split (f: (('T)List) -> Bool; L: ('T)List) : ((('T)List)List) * (('T)List) ;;
constant is_accum_splitting ('T: Type; 'A: Type; L: ('T)List; LL: ((('T)List) * ('A))List; L2: (('T)List) * ('A); f: ((('T)List) * ('A)) -> Bool; g: ((('T)List) * ('A)) -> 'A; x: 'A) : Prop ;;
constant accum_split (g: ((('T)List) * ('A)) -> 'A; x: 'A; f: ((('T)List) * ('A)) -> Bool; L: ('T)List) : (((('T)List) * ('A))List) * ((('T)List) * ('A)) ;;
constant quadratic-residue (a: Int; p: Int) : Prop ;;
constant sign (x: Int) : Int ;;
constant gcd_reduce (p: Int; q: Int) : (Int) * ((Int) * (Int)) ;;
constant ('A, 'B) injection : Type ;;
constant 'T cyclic-map : Type ;;
constant sum-map (f[x: 'T]: Int; L: ('T)List) : Int ;;
constant lifted-rel (R: ('A) -> ('A) -> Prop) : ('A + 'B) -> ('A + 'B) -> Prop ;;
constant lexico ('T: Type; lt[a: 'T; b: 'T]: Prop) : (('T)List) -> (('T)List) -> Prop ;;
constant big-rec : Type ;;
constant formula : Type ;;
constant pvar (name: Atom) : formula ;;
constant pnot (sub: formula) : formula ;;
constant pand (left: formula; right: formula) : formula ;;
constant por (left: formula; right: formula) : formula ;;
constant pimp (left: formula; right: formula) : formula ;;
constant pvar-name (x: formula) : Atom ;;
constant pnot-sub (x: formula) : formula ;;
constant pand-left (x: formula) : formula ;;
constant pand-right (x: formula) : formula ;;
constant por-left (x: formula) : formula ;;
constant por-right (x: formula) : formula ;;
constant pimp-left (x: formula) : formula ;;
constant pimp-right (x: formula) : formula ;;
constant prank (x: formula) : Int ;;
constant psub (a: formula; b: formula) : Prop ;;
constant extend-val (v0: (formula) -> Bool; g: (formula) -> Bool; a: formula) : Bool ;;
constant valuation (v0: (formula) -> Bool; x: formula; f: (formula) -> Bool) : Prop ;;
constant peval (v0: (formula) -> Bool; x: formula) : Bool ;;
constant pnegate (x: formula) : formula ;;
constant anyprop : Prop ;;
constant 'T awf : Type ;;
constant awf-leaf (x: 'A) : ('A)awf ;;
constant ('I, 'A) awf-system : Type ;;
constant awf-solution (G: ('I,'A)awf-system) : ('I) -> ('A)awf ;;
constant oob-apply (X: ('A)Bag; Y: ('B)Bag) : (('A,'B)one_or_both)Bag ;;
constant testrec1 (x: Int; L: ('A)List) : Int ;;
constant 'A unordered-tree : Type ;;
constant grow-tree (t: (Int)unordered-tree) : (Int)unordered-tree ;;
constant grow-tree2 (t: (Int)unordered-tree) : (Int)unordered-tree ;;
constant strict-fun : Type ;;
constant eval_list (t: ('T)List) : ('T)List ;;
constant is-list-if-has-value : Type ;;
constant 'T co-list : Type ;;
constant co-list-cons (h: 'T; t: ('T)co-list) : ('T)co-list ;;
constant co-list-nil : ('T)co-list ;;
constant 'T co-list-islist : Type ;;
constant conil : ('A)co-list-islist ;;
constant cocons (a: 'A; L: ('A)co-list-islist) : ('A)co-list-islist ;;
constant trans-term : Type ;;
constant trans-env : Type ;;
constant trans-eval-apply (subterms: (((Atom)List) * (trans-term))List; ev: (trans-term) -> (trans-env) -> (trans-term) * ((Bool) * (trans-env)) + Unit; env: trans-env) : (trans-term) * ((Bool) * (trans-env)) + Unit ;;
constant quoted-term : Type ;;
constant quoted-env : Type ;;
constant quoted-mk-apply (t1: quoted-term; t2: quoted-term) : quoted-term ;;
constant quoted-dest-apply (t: quoted-term) : (quoted-term) * (quoted-term) + Unit ;;
constant quoted-mk-lambda (var: Atom; body: quoted-term) : quoted-term ;;
constant quoted-dest-lambda (t: quoted-term) : (Atom) * (quoted-term) + Unit ;;
constant quoted-mk-spread (p: quoted-term; a: Atom; b: Atom; body: quoted-term) : quoted-term ;;
constant quoted-dest-spread (t: quoted-term) : (quoted-term) * ((Atom) * ((Atom) * (quoted-term))) + Unit ;;
constant quoted-dest-pair (t: quoted-term) : (quoted-term) * (quoted-term) + Unit ;;
constant quoted-eval-spread (p: quoted-term; a: Atom; b: Atom; body: quoted-term; ev: (quoted-term) -> (quoted-env) -> (quoted-term) * ((Bool) * (quoted-env)) + Unit; env: quoted-env) : (quoted-term) * ((Bool) * (quoted-env)) + Unit ;;
constant quoted-eval-apply (t1: quoted-term; t2: quoted-term; ev: (quoted-term) -> (quoted-env) -> (quoted-term) * ((Bool) * (quoted-env)) + Unit; env: quoted-env) : (quoted-term) * ((Bool) * (quoted-env)) + Unit ;;
constant mk-cont (F[v: 'T; c: 'C]: 'A) : (('T) * ('C)) -> 'A ;;
constant mk-init-cont : (('T) * ('C)) -> ('T) * ('C) ;;
constant qeq (r: (Int,(Int) * (int_nzero))b-union; s: (Int,(Int) * (int_nzero))b-union) : Bool ;;
constant rationals : Type ;;
constant qadd (r: rationals; s: rationals) : rationals ;;
constant qmul (r: rationals; s: rationals) : rationals ;;
constant mk-rational (a: Int; b: int_nzero) : rationals ;;
constant qinv (r: rationals) : rationals ;;
constant qpositive (r: rationals) : Bool ;;
constant qrep (r: rationals) : (Int) * (nat_plus) ;;
constant qdiv (r: rationals; s: rationals) : rationals ;;
constant qsub (r: rationals; s: rationals) : rationals ;;
constant is-qrep (p: (Int) * (nat_plus)) : Bool ;;
constant q_le (r: rationals; s: rationals) : Bool ;;
constant qadd_grp : abgrp ;;
constant qless (r: rationals; s: rationals) : Prop ;;
constant qle (r: rationals; s: rationals) : Prop ;;
constant qmax (x: rationals; y: rationals) : rationals ;;
constant qmax-list (L: (rationals)List) : rationals ;;
constant qmin (x: rationals; y: rationals) : rationals ;;
constant qmin-list (L: (rationals)List) : rationals ;;
constant qrng : crng ;;
constant qabs (r: rationals) : rationals ;;
constant qge (a: rationals; b: rationals) : Prop ;;
constant qgt (a: rationals; b: rationals) : Prop ;;
constant q_less (a: rationals; b: rationals) : Bool ;;
constant qdist (r: rationals; s: rationals) : rationals ;;
constant qbetween (a: rationals; b: rationals; c: rationals) : Prop ;;
constant q-between (a: rationals; b: rationals; c: rationals) : Prop ;;
constant qavg (a: rationals; b: rationals) : rationals ;;
constant q-rel (r: Int; x: rationals) : Prop ;;
constant q-rel-lub (r1: Int; r2: Int) : Int ;;
constant qdot (as: (rationals)List; bs: (rationals)List) : rationals ;;
constant qv-dim (as: (top)List) : Int ;;
constant qv-add (as: (rationals)List; bs: (rationals)List) : (rationals)List ;;
constant qv-mul (r: rationals; bs: (rationals)List) : (rationals)List ;;
constant qv-convex (S[p: (rationals)List]: Prop) : Prop ;;
constant test_case1 : (rationals)List + Atom ;;
constant q-floor (r: rationals) : Int ;;
constant q-ceil (r: rationals) : Int ;;
constant qtruncate (q: rationals; N: nat_plus) : rationals ;;
constant int_part_decomp (q: rationals) : (Int) * (rationals) ;;
constant integer-part (q: rationals) : Int ;;
constant fractional-part (q: rationals) : rationals ;;
constant egyptian (q: rationals) : (Int) * ((nat_plus)List) ;;
constant infinitesmal : Type ;;
constant std-inf : infinitesmal ;;
constant inf-add (x: infinitesmal; y: infinitesmal) : infinitesmal ;;
constant inf-max (x: infinitesmal; y: infinitesmal) : infinitesmal ;;
constant real : Type ;;
constant is-rational (r: Real) : Bool ;;
constant canonical-bound (r: Real) : rationals ;;
constant req (x: Real; y: Real) : Prop ;;
constant regular (f: (Int) -> rationals; d: infinitesmal) : Real ;;
constant reals : Type ;;
constant radd (r: Real; s: Real) : Real ;;
constant rmax (r: Real; s: Real) : Real ;;
constant regmul (r: Real; s: Real) : Real ;;
constant rmul (r: Real; s: Real) : Real ;;
constant rminus (r: Real) : Real ;;
constant rmin (x: Real; y: Real) : Real ;;
constant rabs (x: reals) : reals ;;
constant radd_grp : iabgrp ;;
constant icrng : Type ;;
constant rrng : icrng ;;
constant rpositive (r: Real) : Prop ;;
constant rnonneg (r: Real) : Prop ;;
constant reals-plus : Type ;;
constant real-of (e: reals-plus) : Real ;;
constant rnonzero-witness (x: Real) : Int ;;
constant rsub (x: Real; y: Real) : Real ;;
constant rless (x: Real; y: Real) : Prop ;;
constant rleq (x: Real; y: Real) : Prop ;;
constant rgt (x: Real; y: Real) : Prop ;;
constant rge (x: Real; y: Real) : Prop ;;
constant rbetween (x: Real; y: Real; z: Real) : Prop ;;
constant rneq (x: Real; y: Real) : Prop ;;
constant rinv (x: Real) : Real ;;
constant rdiv (x: Real; y: Real) : Real ;;
constant rational-approx (x: Real; n: nat_plus) : rationals ;;
constant irrational (r: Real) : Prop ;;
constant converges-to (x[n: Int]: Real; y: Real) : Prop ;;
constant converges (x[n: Int]: Real) : Prop ;;
constant diverges (x[n: Int]: Real) : Prop ;;
constant bounded-sequence (x[n: Int]: Real) : Prop ;;
constant r-bound (x: Real) : nat_plus ;;
constant cauchy (x[n: Int]: Real) : Prop ;;
constant converges-to-infinity (x[n: Int]: Real) : Prop ;;
constant series-sum (x[n: Int]: Real; a: Real) : Prop ;;
constant series-converges (x[n: Int]: Real) : Prop ;;
constant converges-absolutely (x[n: Int]: Real) : Prop ;;
constant series-diverges (x[n: Int]: Real) : Prop ;;
constant cosine (x: Real) : Real ;;
constant rexp (x: Real) : Real ;;
constant interval : Type ;;
constant i-finite (J: interval) : Prop ;;
constant endpoints (I: interval) : (Real) * (Real) ;;
constant left-endpoint (I: interval) : Real ;;
constant right-endpoint (I: interval) : Real ;;
constant i-length (I: interval) : Real ;;
constant i-closed (I: interval) : Prop ;;
constant i-member (I: interval; x: Real) : Prop ;;
constant rccint (a: Real; b: Real) : interval ;;
constant rcoint (l: Real; u: Real) : interval ;;
constant rciint (l: Real) : interval ;;
constant rocint (l: Real; u: Real) : interval ;;
constant rooint (l: Real; u: Real) : interval ;;
constant roiint (l: Real) : interval ;;
constant ricint (u: Real) : interval ;;
constant rioint (u: Real) : interval ;;
constant riiint : interval ;;
constant i-approx (I: interval; n: nat_plus) : interval ;;
constant i-nonvoid (I: interval) : Prop ;;
constant icompact (I: interval) : Prop ;;
constant subinterval (I: interval; J: interval) : Prop ;;
constant frs-non-dec (p: (Real)List) : Prop ;;
constant frs-refines (p: (Real)List; q: (Real)List) : Prop ;;
constant frs-increasing (p: (Real)List) : Prop ;;
constant frs-separated (p: (Real)List; q: (Real)List) : Prop ;;
constant frs-mesh (p: (Real)List) : Real ;;
constant partitions (I: interval; p: (Real)List) : Prop ;;
constant rset : Type ;;
constant rset-member (A: rset; x: Real) : Prop ;;
constant rseteq (A: rset; B: rset) : Prop ;;
constant mk-rset (P[x: Real]: Prop) : rset ;;
constant upper-bound (A: rset; b: Real) : Prop ;;
constant strict-upper-bound (A: rset; b: Real) : Prop ;;
constant lower-bound (A: rset; b: Real) : Prop ;;
constant bounded-above (A: rset) : Prop ;;
constant sup (A: rset; b: Real) : Prop ;;
constant inf (A: rset; b: Real) : Prop ;;
constant member-closure (A: rset; y: Real) : Prop ;;
constant closed-rset (A: rset) : Prop ;;
constant upper-bounds (A: rset) : rset ;;
constant strict-upper-bounds (A: rset) : rset ;;
constant totally-bounded (A: rset) : Prop ;;
constant rset-neg (A: rset) : rset ;;
constant r-norm-shift (r: Real) : Int ;;
constant r-normalize (r: Real) : Real ;;
constant bag-count (eq: ('T)Deq; x: 'T; bs: ('T)Bag) : Int ;;
constant bag-map' (f: ('A) -> 'B; b: ('A)Bag) : ('B)Bag ;;
constant bag-deq-member (eq: ('A)Deq; x: 'A; b: ('A)Bag) : Bool ;;
constant bag-eq (eq: ('T)Deq; as: ('T)Bag; bs: ('T)Bag) : Bool ;;
constant bag-deq (eq: ('T)Deq) : (('T)Bag)Deq ;;
constant bag-remove-repeats (eq: ('T)Deq; bs: ('T)Bag) : ('T)Bag ;;
constant bag-to-set (eq: ('T)Deq; bs: ('T)Bag) : ('T)Bag ;;
constant bag-remove (eq: ('T)Deq; bs: ('T)Bag; x: 'T) : ('T)Bag ;;
constant bag-remove1 (eq: ('T)Deq; bs: ('T)List; x: 'T) : ('T)List + Unit ;;
constant bag-diff (eq: ('T)Deq; bs: ('T)Bag; as: ('T)Bag) : ('T)Bag + Unit ;;
constant deq-sub-bag (eq: ('T)Deq; as: ('T)Bag; bs: ('T)Bag) : Bool ;;
constant bag-restrict (eq: ('T)Deq; x: 'T; b: ('T)Bag) : ('T)Bag ;;
constant bag-co-restrict (eq: ('T)Deq; x: 'T; b: ('T)Bag) : ('T)Bag ;;
constant abs-val (x: Int) : Int ;;
constant name : Type ;;
constant name-deq : (name)Deq ;;
constant name_eq (x: name; y: name) : Bool ;;
constant name-subst (s: ((name) * (name))List; x: name) : name ;;
constant str1-to-nat (a: Atom) : Int ;;
constant str-to-nat (s: (Atom)List) : Int ;;
constant maybe-new (s: name; avoid: (name)List) : name ;;
constant Id : Type ;;
constant id-deq : (Loc)Deq ;;
constant eq_id (a: Loc; b: Loc) : Bool ;;
constant ('A, 'B) hdataflow : Type ;;
constant hdf-ap (X: ('A,'B)hdataflow; a: 'A) : (('A,'B)hdataflow) * (('B)Bag) ;;
constant hdf-halted (P: ('A,'B)hdataflow) : Bool ;;
constant hdf-halt : ('A,'B)hdataflow ;;
constant hdf-run (P: ('A) -> (('A,'B)hdataflow) * (('B)Bag)) : ('A,'B)hdataflow ;;
constant hdf-out (P: ('A,'B)hdataflow; x: 'A) : ('B)Bag ;;
constant iterate-hdataflow (P: ('A,'B)hdataflow; inputs: ('A)List) : ('A,'B)hdataflow ;;
constant mk-hdf (G[s: 'S; m: 'A]: ('S) * (('B)Bag); H[s: 'S]: Bool; s0: 'S) : ('A,'B)hdataflow ;;
constant hdf-base (F[m: 'A]: ('B)Bag) : ('A,'B)hdataflow ;;
constant hdf-return (x: ('B)Bag) : ('A,'B)hdataflow ;;
constant hdf-at-locs (pr: (Loc) -> ('A,'B)hdataflow; i: Loc; locs: (Loc)Bag) : ('A,'B)hdataflow ;;
constant hdf-compose0 (f: ('B) -> ('C)Bag; X: ('A,'B)hdataflow) : ('A,'C)hdataflow ;;
constant hdf-compose1 (f: ('B) -> 'C; X: ('A,'B)hdataflow) : ('A,'C)hdataflow ;;
constant hdf-compose2 (X: ('A,('B) -> ('C)Bag)hdataflow; Y: ('A,'B)hdataflow) : ('A,'C)hdataflow ;;
constant hdf-compose3 (X: ('A,('B) -> 'C)hdataflow; Y: ('A,'B)hdataflow) : ('A,'C)hdataflow ;;
constant hdf-compose0-bag (f: (('B)Bag) -> ('C)Bag; X: ('A,'B)hdataflow) : ('A,'C)hdataflow ;;
constant simple-hdf-buffer (X: ('A,('B) -> ('B)Bag)hdataflow; bs: ('B)Bag) : ('A,'B)hdataflow ;;
constant hdf-buffer (X: ('A,('B) -> ('B)Bag)hdataflow; bs: ('B)Bag) : ('A,'B)hdataflow ;;
constant simple-hdf-buffer2 (X: ('A,('B) -> 'B)hdataflow; bs: ('B)Bag) : ('A,'B)hdataflow ;;
constant hdf-buffer2 (X: ('A,('B) -> 'B)hdataflow; bs: ('B)Bag) : ('A,'B)hdataflow ;;
constant hdf-state (X: ('A,('B) -> 'B)hdataflow; bs: ('B)Bag) : ('A,'B)hdataflow ;;
constant hdf-single-val-step (P: Prop; X: ('A,'B)hdataflow; 'A: Type; 'B: Type) : Prop ;;
constant hdf-single-valued (X: ('A,'B)hdataflow; 'A: Type; 'B: Type) : Prop ;;
constant hdf-state-single-val (X: ('A,('B) -> 'B)hdataflow; b: 'B) : ('A,'B)hdataflow ;;
constant hdf-state1-single-val (f: ('B) -> ('C) -> 'C; X: ('A,'B)hdataflow; b: 'C) : ('A,'C)hdataflow ;;
constant hdf-memory (X: ('A,('B) -> 'B)hdataflow; bs: ('B)Bag) : ('A,'B)hdataflow ;;
constant hdf-comb2 (f: ('B) -> ('C) -> ('D)Bag; X: ('A,'B)hdataflow; Y: ('A,'C)hdataflow) : ('A,'D)hdataflow ;;
constant hdf-comb3 (f: ('B1) -> ('B2) -> ('B3) -> ('C)Bag; X: ('A,'B1)hdataflow; Y: ('A,'B2)hdataflow; Z: ('A,'B3)hdataflow) : ('A,'C)hdataflow ;;
constant hdf-once (X: ('A,'B)hdataflow) : ('A,'B)hdataflow ;;
constant hdf-until (X: ('A,'B)hdataflow; Y: ('A,'C)hdataflow) : ('A,'B)hdataflow ;;
constant hdf-prior (X: ('A,'B)hdataflow; b: ('B)Bag) : ('A,'B)hdataflow ;;
constant hdf-parallel (X: ('A,'B)hdataflow; Y: ('A,'B)hdataflow) : ('A,'B)hdataflow ;;
constant hdf-parallel-bag (Xs: (('A,'B)hdataflow)Bag) : ('A,'B)hdataflow ;;
constant hdf-union (X: ('A,'B)hdataflow; Y: ('A,'C)hdataflow) : ('A,'B + 'C)hdataflow ;;
constant hdf-sequence (X: ('A,'B)hdataflow; Y: ('A,'C)hdataflow; Z: ('A,'B)hdataflow) : ('A,'B)hdataflow ;;
constant bind-nxt (Y: ('B) -> ('A,'C)hdataflow; p: (('A,'B)hdataflow) * ((('A,'C)hdataflow)Bag); a: 'A) : ((('A,'B)hdataflow) * ((('A,'C)hdataflow)Bag)) * (('C)Bag) ;;
constant simple-bind-nxt (Y: ('B) -> ('A,'C)hdataflow; p: (('A,'B)hdataflow) * ((('A,'C)hdataflow)Bag); a: 'A) : ((('A,'B)hdataflow) * ((('A,'C)hdataflow)Bag)) * (('C)Bag) ;;
constant hdf-bind (X: ('A,'B)hdataflow; Y: ('B) -> ('A,'C)hdataflow) : ('A,'C)hdataflow ;;
constant hdf-bind-gen (X: ('A,'B)hdataflow; Y: ('B) -> ('A,'C)hdataflow; hdfs: (('A,'C)hdataflow)Bag) : ('A,'C)hdataflow ;;
constant simple-hdf-bind (X: ('A,'B)hdataflow; Y: ('B) -> ('A,'C)hdataflow) : ('A,'C)hdataflow ;;
constant rec-bind-nxt (X: ('C) -> ('A,'B)hdataflow; Y: ('C) -> ('A,'C)hdataflow; p: ((('A,'B)hdataflow)Bag) * ((('A,'C)hdataflow)Bag); a: 'A) : (((('A,'B)hdataflow)Bag) * ((('A,'C)hdataflow)Bag)) * (('B)Bag) ;;
constant hdf-rec-bind (X: ('C) -> ('A,'B)hdataflow; Y: ('C) -> ('A,'C)hdataflow) : ('C) -> ('A,'B)hdataflow ;;
constant 'Dom FOAssignment : Type ;;
constant 'Dom FOStruct : Type ;;
constant update-assignment (a: ('Dom)FOAssignment; x: Int; v: 'Dom) : ('Dom)FOAssignment ;;
constant AbstractFOFormula : Type ;;
constant FOSatWith ('Dom: Type; S: ('Dom)FOStruct; a: ('Dom)FOAssignment; fmla: AbstractFOFormula) : Prop ;;
constant AbstractFOAtomic (n: Atom; L: (Int)List) : AbstractFOFormula ;;
constant FOConnective (knd: Atom) : (AbstractFOFormula) -> (AbstractFOFormula) -> AbstractFOFormula ;;
constant FOQuantifier (isall: Bool) : (Int) -> (AbstractFOFormula) -> AbstractFOFormula ;;
constant mFOL : Type ;;
constant mFOatomic (name: Atom; vars: (Int)List) : mFOL ;;
constant mFOconnect (knd: Atom; left: mFOL; right: mFOL) : mFOL ;;
constant mFOquant (isall: Bool; var: Int; body: mFOL) : mFOL ;;
constant mFOatomic-name (x: mFOL) : Atom ;;
constant mFOatomic-vars (x: mFOL) : (Int)List ;;
constant mFOconnect-knd (x: mFOL) : Atom ;;
constant mFOconnect-left (x: mFOL) : mFOL ;;
constant mFOconnect-right (x: mFOL) : mFOL ;;
constant mFOquant-isall (x: mFOL) : Bool ;;
constant mFOquant-var (x: mFOL) : Int ;;
constant mFOquant-body (x: mFOL) : mFOL ;;
constant mFOLvar (n: Int) : Int ;;
constant mFO-dest-atomic (fmla: mFOL; F[nm: Atom; vars: (Int)List]: 'T + Unit) : 'T + Unit ;;
constant mFO-dest-connective (fmla: mFOL; knd: Atom; F[a: mFOL; b: mFOL]: 'T + Unit) : 'T + Unit ;;
constant mFO-dest-quantifier (fmla: mFOL; isall: Bool; F[v: Int; b: mFOL]: 'T + Unit) : 'T + Unit ;;
constant mFO-equal (x: mFOL) : (mFOL) -> Bool ;;
constant eq_mFO (x: mFOL; y: mFOL) : Bool ;;
constant deq-mFO : (mFOL)Deq ;;
constant mFOL-freevars (fmla: mFOL) : (Int)List ;;
constant mFOL-boundvars (fmla: mFOL) : (Int)List ;;
constant mFOL-rename (fmla: mFOL; old: Int; new: Int) : mFOL ;;
constant mFOL-abstract (fmla: mFOL) : AbstractFOFormula ;;
constant mFOL-rename-bound-to-avoid (fmla: mFOL; L: (Int)List) : mFOL ;;
constant mFOL-subst (nw: Int; old: Int; fmla: mFOL) : mFOL ;;
constant mFOLRule : Type ;;
constant mRuleandI : mFOLRule ;;
constant mRuleimpI : mFOLRule ;;
constant mRuleallI (var: Int) : mFOLRule ;;
constant mRuleexistsI (var: Int) : mFOLRule ;;
constant mRuleorI (left: Bool) : mFOLRule ;;
constant mRulehyp : mFOLRule ;;
constant mRuleallI-var (x: mFOLRule) : Int ;;
constant mRuleexistsI-var (x: mFOLRule) : Int ;;
constant mRuleorI-left (x: mFOLRule) : Bool ;;
constant mRuleandE-hypnum (x: mFOLRule) : Int ;;
constant mRuleorE-hypnum (x: mFOLRule) : Int ;;
constant mRuleimpE-hypnum (x: mFOLRule) : Int ;;
constant mRuleallE-hypnum (x: mFOLRule) : Int ;;
constant mRuleallE-var (x: mFOLRule) : Int ;;
constant mRuleexistsE-hypnum (x: mFOLRule) : Int ;;
constant mRuleexistsE-var (x: mFOLRule) : Int ;;
constant mFOL-sequent : Type ;;
constant mk_mFOLSequent (hyps: (mFOL)List; concl: mFOL) : mFOL-sequent ;;
constant mFOL-sequent-abstract (s: mFOL-sequent) : AbstractFOFormula ;;
constant mFOLeffect (sr: (mFOL-sequent) * (mFOLRule)) : (mFOL-sequent)List + Unit ;;
constant mk_mFOLSequentRule (s: mFOL-sequent; r: mFOLRule) : (mFOL-sequent) * (mFOLRule) ;;
constant mk_mFOLProofNode (sr: (mFOL-sequent) * (mFOLRule); subgoals: ('T)List) : ((mFOL-sequent) * (mFOLRule)) * (('T)List) ;;
constant mFOL-proveable (s: mFOL-sequent) : Prop ;;
constant mFOL-proveable-formula (fmla: mFOL) : Prop ;;
constant new-mFO-var (H: (mFOL)List) : Int ;;
constant ('L, 'T) l_tree : Type ;;
constant l_tree_leaf (val: 'L) : ('L,'T)l_tree ;;
constant l_tree_node (val: 'T; left_subtree: ('L,'T)l_tree; right_subtree: ('L,'T)l_tree) : ('L,'T)l_tree ;;
constant l_tree_leaf-val (x: ('L,'T)l_tree) : 'L ;;
constant l_tree_node-val (x: ('L,'T)l_tree) : 'T ;;
constant l_tree_node-left_subtree (x: ('L,'T)l_tree) : ('L,'T)l_tree ;;
constant l_tree_node-right_subtree (x: ('L,'T)l_tree) : ('L,'T)l_tree ;;
constant max_w_ord (t1: 'T; t2: 'T; f: ('T) -> Int) : 'T ;;
constant max_w_unit_l_tree (u1: 'T + Unit; u2: 'T + Unit; f: ('T) -> Int) : 'T + Unit ;;
constant max_l_tree (t: ('L,'T)l_tree; f: ('T) -> Int) : 'T + Unit ;;
constant min_w_ord (t1: 'T; t2: 'T; f: ('T) -> Int) : 'T ;;
constant min_w_unit_l_tree (u1: 'T + Unit; u2: 'T + Unit; f: ('T) -> Int) : 'T + Unit ;;
constant min_l_tree (t: ('L,'T)l_tree; f: ('T) -> Int) : 'T + Unit ;;
constant bs_l_tree (t: ('L,'T)l_tree; f: ('T) -> Int) : Bool ;;
constant bs_l_tree_member (x: 'T; t: ('L,'T)l_tree; f: ('T) -> Int) : Bool ;;
constant fps-rng (r: crng) : crng ;;
constant fps-add-grp (r: crng) : abgrp ;;
constant bm_wt (i: Int) : Int ;;
constant ('T, 'Key) binary_map : Type ;;
constant bm_E : ('T,'Key)binary_map ;;
constant bm_T (key: 'Key; value: 'T; cnt: Int; left: ('T,'Key)binary_map; right: ('T,'Key)binary_map) : ('T,'Key)binary_map ;;
constant bm_T-key (x: ('T,'Key)binary_map) : 'Key ;;
constant bm_T-value (x: ('T,'Key)binary_map) : 'T ;;
constant bm_T-cnt (x: ('T,'Key)binary_map) : Int ;;
constant bm_T-left (x: ('T,'Key)binary_map) : ('T,'Key)binary_map ;;
constant bm_T-right (x: ('T,'Key)binary_map) : ('T,'Key)binary_map ;;
constant bm_cnt_prop0 (m: ('T,'Key)binary_map) : (Int) * (Bool) ;;
constant bm_cnt_prop (m: ('T,'Key)binary_map) : Bool ;;
constant ('T, 'Key) binary-map : Type ;;
constant bm_empty : ('T,'Key)binary-map ;;
constant bm_isEmpty (m: ('T,'Key)binary_map) : Bool ;;
constant bm_numItems (m: ('T,'Key)binary_map) : Int ;;
constant bm_count (m: ('T,'Key)binary_map) : Int ;;
constant bm_first (m: ('T,'Key)binary_map) : 'T + Unit ;;
constant bm_firsti (m: ('T,'Key)binary_map) : ('Key) * ('T) + Unit ;;
constant bm_N (k: 'Key; v: 'T; m1: ('T,'Key)binary-map; m2: ('T,'Key)binary-map) : ('T,'Key)binary-map ;;
constant bm_single_L (a: 'Key; av: 'T; x: ('T,'Key)binary-map; m: ('T,'Key)binary-map) : ('T,'Key)binary-map ;;
constant bm_single_R (b: 'Key; bv: 'T; m: ('T,'Key)binary-map; z: ('T,'Key)binary-map) : ('T,'Key)binary-map ;;
constant bm_double_L (a: 'Key; av: 'T; w: ('T,'Key)binary-map; m: ('T,'Key)binary-map) : ('T,'Key)binary-map ;;
constant bm_double_R (c: 'Key; cv: 'T; m: ('T,'Key)binary-map; z: ('T,'Key)binary-map) : ('T,'Key)binary-map ;;
constant bm_T' (k: 'Key; v: 'T; m1: ('T,'Key)binary-map; m2: ('T,'Key)binary-map) : ('T,'Key)binary-map ;;
constant bm_min (m: ('T,'Key)binary_map) : ('Key) * ('T) ;;
constant bm_delmin (m: ('T,'Key)binary-map) : ('T,'Key)binary-map ;;
constant bm_delete' (m1: ('T,'Key)binary-map; m2: ('T,'Key)binary-map) : ('T,'Key)binary-map ;;
constant bm_singleton (x: 'Key; v: 'T) : ('T,'Key)binary-map ;;
constant 'K bm_compare : Type ;;
constant bm_compare_int : (Int)bm_compare ;;
constant bm_insert (compare: ('Key)bm_compare; m: ('T,'Key)binary-map; x: 'Key; v: 'T) : ('T,'Key)binary-map ;;
constant bm_insert' (compare: ('Key)bm_compare; p: ('Key) * ('T); m: ('T,'Key)binary-map) : ('T,'Key)binary-map ;;
constant bm_insert_if_not_in (compare: ('Key)bm_compare; m: ('T,'Key)binary-map; x: 'Key; v: 'T) : ('T,'Key)binary-map ;;
constant bm_inDomain (compare: ('Key)bm_compare; m: ('T,'Key)binary-map; x: 'Key) : Bool ;;
constant bm_find (compare: ('Key)bm_compare; m: ('T,'Key)binary-map; x: 'Key) : 'T + Unit ;;
constant bm_lookup (compare: ('Key)bm_compare; m: ('T,'Key)binary-map; x: 'Key) : 'T ;;
constant bm_exists (m: ('T,'Key)binary-map; p: ('T) -> Bool) : Bool ;;
constant bm_exists_downeq (compare: ('Key)bm_compare; m: ('T,'Key)binary-map; k: 'Key; p: ('T) -> Bool) : Bool ;;
constant bm_try_remove (compare: ('Key)bm_compare; m: ('T,'Key)binary-map; x: 'Key) : (('T,'Key)binary-map) * ('T + Unit) ;;
constant bm_remove (compare: ('Key)bm_compare; m: ('T,'Key)binary-map; x: 'Key) : (('T,'Key)binary-map) * ('T) ;;
constant bm_listItems_d2l (m: ('T,'Key)binary-map) : (('T)List) -> ('T)List ;;
constant bm_listItems (m: ('T,'Key)binary-map) : ('T)List ;;
constant bm_listItemsi_d2l (m: ('T,'Key)binary-map) : ((('Key) * ('T))List) -> (('Key) * ('T))List ;;
constant bm_listItemsi (m: ('T,'Key)binary-map) : (('Key) * ('T))List ;;
constant bm_listKeys_d2l (m: ('T,'Key)binary-map) : (('Key)List) -> ('Key)List ;;
constant bm_listKeys (m: ('T,'Key)binary-map) : ('Key)List ;;
constant bm_collate_left (m: ('T,'Key)binary-map) : ((('T,'Key)binary-map)List) -> (('T,'Key)binary-map)List ;;
constant bm_collate_next (l: (('T,'Key)binary-map)List) : (('T,'Key)binary-map) * ((('T,'Key)binary-map)List) ;;
constant bm_mapi (f: ('Key) -> ('T) -> 'T; m: ('T,'Key)binary-map) : ('T,'Key)binary-map ;;
constant bm_map (f: ('T) -> 'T; m: ('T,'Key)binary-map) : ('T,'Key)binary-map ;;
constant bm_foldli_aux (f: ('Key) -> ('T) -> ('U) -> 'U; m: ('T,'Key)binary-map) : ('U) -> 'U ;;
constant bm_foldli (f: ('Key) -> ('T) -> ('U) -> 'U; init: 'U; m: ('T,'Key)binary-map) : 'U ;;
constant bm_foldl (f: ('T) -> ('U) -> 'U; init: 'U; m: ('T,'Key)binary-map) : 'U ;;
constant bm_unionWith_ins (compare: ('Key)bm_compare; f: ('T) -> ('T) -> 'T; key: 'Key; x: 'T; m: ('T,'Key)binary-map) : ('T,'Key)binary-map ;;
constant bm_unionWith (compare: ('Key)bm_compare; f: ('T) -> ('T) -> 'T; m1: ('T,'Key)binary-map; m2: ('T,'Key)binary-map) : ('T,'Key)binary-map ;;
constant pform : Type ;;
constant p-add (p: pform; q: pform) : pform ;;
constant p-mul (p: pform; q: pform) : pform ;;
constant p-eq (p: pform; q: pform) : Prop ;;
constant finite-prob-space : Type ;;
constant unit-fps : finite-prob-space ;;
constant binary-fps : finite-prob-space ;;
constant ternary-fps : finite-prob-space ;;
constant uniform-fps (n: nat_plus) : finite-prob-space ;;
constant IdLnk : Type ;;
constant mk_lnk (i: Loc; j: Loc; n: Loc) : IdLnk ;;
constant lnk-inv (l: IdLnk) : IdLnk ;;
constant Knd : Type ;;
constant Kind : Type ;;
constant isrcv (k: Knd) : Bool ;;
constant islocal (k: Knd) : Bool ;;
constant rcv (l: IdLnk; tg: Loc) : Knd ;;
constant locl (a: Loc) : Knd ;;
constant lnk (k: Knd) : IdLnk ;;
constant tagof (k: Knd) : Loc ;;
constant actof (k: Knd) : Loc ;;
constant kindcase (k: Knd; f[a: Loc]: 'B; g[l: IdLnk; t: Loc]: 'B) : 'B ;;
constant kind-rename (ra: (Loc) -> Loc; rt: (Loc) -> Loc; k: Knd) : Knd ;;
constant lsrc (l: IdLnk) : Loc ;;
constant ldst (l: IdLnk) : Loc ;;
constant lname (l: IdLnk) : Loc ;;
constant links-from-to (tg: Loc; srclocs: (Loc)List; dstlocs: (Loc)List) : (IdLnk)List ;;
constant rcvs-on (tg: Loc; links: (IdLnk)List) : (Knd)List ;;
constant lpath (p: (IdLnk)List) : Prop ;;
constant lconnects (p: (IdLnk)List; i: Loc; j: Loc) : Prop ;;
constant vlnk (i: Loc; j: Loc; x: Loc) : IdLnk ;;
constant idlnk-deq : (IdLnk)Deq ;;
constant eq_lnk (a: IdLnk; b: IdLnk) : Bool ;;
constant isrcvl (l: IdLnk; k: Knd) : Bool ;;
constant l_intersection (eq: ('A)Deq; L1: ('A)List; L2: ('A)List) : ('A)List ;;
constant Kind-deq : (Knd)Deq ;;
constant eq_knd (a: Knd; b: Knd) : Bool ;;
constant rcvset (a: Loc; b: Loc; S: (Loc)List; k: Knd) : Bool ;;
constant has-src (i: Loc; k: Knd) : Bool ;;
constant hasloc (k: Knd; i: Loc) : Bool ;;
constant kind-loc (k: Knd; i: Loc) : Bool ;;
constant LocKnd : Type ;;
constant locknd-deq : (LocKnd)Deq ;;
constant locknd (i: Loc; k: Knd) : LocKnd ;;
constant MaName : Type ;;
constant varname (x: Loc; i: Loc) : MaName ;;
constant maname-deq : (MaName)Deq ;;
constant manames-overlap-case (nms1: (MaName)List; nms2: (MaName)List; x: 'T; y: 'T) : 'T ;;
constant normal-type ('T: Type) : Prop ;;
constant 'T process : Type ;;
constant 'T process : Type ;;
constant 'V consensus-state1 : Type ;;
constant cs-undecided : ('V)consensus-state1 ;;
constant cs-decided (v: 'V) : ('V)consensus-state1 ;;
constant consensus-ts1 ('V: Type) : transition-system ;;
constant 'V consensus-state2 : Type ;;
constant cs-is-decided (x: ('V)consensus-state2) : Bool ;;
constant cs-ambivalent : ('V)consensus-state2 ;;
constant cs-predecided (v: 'V) : ('V)consensus-state2 ;;
constant consensus-ts2 ('V: Type) : transition-system ;;
constant 'V consensus-state3 : Type ;;
constant cs-initial : ('V)consensus-state3 ;;
constant cs-withdrawn : ('V)consensus-state3 ;;
constant cs-considering (v: 'V) : ('V)consensus-state3 ;;
constant cs-commited (v: 'V) : ('V)consensus-state3 ;;
constant cs-is-committed (x: ('V)consensus-state3) : Bool ;;
constant cs-is-considering (x: ('V)consensus-state3) : Bool ;;
constant consensus-ts3 ('V: Type) : transition-system ;;
constant cs-ref-map3 (L: (('V)consensus-state3)List) : ('V)consensus-state2 ;;
constant int_consensus_accum (n: Int) : ((Bool) * ((Int) * (((Loc)List) * (((Int)List) * (Int))))) -> (Int + (Loc) * ((Int) * (Int))) -> (Bool) * ((Int) * (((Loc)List) * (((Int)List) * (Int)))) ;;
constant int_consensus_init : (Bool) * ((Int) * ((('T)List) * ((('T1)List) * (Int)))) ;;
constant int_consensus_test (s: (Bool) * ((Int) * (((Loc)List) * (((Int)List) * (Int))))) : (Int) * (Int) + top ;;
constant event_ordering : Type ;;
constant event_system_typename : Type ;;
constant EOrder : Type ;;
constant EKind : Type ;;
constant EVal : Type ;;
constant es-LnkTag-deq : ((IdLnk) * (Loc))Deq ;;
constant possible-event (poss: (event_ordering) -> Prop) : Prop ;;
constant es-decl-set : Type ;;
constant es-decl-set-domain (dd: es-decl-set) : (Loc)List ;;
constant es-decl-set-avoids (dd: es-decl-set; x: Loc) : Prop ;;
constant es-decl-set-avoids-tag (dd: es-decl-set; x: Loc) : Prop ;;
constant es-decl-set-declares-tag (dd: es-decl-set; x: Loc; 'T: Type) : Prop ;;
constant es-decl-sets-compatible (dd1: es-decl-set; dd2: es-decl-set) : Prop ;;
constant es-decl-set-join (dd1: es-decl-set; dd2: es-decl-set) : es-decl-set ;;
constant es-decl-sets-sub (dd1: es-decl-set; dd2: es-decl-set) : Prop ;;
constant normal-decl-set (dd: es-decl-set) : Prop ;;
constant cond-to-list (x: 'A + Unit) : ('A)List ;;
constant 'T class-program : Type ;;
constant cp-domain (cp: (top)class-program) : (Loc)List ;;
constant cp-decls (cp: (top)class-program) : es-decl-set ;;
constant concrete-interface : Type ;;
constant ci-decls (c: concrete-interface) : es-decl-set ;;
constant ci-port (l: IdLnk; tg: Loc; 'T: Type) : concrete-interface ;;
constant threshold_accum (test: ('S) -> ('A) -> Bool; nxt: (('S) * ('A)) -> 'S; step: ('S) -> ('A) -> 'S; g: (('S) * ('A)) -> 'B + Unit) : (('S) * ('B + Unit)) -> ('A) -> ('S) * ('B + Unit) ;;
constant threshold_val (p: ('S) * ('A + Unit)) : 'A + Unit ;;
constant thread : Type ;;
constant thread-name (t: thread) : Loc ;;
constant thread-session (t: thread) : Loc ;;
constant single-valued-classrel-all ('Info: Type; 'T: Type; X: ('T)Class) : Prop ;;
constant class-loc-bound ('Info: Type; 'T: Type; X: ('T)Class; L: (Loc)Bag) : Prop ;;
constant loc-bounded-class ('Info: Type; 'T: Type; X: ('T)Class) : Prop ;;
constant local-class-predicate (F: (Loc) -> ('Info,'A)hdataflow; 'Info: Type; 'A: Type; X: ('A)Class) : Prop ;;
constant local-class ('Info: Type; 'A: Type; X: ('A)Class) : Prop ;;
constant global-class ('Info: Type; 'A: Type; X: ('A)Class) : Prop ;;
constant class-ap-val (X: (('A) -> 'B)Class; a: 'A) : ('B)Class ;;
constant eclass-union (X: (('A)Bag)Class) : ('A)Class ;;
constant eclass0 (f: (Loc) -> ('B) -> ('C)Bag; X: ('B)Class) : ('C)Class ;;
constant eclass1 (f: (Loc) -> ('B) -> 'C; X: ('B)Class) : ('C)Class ;;
constant eclass2 (X: (('B) -> ('C)Bag)Class; Y: ('B)Class) : ('C)Class ;;
constant eclass3 (X: (('B) -> 'C)Class; Y: ('B)Class) : ('C)Class ;;
constant eclass-cond (X: (('B) -> 'B)Class; Y: ('B)Class) : ('B)Class ;;
constant eclass0-bag (f: (Loc) -> (('B)Bag) -> ('C)Bag; X: ('B)Class) : ('C)Class ;;
constant eclass2-bag (X: ((('B)Bag) -> ('C)Bag)Class; Y: ('B)Class) : ('C)Class ;;
constant return-loc-class (x: (Loc) -> 'A) : ('A)Class ;;
constant return-loc-bag-class (x: (Loc) -> ('A)Bag) : ('A)Class ;;
constant simple-loc-comb0 (b[l: Loc]: ('B)Bag) : ('B)Class ;;
constant eclass-compose1 (f: (('A)Bag) -> ('B)Bag; X: ('A)Class) : ('B)Class ;;
constant eclass-compose2 (f: (('A)Bag) -> (('B)Bag) -> ('C)Bag; X: ('A)Class; Y: ('B)Class) : ('C)Class ;;
constant eclass-compose3 (f: (('A)Bag) -> (('B)Bag) -> (('C)Bag) -> ('D)Bag; X: ('A)Class; Y: ('B)Class; Z: ('C)Class) : ('D)Class ;;
constant eclass-compose4 (f: (('A)Bag) -> (('B)Bag) -> (('C)Bag) -> (('D)Bag) -> ('E)Bag; X: ('A)Class; Y: ('B)Class; Z: ('C)Class; V: ('D)Class) : ('E)Class ;;
constant es-empty-interface : ('A)Class ;;
constant bind-class (X: ('A)Class; Y[x: 'A]: ('B)Class) : ('B)Class ;;
constant return-class (x: 'A) : ('A)Class ;;
constant parallel-class (X: ('T)Class; Y: ('T)Class) : ('T)Class ;;
constant cond-class (X: ('A)Class; Y: ('A)Class) : ('A)Class ;;
constant es-interface-image (f: ('A) -> 'B; Ia: ('A)Class) : ('B)Class ;;
constant es-filter-image (f: ('A) -> ('B)Bag; X: ('A)Class) : ('B)Class ;;
constant es-interface-left (X: ('A + 'B)Class) : ('A)Class ;;
constant es-interface-right (X: ('A + 'B)Class) : ('B)Class ;;
constant first-class (L: (('A)Class)List) : ('A)Class ;;
constant mapfilter-class (P[v: 'A]: Bool; f[v: 'A]: 'B; X: ('A)Class) : ('B)Class ;;
constant map-class (f[v: 'A]: 'B; X: ('A)Class) : ('B)Class ;;
constant es-tagged-true-class (X: (('T) * (Bool))Class) : ('T)Class ;;
constant first-eclass (Xs: (('A)Class)List) : ('A)Class ;;
constant es-interface-union (X: ('A)Class; Y: ('B)Class) : ('A + 'B)Class ;;
constant outl-class (X: ('A + top)Class) : ('A)Class ;;
constant outr-class (X: (top + 'A)Class) : ('A)Class ;;
constant or-class (X: ('A)Class; Y: ('B)Class) : ('A + 'B)Class ;;
constant es-interface-or (X: ('A)Class; Y: ('B)Class) : (('A,'B)one_or_both)Class ;;
constant es-interface-or-left (X: (('A,'B)one_or_both)Class) : ('A)Class ;;
constant es-interface-or-right (X: (('A,'B)one_or_both)Class) : ('B)Class ;;
constant es-interface-state (X: ('T)Class; g: (('T)List) -> ('A)Bag) : ('A)Class ;;
constant es-interface-disjoint ('Info: Type; X: ('A)Class; Y: ('B)Class) : Prop ;;
constant es-interface-filter (X: ('A)Class; P[a: 'A]: Bool) : ('A)Class ;;
constant class-at (X: ('T)Class; locs: (Loc)Bag) : ('T)Class ;;
constant es-interface-at (X: ('T)Class; i: Loc) : ('T)Class ;;
constant es-interface-count (X: (top)Class) : (Int)Class ;;
constant es-interface-accum (f: ('B) -> ('A) -> 'B; b: 'B; X: ('A)Class) : ('B)Class ;;
constant imax-class (lb: Int; f[v: 'T]: Int; X: ('T)Class) : (Int)Class ;;
constant accum-class (f[b: 'B; a: 'A]: 'B; b[a: 'A]: 'B; X: ('A)Class) : ('B)Class ;;
constant max-f-class (f[v: 'A]: Int; X: ('A)Class) : ('A)Class ;;
constant es-interface-unmatched (A: ('Ta)Class; B: ('Tb)Class; R: ('Ta) -> ('Tb) -> Bool) : (('Ta)List)Class ;;
constant until-class (X: ('A)Class; Y: (top)Class) : ('A)Class ;;
constant once-class (X: ('A)Class) : ('A)Class ;;
constant send-once-class (b: ('A)Bag) : ('A)Class ;;
constant send-once-loc-class (b: (Loc) -> ('A)Bag) : ('A)Class ;;
constant on-loc-class (X: (Loc) -> ('T)Class) : ('T)Class ;;
constant but-first-class (X: ('A)Class) : ('A)Class ;;
constant skip-first-class (X: ('A)Class) : ('A)Class ;;
constant primed-class (X: ('T)Class) : ('T)Class ;;
constant primed-class-opt (X: ('T)Class; b: (Loc) -> ('T)Bag) : ('T)Class ;;
constant loop-class (X: (('B) -> ('B)Bag)Class; init: (Loc) -> ('B)Bag) : ('B)Class ;;
constant loop-class2 (X: (('B) -> 'B)Class; init: (Loc) -> ('B)Bag) : ('B)Class ;;
constant loop-class-state (X: (('B) -> 'B)Class; init: (Loc) -> ('B)Bag) : ('B)Class ;;
constant loop-class-memory (X: (('B) -> 'B)Class; init: (Loc) -> ('B)Bag) : ('B)Class ;;
constant eclass-disju (X: ('A)Class; Y: ('B)Class) : ('A + 'B)Class ;;
constant state-class1 (init: (Loc) -> 'B; f: (Loc) -> ('A) -> ('B) -> 'B; X: ('A)Class) : ('B)Class ;;
constant state-class2 (init: (Loc) -> 'B; tr1: (Loc) -> ('A1) -> ('B) -> 'B; X1: ('A1)Class; tr2: (Loc) -> ('A2) -> ('B) -> 'B; X2: ('A2)Class) : ('B)Class ;;
constant state-class3 (init: (Loc) -> 'B; tr1: (Loc) -> ('A1) -> ('B) -> 'B; X1: ('A1)Class; tr2: (Loc) -> ('A2) -> ('B) -> 'B; X2: ('A2)Class; tr3: (Loc) -> ('A3) -> ('B) -> 'B; X3: ('A3)Class) : ('B)Class ;;
constant state-class4 (init: (Loc) -> 'B; tr1: (Loc) -> ('A1) -> ('B) -> 'B; X1: ('A1)Class; tr2: (Loc) -> ('A2) -> ('B) -> 'B; X2: ('A2)Class; tr3: (Loc) -> ('A3) -> ('B) -> 'B; X3: ('A3)Class; tr4: (Loc) -> ('A4) -> ('B) -> 'B; X4: ('A4)Class) : ('B)Class ;;
constant memory-class1 (init: (Loc) -> 'B; f: (Loc) -> ('A) -> ('B) -> 'B; X: ('A)Class) : ('B)Class ;;
constant memory-class2 (init: (Loc) -> 'B; tr1: (Loc) -> ('A1) -> ('B) -> 'B; X1: ('A1)Class; tr2: (Loc) -> ('A2) -> ('B) -> 'B; X2: ('A2)Class) : ('B)Class ;;
constant memory-class3 (init: (Loc) -> 'B; tr1: (Loc) -> ('A1) -> ('B) -> 'B; X1: ('A1)Class; tr2: (Loc) -> ('A2) -> ('B) -> 'B; X2: ('A2)Class; tr3: (Loc) -> ('A3) -> ('B) -> 'B; X3: ('A3)Class) : ('B)Class ;;
constant memory-class4 (init: (Loc) -> 'B; tr1: (Loc) -> ('A1) -> ('B) -> 'B; X1: ('A1)Class; tr2: (Loc) -> ('A2) -> ('B) -> 'B; X2: ('A2)Class; tr3: (Loc) -> ('A3) -> ('B) -> 'B; X3: ('A3)Class; tr4: (Loc) -> ('A4) -> ('B) -> 'B; X4: ('A4)Class) : ('B)Class ;;
constant eclass-state (init: (Loc) -> 'B; f: (Loc) -> ('A) -> ('B) -> 'B; X: ('A)Class) : ('B)Class ;;
constant class-opt (X: ('T)Class; b: (Loc) -> ('T)Bag) : ('T)Class ;;
constant class-opt-class (X: ('T)Class; Y: ('T)Class) : ('T)Class ;;
constant es-prior-val (X: ('T)Class) : ('T)Class ;;
constant simple-comb2 (F[x: ('A)Bag; y: ('B)Bag]: ('C)Bag; X: ('A)Class; Y: ('B)Class) : ('C)Class ;;
constant simple-loc-comb2 (F[l: Loc; a: ('A)Bag; b: ('B)Bag]: ('C)Bag; X: ('A)Class; Y: ('B)Class) : ('C)Class ;;
constant simple-loc-comb1 (F[l: Loc; w: ('A)Bag]: ('B)Bag; X: ('A)Class) : ('B)Class ;;
constant simple-comb1 (F[x: ('A)Bag]: ('B)Bag; X: ('A)Class) : ('B)Class ;;
constant simple-comb0 (b: ('B)Bag) : ('B)Class ;;
constant rec-combined-loc-class2 (F[l: Loc; x: ('A)Bag; y: ('B)Bag; s: ('C)Bag]: ('C)Bag; X: ('A)Class; Y: ('B)Class) : ('C)Class ;;
constant rec-combined-loc-class1 (F[l: Loc; x: ('A)Bag; s: ('B)Bag]: ('B)Bag; X: ('A)Class) : ('B)Class ;;
constant rec-combined-class2 (F[x: ('A)Bag; y: ('B)Bag; s: ('C)Bag]: ('C)Bag; X: ('A)Class; Y: ('B)Class) : ('C)Class ;;
constant rec-combined-class1 (F[x: ('A)Bag; s: ('B)Bag]: ('B)Bag; X: ('A)Class) : ('B)Class ;;
constant rec-combined-class-0 (F: (('A)Bag) -> ('A)Bag) : ('A)Class ;;
constant rec-combined-class-1 (F: (('A)Bag) -> (('B)Bag) -> ('B)Bag; X: ('A)Class) : ('B)Class ;;
constant rec-combined-class-2 (F: (('A)Bag) -> (('B)Bag) -> (('C)Bag) -> ('C)Bag; X: ('A)Class; Y: ('B)Class) : ('C)Class ;;
constant rec-combined-class-3 (F: (('A)Bag) -> (('B)Bag) -> (('C)Bag) -> (('D)Bag) -> ('D)Bag; X: ('A)Class; Y: ('B)Class; Z: ('C)Class) : ('D)Class ;;
constant rec-combined-class-opt-1 (F: (('A)Bag) -> (('B)Bag) -> ('B)Bag; init: (Loc) -> ('B)Bag; X: ('A)Class) : ('B)Class ;;
constant rec-combined-loc-class-opt-1 (F: (Loc) -> (('A)Bag) -> (('B)Bag) -> ('B)Bag; init: (Loc) -> ('B)Bag; X: ('A)Class) : ('B)Class ;;
constant rec-combined-loc-class-0 (F: (Loc) -> (('A)Bag) -> ('A)Bag) : ('A)Class ;;
constant rec-combined-loc-class-1 (F: (Loc) -> (('A)Bag) -> (('B)Bag) -> ('B)Bag; X: ('A)Class) : ('B)Class ;;
constant rec-combined-loc-class-2 (F: (Loc) -> (('A)Bag) -> (('B)Bag) -> (('C)Bag) -> ('C)Bag; X: ('A)Class; Y: ('B)Class) : ('C)Class ;;
constant rec-combined-loc-class-3 (F: (Loc) -> (('A)Bag) -> (('B)Bag) -> (('C)Bag) -> (('D)Bag) -> ('D)Bag; X: ('A)Class; Y: ('B)Class; Z: ('C)Class) : ('D)Class ;;
constant rec-combined-class-opt-2 (F: (('A)Bag) -> (('B)Bag) -> (('C)Bag) -> ('C)Bag; init: (Loc) -> ('C)Bag; X: ('A)Class; Y: ('B)Class) : ('C)Class ;;
constant rec-combined-class-opt-3 (F: (('A)Bag) -> (('B)Bag) -> (('C)Bag) -> (('D)Bag) -> ('D)Bag; init: (Loc) -> ('D)Bag; X: ('A)Class; Y: ('B)Class; Z: ('C)Class) : ('D)Class ;;
constant rec-combined-loc-class-opt-2 (F: (Loc) -> (('A)Bag) -> (('B)Bag) -> (('C)Bag) -> ('C)Bag; init: (Loc) -> ('C)Bag; X: ('A)Class; Y: ('B)Class) : ('C)Class ;;
constant rec-combined-loc-class-opt-3 (F: (Loc) -> (('A)Bag) -> (('B)Bag) -> (('C)Bag) -> (('D)Bag) -> ('D)Bag; init: (Loc) -> ('D)Bag; X: ('A)Class; Y: ('B)Class; Z: ('C)Class) : ('D)Class ;;
constant simple-comb3 (F[x: ('A)Bag; y: ('B)Bag; z: ('C)Bag]: ('D)Bag; X: ('A)Class; Y: ('B)Class; Z: ('C)Class) : ('D)Class ;;
constant simple-loc-comb-2 (F: (Loc) -> (('A)Bag) -> (('B)Bag) -> ('C)Bag; X: ('A)Class; Y: ('B)Class) : ('C)Class ;;
constant simple-loc-comb-3 (F: (Loc) -> (('A)Bag) -> (('B)Bag) -> (('C)Bag) -> ('D)Bag; X: ('A)Class; Y: ('B)Class; Z: ('C)Class) : ('D)Class ;;
constant simple-loc-comb-1 (F: (Loc) -> (('A)Bag) -> ('B)Bag; X: ('A)Class) : ('B)Class ;;
constant simple-loc-comb-0 (b: (Loc) -> ('B)Bag) : ('B)Class ;;
constant simple-comb-2 (F: (('A)Bag) -> (('B)Bag) -> ('C)Bag; X: ('A)Class; Y: ('B)Class) : ('C)Class ;;
constant simple-comb-3 (F: (('A)Bag) -> (('B)Bag) -> (('C)Bag) -> ('D)Bag; X: ('A)Class; Y: ('B)Class; Z: ('C)Class) : ('D)Class ;;
constant simple-comb-1 (F: (('A)Bag) -> ('B)Bag; X: ('A)Class) : ('B)Class ;;
constant simple-comb-0 (b: ('B)Bag) : ('B)Class ;;
constant simple-comb-4 (F: (('A)Bag) -> (('B)Bag) -> (('C)Bag) -> (('D)Bag) -> ('E)Bag; W: ('A)Class; X: ('B)Class; Y: ('C)Class; Z: ('D)Class) : ('E)Class ;;
constant simple-loc-comb-4 (F: (Loc) -> (('A)Bag) -> (('B)Bag) -> (('C)Bag) -> (('D)Bag) -> ('E)Bag; W: ('A)Class; X: ('B)Class; Y: ('C)Class; Z: ('D)Class) : ('E)Class ;;
constant mbind-class (X: ('A)Class; Y: ('A) -> ('B)Class) : ('B)Class ;;
constant disjoint-union-comb (X: ('A)Class; Y: ('B)Class) : ('A + 'B)Class ;;
constant null-class : ('T)Class ;;
constant sequence-class (X: ('A)Class; Y: ('B)Class; Z: ('A)Class) : ('A)Class ;;
constant lift-class (X: ('A)Class) : (('A)Bag)Class ;;
constant send-on-class (b: ('B)Bag; X: ('A)Class) : ('B)Class ;;
constant send-class (b: ('T)Bag) : ('T)Class ;;
constant send-first-class (b: ('T)Bag) : ('T)Class ;;
constant on-first-class (X: ('A)Class) : ('A)Class ;;
constant not-self-starting ('Info: Type; 'A: Type; Y: ('A) -> ('A)Class) : Prop ;;
constant rec-bind-class (X: ('A) -> ('B)Class; Y: ('A) -> ('A)Class) : ('A) -> ('B)Class ;;
constant prior-as-rec-bind-class-out (i: ('T)Bag + top) : ('T)Class ;;
constant prior-as-rec-bind-class-in (X: ('A)Class; i: top + ('A)Bag + top) : (('A)Bag + ('A)Bag + Unit)Class ;;
constant prior-as-rec-bind-class (X: ('A)Class) : ('A)Class ;;
constant prior-as-rec-bind-class-out2 (i: ('A)Bag) : ('A)Class ;;
constant prior-as-rec-bind-class-in2 (X: ('A)Class; i: ('A)Bag) : (('A)Bag)Class ;;
constant prior-as-rec-bind-class2 (X: ('A)Class) : ('A)Class ;;
constant rec-bind-class-arg (X: ('A) -> ('B)Class; Y: ('A) -> ('A)Class; a: 'A) : ('B)Class ;;
constant rec-op-bind-class (X: ('A) -> ('B)Class; Y: ('A) -> ('A)Class; F: ('A) -> (('B)Bag) -> ('B)Bag) : ('A) -> ('B)Class ;;
constant es-latest-val (X: ('T)Class) : ('T)Class ;;
constant es-threshold (init: 'S; f: ('S) -> ('A) -> 'S; test: ('S) -> ('A) -> Bool; nxt: (('S) * ('A)) -> 'S; X: ('A)Class) : (('S) * ('A))Class ;;
constant es-interface-match (A: ('Ta)Class; B: ('Tb)Class; R: ('Ta) -> ('Tb) -> Bool) : (('Ta) * ('Tb))Class ;;
constant es-interface-pair (X: ('A)Class; Y: ('B)Class) : (('A) * ('B))Class ;;
constant latest-pair (X: ('A)Class; Y: ('B)Class) : (('A) * ('B))Class ;;
constant es-or-latest (X: ('A)Class; Y: ('B)Class) : (('A,'B)one_or_both)Class ;;
constant es-interface-triple (X: ('A)Class; Y: ('B)Class; Z: ('C)Class) : (('A) * (('B) * ('C)))Class ;;
constant es-interface-pair-prior (X: ('A)Class; Y: ('B)Class) : (('A) * ('B))Class ;;
constant es-prior-class-when (X: ('A)Class; Y: ('B)Class; d: 'A) : (('B) * ('A))Class ;;
constant es-prior-match (R: ('A) -> ('B) -> Bool; X: ('A)Class; Y: ('B)Class) : (('A) * ('B))Class ;;
constant es-interface-numbered (A: ('T)Class) : (('T) * (Int))Class ;;
constant ('Info, 'A, 'B) es-component : Type ;;
constant hdataflow-class (F: (Loc) -> ('Info,'A)hdataflow) : ('A)Class ;;
constant mData : Type ;;
constant mdata-class (f: (name) -> Type; hdr: name) : (mData)Class ;;
constant base-headers-msg-val (hdr: name) : ('T)Class ;;
constant typed-base-class (hdr: name; 'T: Type) : ('T)Class ;;
constant base-headers-msg-val-loc (hdr: name; locs: (Loc)Bag) : ('T)Class ;;
constant info-delivered ('Info: Type; X: ((Loc) * ('Info))Class) : Prop ;;
constant disjoint-union-tr (tr1: (Loc) -> ('A) -> ('S) -> 'S; tr2: (Loc) -> ('B) -> ('S) -> 'S) : (Loc) -> ('A + 'B) -> ('S) -> 'S ;;
constant lifting1-loc (f: (Loc) -> ('A) -> 'B; loc: Loc; b: ('A)Bag) : ('B)Bag ;;
constant lifting2-loc (f: (Loc) -> ('A) -> ('B) -> 'C; loc: Loc; abag: ('A)Bag; bbag: ('B)Bag) : ('C)Bag ;;
constant lifting-loc-0 (f: (Loc) -> 'B) : (Loc) -> ('B)Bag ;;
constant lifting-loc-1 (f: (Loc) -> ('A) -> 'B) : (Loc) -> (('A)Bag) -> ('B)Bag ;;
constant lifting-loc-2 (f: (Loc) -> ('A) -> ('B) -> 'C) : (Loc) -> (('A)Bag) -> (('B)Bag) -> ('C)Bag ;;
constant lifting-loc-3 (f: (Loc) -> ('A) -> ('B) -> ('C) -> 'D) : (Loc) -> (('A)Bag) -> (('B)Bag) -> (('C)Bag) -> ('D)Bag ;;
constant concat-lifting1-loc (f: (Loc) -> ('A) -> ('B)Bag; b: ('A)Bag; l: Loc) : ('B)Bag ;;
constant concat-lifting2-loc (f: (Loc) -> ('A) -> ('B) -> ('C)Bag; abag: ('A)Bag; bbag: ('B)Bag; l: Loc) : ('C)Bag ;;
constant concat-lifting-loc-0 (f: (Loc) -> ('B)Bag) : (Loc) -> ('B)Bag ;;
constant concat-lifting-loc-1 (f: (Loc) -> ('A) -> ('B)Bag) : (Loc) -> (('A)Bag) -> ('B)Bag ;;
constant concat-lifting-loc-2 (f: (Loc) -> ('A) -> ('B) -> ('C)Bag) : (Loc) -> (('A)Bag) -> (('B)Bag) -> ('C)Bag ;;
constant concat-lifting-loc-3 (f: (Loc) -> ('A) -> ('B) -> ('C) -> ('D)Bag) : (Loc) -> (('A)Bag) -> (('B)Bag) -> (('C)Bag) -> ('D)Bag ;;
constant Accum-class (f: ('A) -> ('B) -> 'B; init: (Loc) -> ('B)Bag; X: ('A)Class) : ('B)Class ;;
constant Accum-loc-class (f: (Loc) -> ('A) -> ('B) -> 'B; init: (Loc) -> ('B)Bag; X: ('A)Class) : ('B)Class ;;
constant Memory-class (f: ('A) -> ('B) -> 'B; init: (Loc) -> ('B)Bag; X: ('A)Class) : ('B)Class ;;
constant Memory-loc-class (f: (Loc) -> ('A) -> ('B) -> 'B; init: (Loc) -> ('B)Bag; X: ('A)Class) : ('B)Class ;;
constant Threshold-Combinator (R: ('A) -> ('S) -> Bool; X: ('A)Class; init_state: (Loc) -> ('S)Bag; accum: ('A) -> ('S) -> 'S; f: (Loc) -> ('A) -> ('S) -> ('B)Bag) : ('B)Class ;;
constant disjoint-union-class (X: ('A)Class; Y: ('B)Class) : ('A + 'B)Class ;;
constant Memory1 (init: (Loc) -> 'B; tr: (Loc) -> ('A) -> ('B) -> 'B; X: ('A)Class) : ('B)Class ;;
constant Memory2 (init: (Loc) -> 'S; tr1: (Loc) -> ('A1) -> ('S) -> 'S; X1: ('A1)Class; tr2: (Loc) -> ('A2) -> ('S) -> 'S; X2: ('A2)Class) : ('S)Class ;;
constant Memory3 (init: (Loc) -> 'S; tr1: (Loc) -> ('A1) -> ('S) -> 'S; X1: ('A1)Class; tr2: (Loc) -> ('A2) -> ('S) -> 'S; X2: ('A2)Class; tr3: (Loc) -> ('A3) -> ('S) -> 'S; X3: ('A3)Class) : ('S)Class ;;
constant Memory4 (init: (Loc) -> 'S; tr1: (Loc) -> ('A1) -> ('S) -> 'S; X1: ('A1)Class; tr2: (Loc) -> ('A2) -> ('S) -> 'S; X2: ('A2)Class; tr3: (Loc) -> ('A3) -> ('S) -> 'S; X3: ('A3)Class; tr4: (Loc) -> ('A4) -> ('S) -> 'S; X4: ('A4)Class) : ('S)Class ;;
constant State-class (init: (Loc) -> ('B)Bag; f: ('A) -> ('B) -> 'B; X: ('A)Class) : ('B)Class ;;
constant State-comb (init: (Loc) -> ('B)Bag; f: ('A) -> ('B) -> 'B; X: ('A)Class) : ('B)Class ;;
constant State-loc-comb (init: (Loc) -> ('B)Bag; f: (Loc) -> ('A) -> ('B) -> 'B; X: ('A)Class) : ('B)Class ;;
constant State1 (init: (Loc) -> 'B; tr: (Loc) -> ('A) -> ('B) -> 'B; X: ('A)Class) : ('B)Class ;;
constant State2 (init: (Loc) -> 'S; tr1: (Loc) -> ('A1) -> ('S) -> 'S; X1: ('A1)Class; tr2: (Loc) -> ('A2) -> ('S) -> 'S; X2: ('A2)Class) : ('S)Class ;;
constant State3 (init: (Loc) -> 'S; tr1: (Loc) -> ('A1) -> ('S) -> 'S; X1: ('A1)Class; tr2: (Loc) -> ('A2) -> ('S) -> 'S; X2: ('A2)Class; tr3: (Loc) -> ('A3) -> ('S) -> 'S; X3: ('A3)Class) : ('S)Class ;;
constant 'T labeled-graph : Type ;;
constant lg-size (g: ('T)labeled-graph) : Int ;;
constant lg-nil : ('T)labeled-graph ;;
constant lg-append (g1: ('T)labeled-graph; g2: ('T)labeled-graph) : ('T)labeled-graph ;;
constant lg-contains ('T: Type; g1: ('T)labeled-graph; g2: ('T)labeled-graph) : Prop ;;
constant lg-filter (P: ('T) -> Bool; G: ('T)labeled-graph) : ('T)labeled-graph ;;
constant make-lg (L: ('T)List) : ('T)labeled-graph ;;
constant lg-acyclic (g: ('T)labeled-graph) : Prop ;;
constant is-dag (g: ('T)labeled-graph) : Prop ;;
constant 'T ldag : Type ;;
constant lg-map (f: ('T) -> 'S; g: ('T)labeled-graph) : ('S)labeled-graph ;;
constant lg-all (G: ('T)labeled-graph; P[x: 'T]: Prop) : Prop ;;
constant lg-exists (G: ('T)labeled-graph; P[x: 'T]: Prop) : Prop ;;
constant sv-bag-tail (bs: ('A)Bag) : ('A)Bag ;;
constant lifting-like ('A: Type; f: (('A)Bag) -> ('B)Bag) : Prop ;;
constant lifting2-like ('A: Type; 'B: Type; f: (('A)Bag) -> (('B)Bag) -> ('C)Bag) : Prop ;;
constant bar_fwd_fim (R: ((Int)List) -> Prop) : Prop ;;
constant bar_bwd_fim (R: ((Int)List) -> Prop; A: ((Int)List) -> Prop) : Prop ;;
constant bar_fwd_fim_classical (R: ((Int)List) -> Prop) : Prop ;;
constant bar_bwd_fim_classical (R: ((Int)List) -> Prop; A: ((Int)List) -> Prop) : Prop ;;
constant bar_26_1 (R: ((Int)List) -> Prop) : Prop ;;
constant bar_26_3a (R: ((Int)List) -> Prop) : Prop ;;
constant bar_26_3b : Prop ;;
constant bar_26_4a : Prop ;;
constant gammaFIM (a: ('T6)List; g: (('T6)List) -> Int; h: (('T6)List) -> 'T6) : ('T6)List ;;
constant fan_26_6a : Prop ;;
constant fan_26_7a : Prop ;;
constant brouwer_prin_for_fun_27_1ax : Prop ;;
constant monus (a: Int; b: Int) : Int ;;
constant brouwer_prin_for_num_27_2_orig : Prop ;;
constant brouwer_prin_for_num_27_2 : Prop ;;
constant brouwer_prin_for_num_simpl : Prop ;;
constant brouwer_prin_27_5 : Prop ;;
constant fan_27_7a : Prop ;;
constant fan_wo_dec_27_9 : Prop ;;
constant lift_ctr (f: ('F) -> 'a4) : ((Int) * ('F)) -> (Int) * ('a4) ;;
constant dec_eq_type ('T: Type) : Prop ;;
constant weak_fan_th : Prop ;;
constant aa_list_filter_indices (l: ('T)List) : ((Int) -> Bool) -> ('T)List ;;
constant aa_min_w_unit (u1: Int + Unit; u2: Int + Unit) : Int + Unit ;;
constant aa_max_w_unit (u1: Int + Unit; u2: Int + Unit) : Int + Unit ;;
constant 'T aa_ltree : Type ;;
constant aa_lt_leaf : ('T)aa_ltree ;;
constant aa_lt_node (val: 'T; left_subtree: ('T)aa_ltree; right_subtree: ('T)aa_ltree) : ('T)aa_ltree ;;
constant aa_lt_node-val (x: ('T)aa_ltree) : 'T ;;
constant aa_lt_node-left_subtree (x: ('T)aa_ltree) : ('T)aa_ltree ;;
constant aa_lt_node-right_subtree (x: ('T)aa_ltree) : ('T)aa_ltree ;;
constant aa_max_ltree (t: (Int)aa_ltree) : Int + Unit ;;
constant aa_min_ltree (t: (Int)aa_ltree) : Int + Unit ;;
constant aa_bst_member (i: Int; t: (Int)aa_ltree) : Bool ;;
constant aa_bst_member_prop (i: Int; t: (Int)aa_ltree) : Prop ;;
constant aa_binary_search_tree (t: (Int)aa_ltree) : Prop ;;
constant 'T aa_data_wrapper : Type ;;
constant aa_data_wrapnode (nd: ('T)aa_data_wrapper) : ('T)aa_data_wrapper ;;
constant aa_data_wrapleaf (val: 'T) : ('T)aa_data_wrapper ;;
constant aa_wrapper_get_data (dw: ('T)aa_data_wrapper) : 'T ;;
constant aa_data_wrapnode-nd (x: ('T)aa_data_wrapper) : ('T)aa_data_wrapper ;;
constant aa_data_wrapleaf-val (x: ('T)aa_data_wrapper) : 'T ;;
constant aa_3n_step (t: top) : ((Int) -> Int) -> (Int) -> Int ;;
constant aa_3n_plus_1_rel (ni: Int; no: Int) : Bool ;;
constant aa_capply (p: ('a) * (Int); l: ('a) -> 'a1) : ('a1) * (Int) ;;
constant simple-consensus-state : Type ;;
constant simple-consensus-msg : Type ;;
constant inning_test (t: Int) : (simple-consensus-state) -> (simple-consensus-msg) -> Bool ;;
constant nxt_inning : ((simple-consensus-state) * (simple-consensus-msg)) -> simple-consensus-state ;;
constant inning_step : (simple-consensus-state) -> (simple-consensus-msg) -> simple-consensus-state ;;
constant is-vote-from-inning (i: Int) : (simple-consensus-msg) -> Bool ;;
constant inning_val : ((simple-consensus-state) * (simple-consensus-msg)) -> (Int) * (Int) + Int + Unit ;;
constant simple_consensus_init : simple-consensus-state ;;
constant mlt_simple_consensus_init : (Int) * (((Int)List) * (Int)) ;;
constant inning_vote : (('A) * ('a)) -> 'a ;;
constant 'Op sm-command : Type ;;
constant eq-sm-command (eq: ('Op)Deq) : (('Op)sm-command)Deq ;;
constant 'R sm-response : Type ;;
constant sm-do-ops (s: 'S; f: ('S) -> ('Op) -> ('S) * ('R); L: ('Op)List) : ('S) * (('R)List) ;;
constant sm-class (init: 'S; F[s: 'S; op: 'Op]: ('S) * ('R); X: ('Op)Class) : (('S) * ('R))Class ;;
constant smr-class (init: 'S; F[s: 'S; op: 'Op]: ('S) * ('R); X: ('Op)Class) : ('R)Class ;;
constant request-buffer (Req: ((Int) * ('A))Class) : (('A)List)Class ;;
constant sm-replica (init: 'S; f: ('S) -> ('Op) -> ('S) * ('R); Req: ((Int) * (('Op)sm-command))Class) : ((('R)sm-response)List)Class ;;
constant ballot-id : Type ;;
constant ballot-none : ballot-id ;;
constant mk-ballot (n: Int; ldr: Loc) : ballot-id ;;
constant eq_ballot (b1: ballot-id; b2: ballot-id) : Bool ;;
constant ballot-less (b1: ballot-id; b2: ballot-id) : Bool ;;
constant ballot-max (b1: ballot-id; b2: ballot-id) : ballot-id ;;
constant classPerform ('Op: Type) : ((Int) * (('Op)sm-command))Class ;;
constant class1a : ((Loc) * (ballot-id))Class ;;
constant class2a ('Op: Type) : ((Loc) * ((ballot-id) * ((Int) * (('Op)sm-command))))Class ;;
constant class1b ('Op: Type) : ((Loc) * ((ballot-id) * (((Int) * ((ballot-id) * (('Op)sm-command)))List)))Class ;;
constant class2b (c: Int) : ((Loc) * (ballot-id))Class ;;
constant classChosen : (Int)Class ;;
constant classPreempted : (ballot-id)Class ;;
constant 'T paxos-acceptor-state : Type ;;
constant paxos-state-ballot (s: ('T)paxos-acceptor-state) : Int ;;
constant paxos-state-value (s: ('T)paxos-acceptor-state) : 'T ;;
constant paxos-state-name (s: ('T)paxos-acceptor-state) : Loc ;;
constant paxos-state-info (s: ('T)paxos-acceptor-state) : (Int) * ('T) + Unit ;;
constant paxos-state-reservation (s: ('T)paxos-acceptor-state) : Int ;;
constant leaders-finite (l: (Int) -> Loc) : Prop ;;
constant list_contained-in (L1: ('T)List; L2: ('T)List; 'T: Type) : Prop ;;
constant lex-pair ('S: Type; ord1: ('S) -> ('S) -> Prop; ord2: ('T) -> ('T) -> Prop) : (('S) * ('T)) -> (('S) * ('T)) -> Prop ;;
constant add-bottom (ord: ('T) -> ('T) -> Prop) : ('T + Unit) -> ('T + Unit) -> Prop ;;
constant compat-pair-lists (x: (('S) * ('T))List; y: (('S) * ('T))List; 'S: Type; 'T: Type) : Prop ;;
constant compat-trip-lists (x: (('R) * (('S) * ('T)))List; y: (('R) * (('S) * ('T)))List; 'R: Type; 'S: Type; 'T: Type) : Prop ;;
constant Ballot_Num : Type ;;
constant ballot-lt (Id-lt: (Loc) -> (Loc) -> Prop) : (Ballot_Num) -> (Ballot_Num) -> Prop ;;
constant Cid : Type ;;
constant PaxosOp : Type ;;
constant Command : Type ;;
constant Proposal : Type ;;
constant PValue : Type ;;
constant PVList : Type ;;
constant compat-pvals (bsp: PValue; bsp': PValue) : Prop ;;
constant supercompat-pvals (Id-lt: (Loc) -> (Loc) -> Prop; bsp: PValue; bsp': PValue) : Prop ;;
constant pax_p1a : name ;;
constant pax_p1b : name ;;
constant pax_p2a : name ;;
constant pax_p2b : name ;;
constant pax_preempted : name ;;
constant pax_adopted : name ;;
constant pax_request : name ;;
constant pax_propose : name ;;
constant pax_decision : name ;;
constant pax_response : name ;;
constant pax-message-types ('Result: Type) : ((name) * (Type))List ;;
constant pax-header2type ('Result: Type; hdr: name) : Prop + Unit ;;
constant pax-p2a-msgs : Type ;;
constant pax-p2a-msgs' : Type ;;
constant 'RepState replica-state : Type ;;
constant slot_num (rstate: ('RepState)replica-state) : Int ;;
constant proposals (rstate: ('RepState)replica-state) : (Proposal)List ;;
constant decisions (rstate: ('RepState)replica-state) : (Proposal)List ;;
constant acceptor-state : Type ;;
constant init-acceptor-state : acceptor-state ;;
constant ballot_num (astate: acceptor-state) : Ballot_Num ;;
constant accepted (astate: acceptor-state) : PVList ;;
constant kind_event_ordering : Type ;;
constant ecase1 (e: 'E; info: ('E) -> (Loc) * ('X1) + ((IdLnk) * ('E)) * ('X2); f[i: Loc]: 'T; g[l: IdLnk; e': 'E]: 'T) : 'T ;;
constant loc (info: ('E) -> (Loc) * ('X1) + ((IdLnk) * ('E)) * ('X2); e: 'E) : Loc ;;
constant rcv-from-on (dE: ('E)Deq; dL: (IdLnk)Deq; info: ('E) -> (Loc) * ('X1) + ((IdLnk) * ('E)) * ('X2); e: 'E; l: IdLnk; r: 'E) : Bool ;;
constant kind (info: ('E) -> (Loc) * (Loc) + ((IdLnk) * ('E)) * (Loc); e: 'E) : Knd ;;
constant constant_function (f: ('A) -> 'B; 'A: Type; 'B: Type) : Prop ;;
constant 'MS MachinState_con : Type ;;
constant MachineState : Type ;;
constant paxos_voter_accum : ((Int) * ('B)) -> (Int + (Int) * ('B)) -> (Int) * ('B) ;;
constant esharp-compilation (spec: 'T; pgm: 'T1) : ('T) * ('T1) ;;
constant esharp-update-send (upds: 'updsT; snds: 'sndsT) : ('updsT) * ('sndsT) ;;
constant 'T oprocess : Type ;;
constant 'T process-Msg : Type ;;
constant 'T process-External : Type ;;
constant 'T process-set : Type ;;
constant process-set-locs (Ps: ('T)process-set) : (Loc)List ;;
constant process-external (x: Loc; Ps: ('T)process-set) : ('T)process-External ;;
constant process-msgs-for (x: Loc; M: ('T)process-External) : (('T)process-Msg)List ;;
constant process-newnodes (Ps: ('T)process-set; M: ('T)process-External) : (Loc)List ;;
constant process-inputs (Ps: ('T)process-set; M: ('T)process-External) : ('T)process-set ;;
constant 'T process-event-struct : Type ;;
constant 'T process-event-class : Type ;;
constant process-set-event-class (Ps: ('T)process-set) : ('T)process-event-class ;;
constant pec-combinator (F: ((('T)process-Msg + Unit)List) -> ('T)process-Msg + Unit; Xs: (('T)process-event-class)List) : ('T)process-event-class ;;
constant es_realizer : Type ;;
constant Rnone : es_realizer ;;
constant Rplus (left: es_realizer; right: es_realizer) : es_realizer ;;
constant Rinit (loc: Loc; 'T: Type; x: Loc; v: 'T + (rationals) -> 'T) : es_realizer ;;
constant Rframe (loc: Loc; 'T: Type; x: Loc; L: (Knd)List) : es_realizer ;;
constant Rsframe (lnk: IdLnk; tag: Loc; L: (Knd)List) : es_realizer ;;
constant Raframe (loc: Loc; k: Knd; L: (Loc)List) : es_realizer ;;
constant Rbframe (loc: Loc; k: Knd; L: ((IdLnk) * (Loc))List) : es_realizer ;;
constant Rrframe (loc: Loc; x: Loc; L: (Knd)List) : es_realizer ;;
constant R-plus (A: es_realizer; B: es_realizer) : es_realizer ;;
constant Rtransform (f: (es_realizer) -> es_realizer; A: es_realizer) : es_realizer ;;
constant realizer-skeleton : Type ;;
constant Rlist (L: (es_realizer)List) : es_realizer ;;
constant Rall (L: ('T)List; R[x: 'T]: es_realizer) : es_realizer ;;
constant sem-sat (S: ('Pgm) -> 'Sem; pr: 'Pgm; X: ('Sem) -> Prop) : Prop ;;
constant sem-satisfiable (S: ('Pgm) -> 'Sem; 'Pgm: Type; X: ('Sem) -> Prop) : Prop ;;
constant K-sem (S: ('Pgm) -> 'Sem; equiv: ('Sem) -> ('Sem) -> Prop) : (('Sem) -> 'Pgm) -> ('Sem) -> Prop ;;
constant K-sem-sat ('Sem: Type; equiv: ('Sem) -> ('Sem) -> Prop; S: ('Pgm) -> 'Sem; kpr: ('Sem) -> 'Pgm; X: ('Sem) -> Prop) : Prop ;;
constant K-implements (S: ('Pgm) -> 'Sem; equiv: ('Sem) -> ('Sem) -> Prop; pr: 'Pgm; kpr: ('Sem) -> 'Pgm) : Prop ;;
constant R-size (R: es_realizer) : nat_plus ;;
constant R-has-loc (R: es_realizer; i: Loc) : Bool ;;
constant R-frame-compat (A: es_realizer; B: es_realizer) : Prop ;;
constant R-discrete_compat (A: es_realizer; B: es_realizer) : Prop ;;
constant R-interface-compat (A: es_realizer; B: es_realizer) : Prop ;;
constant R-sends-tags (A: es_realizer) : (Loc)List ;;
constant R-compat (A: es_realizer; B: es_realizer) : Prop ;;
constant R-icompat (A: es_realizer; B: es_realizer) : Prop ;;
constant R-interface (A: es_realizer; B: es_realizer) : Prop ;;
constant R-lnktags (A: es_realizer) : ((IdLnk) * (Loc))List ;;
constant R-hasloc (R: es_realizer) : Bool ;;
constant R-Feasible (R: es_realizer) : Prop ;;
constant R-self-interface (R: es_realizer) : Prop ;;
constant R-sub (A: es_realizer; B: es_realizer) : Prop ;;
constant R-affects (R: es_realizer; x: Loc; i: Loc) : Bool ;;
constant R-occurs (R: es_realizer; i: Loc; z: Loc) : Bool ;;
constant init-allowed (R: es_realizer; x: Loc; i: Loc; discrete: Bool) : Bool ;;
constant frame-allowed (R: es_realizer; i: Loc; x: Loc; L: (Knd)List) : Bool ;;
constant sframe-allowed (R: es_realizer; l: IdLnk; tg: Loc; L: (Knd)List) : Bool ;;
constant rframe-allowed (R: es_realizer; i: Loc; x: Loc; L: (Knd)List) : Bool ;;
constant aframe-allowed (R: es_realizer; i: Loc; k: Knd; L: (Loc)List) : Bool ;;
constant bframe-allowed (R: es_realizer; i: Loc; k: Knd; L: ((IdLnk) * (Loc))List) : Bool ;;
constant effect-allowed (R: es_realizer; k: Knd; x: Loc; i: Loc; discrete: Bool) : Bool ;;
constant sends-allowed (R: es_realizer; k: Knd; l: IdLnk; tgs: (Loc)List) : Bool ;;
constant pre-allowed (R: es_realizer; i: Loc; b: Loc) : Bool ;;
constant write-restricted (R: es_realizer; i: Loc; k: Knd) : Bool ;;
constant write-allowed (R: es_realizer; k: Knd; i: Loc; x: Loc) : Bool ;;
constant send-restricted (R: es_realizer; i: Loc; k: Knd) : Bool ;;
constant send-allowed (R: es_realizer; k: Knd; l: IdLnk; tgs: (Loc)List) : Bool ;;
constant read-restricted (R: es_realizer; i: Loc; y: Loc) : Bool ;;
constant read-allowed (R: es_realizer; k: Knd; i: Loc; ys: (Loc)List) : Bool ;;
constant Rinterface (A: es_realizer) : es_realizer ;;
constant R-has-sends (A: es_realizer) : Bool ;;
constant R-names (R: es_realizer) : (MaName)List ;;
constant R-tags (R: es_realizer) : (Loc)List ;;
constant R-links (R: es_realizer) : (IdLnk)List ;;
constant R-vars (R: es_realizer) : (Loc)List ;;
constant R-restrict (R: es_realizer; names: (MaName)List) : es_realizer ;;
constant R-comb (none: 'A; comb[left: 'A; right: 'A]: 'A; base[b: es_realizer]: 'A; R: es_realizer) : 'A ;;
constant R-compat2 (A: es_realizer; B: es_realizer) : Prop ;;
constant constR ('T: Type; c: 'T; i: Loc) : es_realizer ;;
constant onceR (i: Loc) : es_realizer ;;
constant RealizerScheme : Type ;;
constant scheme-plus (A: RealizerScheme; B: RealizerScheme) : RealizerScheme ;;
constant scheme-compatible (A: RealizerScheme; B: RealizerScheme) : Prop ;;
constant 'T ma-interface : Type ;;
constant ma-interface-locs (I: ('A)ma-interface) : (Loc)List ;;
constant ma-interface-loc (I: ('A)ma-interface; i: Loc) : Bool ;;
constant ma-interface-non-degenerate (I: ('A)ma-interface) : Prop ;;
constant ma-interface-normal ('A: Type; I: ('A)ma-interface) : Prop ;;
constant ma-interface-compose (g: ('A) -> 'B + top; X: ('A)ma-interface) : ('B)ma-interface ;;
constant ma-interface-left (X: ('T + top)ma-interface) : ('T)ma-interface ;;
constant ma-interface-right (X: (top + 'T)ma-interface) : ('T)ma-interface ;;
constant ma-interface-inl (X: ('T)ma-interface) : ('T + top)ma-interface ;;
constant ma-interface-inr (X: ('T)ma-interface) : (top + 'T)ma-interface ;;
constant scheme-constant (R: es_realizer) : RealizerScheme ;;
constant scheme-none : RealizerScheme ;;
constant gluable (I: ('A)ma-interface; l: IdLnk; tg: Loc) : Prop ;;
constant gluable2 ('A: Type; I: ('A)ma-interface; l: IdLnk; tg: Loc) : Prop ;;
constant ma-interface-kinds (I: ('A)ma-interface) : (Knd)List ;;
constant ma-interface-tags (I: ('A)ma-interface) : (Loc)List ;;
constant R-class-state (cp: (top)class-program; x: Loc) : es_realizer ;;
constant intpair-less (x: (Int) * (Int); y: (Int) * (Int)) : Prop ;;
constant w-action-dec (TA: (Loc) -> (Loc) -> Type; M: (IdLnk) -> (Loc) -> Type; i: Loc) : (Knd) -> Type ;;
constant world : Type ;;
constant w-T (w: world) : (Loc) -> (Loc) -> Type ;;
constant w-TA (w: world) : (Loc) -> (Loc) -> Type ;;
constant w-M (w: world) : (IdLnk) -> (Loc) -> Type ;;
constant w-discrete (w: world; i: Loc; x: Loc) : Bool ;;
constant w-atom-constraint (w: world) : Prop ;;
constant w-machine-independent (w: world; i: Loc; k: Knd; x: Loc) : Prop ;;
constant w-discrete-constraint (w: world) : Prop ;;
constant fair-fifo (the_w: world) : Prop ;;
constant msga : Type ;;
constant ma-ds-agree (M: msga; x: Loc; 'T: Type) : Prop ;;
constant ma-decla (M: msga; a: Loc) : Prop ;;
constant ma-declm (M: msga; l: IdLnk; tg: Loc) : Prop ;;
constant ma-da-agree (M: msga; k: Knd; 'T: Type) : Prop ;;
constant ma-init-const (M: msga; x: Loc) : Prop ;;
constant ma-has-pre (M: msga; a: Loc) : Prop ;;
constant ma-sends-on (M: msga; l: IdLnk) : Bool ;;
constant ma-frame (M: msga; k: Knd; x: Loc) : Prop ;;
constant ma-sframe (M: msga; k: Knd; l: IdLnk; tg: Loc) : Prop ;;
constant ma-aframe (M: msga; k: Knd; x: Loc) : Prop ;;
constant ma-bframe (M: msga; k: Knd; ltg: (IdLnk) * (Loc)) : Prop ;;
constant ma-rframe (M: msga; k: Knd; x: Loc) : Prop ;;
constant ma-no-read (M: msga; k: Knd; x: Loc) : Bool ;;
constant ma-prob (M: msga; b: Loc) : finite-prob-space ;;
constant ma-prob-dom (M: msga; b: Loc) : Bool ;;
constant ma-prob-da-dom (M: msga; b: Loc) : Prop ;;
constant ma-sub (M1: msga; M2: msga) : Prop ;;
constant ma-empty : msga ;;
constant ma-disjoint-tags : ((((Loc) * (top))List)List) -> (((Loc) * (top))List) -> Bool ;;
constant pairwise-disjoint-tags (L: (((Loc) * (top))List)List) : Prop ;;
constant ma-compatible (M1: msga; M2: msga) : Prop ;;
constant ma-sends-sv (M: msga) : Prop ;;
constant ma-single-init (x: Loc; 't: Type; v: (rationals) -> 't) : msga ;;
constant ma-single-frame (L: (Knd)List; 't: Type; x: Loc) : msga ;;
constant ma-single-sframe (L: (Knd)List; l: IdLnk; tg: Loc) : msga ;;
constant ma-single-aframe (L: (Loc)List; k: Knd) : msga ;;
constant ma-single-bframe (k: Knd; L: ((IdLnk) * (Loc))List) : msga ;;
constant ma-single-rframe (L: (Knd)List; x: Loc) : msga ;;
constant ma-frame-compat (A: msga; B: msga) : Prop ;;
constant ma-frame-compatible (A: msga; B: msga) : Prop ;;
constant ma-prob-da (M: msga) : Prop ;;
constant ma-feasible-send (M: msga) : Prop ;;
constant ma-feasible (M: msga) : Prop ;;
constant ma-compat (A: msga; B: msga) : Prop ;;
constant dsys : Type ;;
constant d-eq-Loc (i: Loc; j: Loc) : Bool ;;
constant d-m (D: dsys; i: Loc) : msga ;;
constant d-decl (D: dsys; i: Loc) : (Knd) -> Type ;;
constant d-sub (D1: dsys; D2: dsys) : Prop ;;
constant d-single-init (i: Loc; x: Loc; 'T: Type; v: (rationals) -> 'T) : dsys ;;
constant d-single-frame (i: Loc; L: (Knd)List; 't: Type; x: Loc) : dsys ;;
constant d-single-aframe (i: Loc; L: (Loc)List; k: Knd) : dsys ;;
constant d-single-bframe (i: Loc; L: ((IdLnk) * (Loc))List; k: Knd) : dsys ;;
constant d-single-rframe (i: Loc; L: (Knd)List; x: Loc) : dsys ;;
constant d-single-sframe (i: Loc; L: (Knd)List; l: IdLnk; tg: Loc) : dsys ;;
constant d-feasible (D: dsys) : Prop ;;
constant d-feasible-discrete (D: dsys; discrete: (Loc) -> (Loc) -> Bool) : Prop ;;
constant possible-world (D: dsys; w: world) : Prop ;;
constant msystem : Type ;;
constant m-sys-null : msystem ;;
constant es-class (dd: es-decl-set; 'T: Type) : Prop ;;
